{"meta":{"title":"Yun Chen Blog","subtitle":"A log about a developer.","description":"A log about a developer.","author":"Yun Chen","url":"https://blog.yunchen.tw"},"pages":[],"posts":[{"title":"Search a 2D Matrix II","slug":"search-a-2D-matrix-II","date":"2017-07-19T16:00:00.000Z","updated":"2017-07-21T15:54:39.000Z","comments":true,"path":"2017/07/20/search-a-2D-matrix-II/","link":"","permalink":"https://blog.yunchen.tw/2017/07/20/search-a-2D-matrix-II/","excerpt":"","text":"Search a 2D Matrix IIWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. For example:Consider the following matrix: 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] Given target = 5, return true. Given target = 20, return false. Default:123func searchMatrix(matrix [][]int, target int) bool &#123;&#125; 解答思路:先前雖然有Search a 2D Matrix，不過當時不但右邊的元素一律比左邊大，而且下面整列的所有元素一律比上面的元素來的大，因此可以透過兩次二分法來推出目標值是落在x軸與y軸的哪個位置且是否存在，不過這次只能保證該元素的正下方比較大，所以只能從頭開始與鄰近的元素一一作比較並逐步靠進目標值，而唯一要注意的就是開始比較的位置，從最左上角開始的話，如果目標值比較大而需要往值大的地方移動時，往下或往右便成了問題，並且無法確保用最少的移動數到達目標值，但如果從最右上角開始的話所有的問題便都解決了，如果目標值比較大而需要往值大的地方移動時就只能往下移動(因為已經在最右邊了)，而如果目標值比較小而需要往值小的地方移動也就只能往左邊移動，如此一來就可以用最簡單的方式及最快的路徑到達目標值，最後當移動到超出二元陣列範圍外時便能確定此值不存在。 程式碼解說:一開始先判斷二元陣列是否為空，如果是便直接回傳false，否則就先初始化二元陣列最右上角的位置，接著便以此做為起點逐步靠進目標值，如果元素值與目標值相等便回傳true，而如果元素值比目標值大便往左邊移動，元素值比目標值小便往下面移動，不斷重覆上述動作直到發現目標值為止，最後當移動到超出二元陣列範圍外時便能確定此值不存在回傳false 1234567891011121314151617if len(matrix) == 0 &#123; return false&#125;var y intvar element intx := len(matrix[0]) - 1for x &gt;= 0 &amp;&amp; y &lt; len(matrix) &#123; element = matrix[y][x] if element == target &#123; return true &#125; else if element &gt; target &#123; x-- &#125; else &#123; y++ &#125;&#125;return false 完整程式碼:12345678910111213141516171819func searchMatrix(matrix [][]int, target int) bool &#123; if len(matrix) == 0 &#123; return false &#125; var y int var element int x := len(matrix[0]) - 1 for x &gt;= 0 &amp;&amp; y &lt; len(matrix) &#123; element = matrix[y][x] if element == target &#123; return true &#125; else if element &gt; target &#123; x-- &#125; else &#123; y++ &#125; &#125; return false&#125; 總結:要從排序的二元陣列(右邊的元素一律比左邊大，元素的正下方比上面的位置大，但並非整列的所有元素比上列大)中找出目標值，其做法只能從頭開始與鄰近的元素一一作比較並逐步靠進目標值，開始比較的位置如果從最右上角開始的話就可以用最簡單的方式及最快的路徑到達目標值，如果目標值比較大而需要往值大的地方移動時就只能往下移動，而如果目標值比較小而需要往值小的地方移動也就只能往左邊移動，最後當移動到超出二元陣列範圍外時便能確定此值不存在。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"DivideAndConquer","slug":"DivideAndConquer","permalink":"https://blog.yunchen.tw/tags/DivideAndConquer/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://blog.yunchen.tw/tags/BinarySearch/"}]},{"title":"Product of Array Except Self","slug":"product-of-array-except-self","date":"2017-07-17T16:00:00.000Z","updated":"2017-07-19T16:58:05.000Z","comments":true,"path":"2017/07/18/product-of-array-except-self/","link":"","permalink":"https://blog.yunchen.tw/2017/07/18/product-of-array-except-self/","excerpt":"","text":"Product of Array Except SelfGiven an array of n integers where n &gt; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Solve it without division and in O(n). For example:Given [1,2,3,4], return [24,12,8,6]. Follow up: Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.) 提示 解題應用 Array Array/Slice Default:123func productExceptSelf(nums []int) []int &#123;&#125; 解答思路:要回傳一個與原數列相同長度的陣列，且其每個元素是不包含原數列位置所有其它值的乘積，如果沒有其它限制的話就只要先全數遍歷一次數列得到所有元素的乘積，接著只要再分別將所有元素的乘積對每個元素的值相除，並放入對應的陣列位置就搞定，不過當然底下有要求要在時間複雜度為O(n)，空間複雜度為O(1)(不包含要回傳的陣列空間)，且最重要的是不能用”/“這個運算子，所以只能以其它方式來處理，仔細想想會發現如果要不包含原數列位置的乘積，那就是在”該位置之前所有元素的乘積”乘上”該位置之後所有元素的乘積”，而”該位置之前所有元素的乘積”其實就是紀錄開頭到前一個位置的所有元素乘積，反之”該位置之後所有元素的乘積”就是紀錄結尾到後一個位置的所有元素乘積，所以只要遍歷兩次數列，第一次先從頭開始遍歷，並在結果陣列中的每個位置上紀錄開頭到前一個位置的所有元素乘積，接著第二次則是從結尾開始遍歷，將”該位置之後所有元素的乘積”的暫存值與結果陣列其位置上所儲存的”該位置之前所有元素的乘積”相乘就會是目標要求每個元素的結果。 程式碼解說:一開始先初始化一個與原數列相同長度的結果陣列，接下來要在陣列的每個位置上紀錄”該位置之前所有元素的乘積”，而這邊實際的做法是每當從數列取出一個值，便將該值與該值所對應結果陣列位置的值相乘作為下一個在結果陣列位置上的值，一直取到數列的倒數第二個值為止(因為結果陣列最後一個值是數列開頭到倒數第二個元素之間的相乘)，而記得要將結果陣列的第一個元素初始化為1，才不後導致後續的結果全數為0 12345output := make([]int, len(nums))output[0] = 1for i, v := range nums[:len(nums)-1] &#123; output[i+1] = output[i] * v&#125; 接著則是從結尾開始遍歷並初始化一暫存值為1，與上述同理只取到數列的第二個值為止，”該位置之後所有元素的乘積”與”該位置之前所有元素的乘積”相乘就會是目標要求每個元素的結果，這邊實際的做法是暫存值紀錄結尾到取出元素之間的相乘，而前一個在結果陣列位置上的值就是其值(前一個在結果陣列位置上的值)與暫存值相乘 12345678tmp := 1i := len(nums) - 1for i &gt; 0 &#123; tmp *= nums[i] output[i-1] *= tmp i--&#125;return output 完整程式碼:123456789101112131415func productExceptSelf(nums []int) []int &#123; output := make([]int, len(nums)) output[0] = 1 for i, v := range nums[:len(nums)-1] &#123; output[i+1] = output[i] * v &#125; tmp := 1 i := len(nums) - 1 for i &gt; 0 &#123; tmp *= nums[i] output[i-1] *= tmp i-- &#125; return output&#125; 總結:要回傳一個與原數列相同長度的陣列，其每個元素是不包含原數列位置所有其它值的乘積，且時間複雜度為O(n)，空間複雜度為O(1)(不包含要回傳的陣列空間)，最重要的是不能用”/“這個運算子，而其做法總共要遍歷兩次數列，第一次先從頭開始遍歷，並在結果陣列中的每個位置上紀錄開頭到前一個位置的所有元素乘積，接著第二次則是從結尾開始遍歷，將”該位置之後所有元素的乘積”的暫存值與結果陣列其位置上所儲存的”該位置之前所有元素的乘積”相乘就會是目標要求每個元素的結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"}]},{"title":"Kth Smallest Element in a BST","slug":"Kth-smallest-element-in-a-BST","date":"2017-07-16T16:00:00.000Z","updated":"2017-07-19T13:53:45.000Z","comments":true,"path":"2017/07/17/Kth-smallest-element-in-a-BST/","link":"","permalink":"https://blog.yunchen.tw/2017/07/17/Kth-smallest-element-in-a-BST/","excerpt":"","text":"Kth Smallest Element in a BSTGiven a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note: You may assume k is always valid, 1 ? k ? BST’s total elements. Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? 提示 解題應用 Tree InorderTravel Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func kthSmallest(root *TreeNode, k int) int &#123;&#125; 解答思路:如果有一棵二元搜尋樹要找出第k個大的元素，基本上就只要透過中序遍歷就會得到一個由小排序至大的數列，此時再根據題目所需找出第k個大的目標，數列所對應到的第k個位置就會是我們要的結果。 程式碼解說:如思路所述，一開始便透過中序遍歷(由遞回函數實作，第一個參數為節點的位置，而第二個參數則是目前已排序的數列)來從二元搜尋樹取得所有節點值由小排序至大的數列，有了排序數列的話，最後再根據所需目標找出對應數列中的第k個位置就會是我們要的結果 1234func kthSmallest(root *TreeNode, k int) int &#123; sortList := inOrderTravel(root, []int&#123;&#125;) return sortList[k-1]&#125; 至於實作中序遍歷的遞回函數細節，先檢查帶入的節點是否為nil，如果是便直接向上回傳原本所帶入的排序數列，否則繼續向下做中序遍歷，將左子節點與數列帶入遞回函數得到新的數列之後，再對目前的節點做處理(將節點值放入數列後頭)，接著才是將右子節點與數列帶入遞回函數，最後如果節點與其左右子樹的值都處理完畢，便向上回傳整個排序數列 123456789func inOrderTravel(node *TreeNode, list []int) []int &#123; if node == nil &#123; return list &#125; list = inOrderTravel(node.Left, list) list = append(list, node.Val) list = inOrderTravel(node.Right, list) return list&#125; 完整程式碼:12345678910111213func kthSmallest(root *TreeNode, k int) int &#123; sortList := inOrderTravel(root, []int&#123;&#125;) return sortList[k-1]&#125;func inOrderTravel(node *TreeNode, list []int) []int &#123; if node == nil &#123; return list &#125; list = inOrderTravel(node.Left, list) list = append(list, node.Val) list = inOrderTravel(node.Right, list) return list&#125; 總結:若二元搜尋樹要找出第k個大的元素，基本上就只要透過中序遍歷就會得到一個由小排序至大的數列，此時再根據題目所需找出第k個大的目標，數列所對應到的第k個位置就會是我們要的結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://blog.yunchen.tw/tags/BinarySearch/"}]},{"title":"Majority Element II","slug":"majority-element-II","date":"2017-07-15T16:00:00.000Z","updated":"2017-07-16T16:49:17.000Z","comments":true,"path":"2017/07/16/majority-element-II/","link":"","permalink":"https://blog.yunchen.tw/2017/07/16/majority-element-II/","excerpt":"","text":"Majority Element IIGiven an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space. 提示 解題應用 Array Array/Slice Default:123func majorityElement(nums []int) []int &#123;&#125; 解答思路:之前雖然有一篇Majority Element，不過當時是直接採用hashmap的方式來統計結果，但如果要只用O(1)的空間複雜度的話，基本上就是用互相抵消的方式來處理，也就是說先取第一個元素為基準(此時計數器初始為1)，如果碰到相同的元素就將計數器+1，碰到不同的就將計數器-1，當計數器歸0便以下一個元素為基準重新計算，遍歷完之後其基準值就會是結果(因為最多的元素超過一半，透過抵消的方式最後一定只剩下該元素)，上述的方式同樣也可以利用在這題要找出超過1/3總數的基準值(時間複雜度O(n)及空間複雜度O(1))，可想而之能超過1/3的基準值頂多只會有兩個，所以這次就只要設兩個基準值、兩個計數器來找出最多的兩個元素即可，不過最後還要再針對這個兩元素重新遍歷一次數列，並各別計算兩個的數量，因為雖然是最多的兩個元素，但也有可能其中一個特別多而導致另一個總數未超過1/3。 程式碼解說:如思路所述，設定兩個基準值、兩個計數器來找出最多的兩個元素，不過並不需要為兩個基準值做初始化，因為兩個計數器一開始都為0，之後遍歷時會發現計數器為0而將取出的元素作為其對應的新基準值，接下來就是遍歷整個數列，如果碰到與基準值相同的元素就將對應的計數器+1，碰到都不同的就將兩個計數器-1，當有計數器歸0便以下一個元素為其對應的新基準值重新計算，這邊要注意取出任一基準值的元素時，不要將另一個基準值的計數器-1，否則會導致最多的兩個元素互相抵消而被取代 123456789101112131415161718192021var count1 intvar count2 intvar candidate1 intvar candidate2 intvar major []intfor _, v := range nums &#123; if v == candidate1 &#123; count1++ &#125; else if v == candidate2 &#123; count2++ &#125; else if count1 == 0 &#123; candidate1 = v count1++ &#125; else if count2 == 0 &#123; candidate2 = v count2++ &#125; else &#123; count1-- count2-- &#125;&#125; 遍歷完之後兩個的基準值就會是最多的兩個元素，還要再針對這個兩元素重新遍歷一次數列，並各別計算兩個的數量(在那之前要記得先重置兩個計數器為0)，最後再判斷兩個元素各別的數量是否超過總數的1/3，如果有才將其放入結果陣列之中 12345678910111213141516count1 = 0count2 = 0for _, v := range nums &#123; if v == candidate1 &#123; count1++ &#125; else if v == candidate2 &#123; count2++ &#125;&#125;if count1 &gt; len(nums)/3 &#123; major = append(major, candidate1)&#125;if count2 &gt; len(nums)/3 &#123; major = append(major, candidate2)&#125;return major 完整程式碼:123456789101112131415161718192021222324252627282930313233343536373839func majorityElement(nums []int) []int &#123; var count1 int var count2 int var candidate1 int var candidate2 int var major []int for _, v := range nums &#123; if v == candidate1 &#123; count1++ &#125; else if v == candidate2 &#123; count2++ &#125; else if count1 == 0 &#123; candidate1 = v count1++ &#125; else if count2 == 0 &#123; candidate2 = v count2++ &#125; else &#123; count1-- count2-- &#125; &#125; count1 = 0 count2 = 0 for _, v := range nums &#123; if v == candidate1 &#123; count1++ &#125; else if v == candidate2 &#123; count2++ &#125; &#125; if count1 &gt; len(nums)/3 &#123; major = append(major, candidate1) &#125; if count2 &gt; len(nums)/3 &#123; major = append(major, candidate2) &#125; return major&#125; 總結:要從一數列中找出超過1/3總數的元素，且其時間複雜度為O(n)及空間複雜度為O(1)，可想而之能超過1/3總數的元素最多只會有兩個，而基本上就是用互相抵消的方式來處理，設定兩個基準值、兩個計數器來找出最多的兩個元素，如果碰到與基準值相同的元素就將對應的計數器+1，碰到都不同的就將兩個計數器-1，當有計數器歸0便以下一個元素為其對應的新基準值重新計算，遍歷完之後兩個的基準值就會是最多的兩個元素，不過最後還要再針對這個兩元素重新遍歷一次數列，並各別計算兩個的數量，因為有可能其中一個特別多而導致另一個總數未超過1/3。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"}]},{"title":"Summary Ranges","slug":"summary-ranges","date":"2017-07-14T16:00:00.000Z","updated":"2017-07-15T15:39:13.000Z","comments":true,"path":"2017/07/15/summary-ranges/","link":"","permalink":"https://blog.yunchen.tw/2017/07/15/summary-ranges/","excerpt":"","text":"Summary RangesGiven a sorted integer array without duplicates, return the summary of its ranges. For example:12345Given [0,1,2,4,5,7],return [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]. 提示 解題應用 Array Array/Slice Default:123func summaryRanges(nums []int) []string &#123;&#125; 解答思路:要將數列中的連續範圍給一一分別歸納出來，就只要一邊遍歷一邊確認當下的數字是否與前一個連續，如果是就更新先前所儲存的範圍，一直到發現不為連續的數字才又新增一個新的範圍，並將其值做為範圍的起始值，待遍歷結束後便回傳歸納出的各別範圍結果。 程式碼解說:一開始先判斷數列是否為空，如果是便回傳空的字串陣列，否則就先將第一個數字放入計數器之中，再將其轉為字串型別做為範圍的起始值，並記得放入結果陣列之中做為初始的範圍，接著從數列的第二個值開始遍歷，不過因為是要核對當下的數字是否與前一個連續(比較前一個數+1是否與其相同)，所以遍歷之前還要記得再將計數器+1以利後續比較，如果為連續的數字就更新先前所儲存的範圍(更新範圍的結尾值)，一直到發現不為連續的數字才又新增一個新的範圍，並將其值做為範圍與計數器的起始值，待遍歷結束後便回傳歸納出的各別範圍結果 123456789101112131415161718if len(nums) == 0 &#123; return []string&#123;&#125;&#125;count := nums[0]start := strconv.Itoa(count)ranges := []string&#123;start&#125;count++for _, v := range nums[1:] &#123; if v == count &#123; ranges[len(ranges)-1] = start + \"-&gt;\" + strconv.Itoa(v) &#125; else &#123; start = strconv.Itoa(v) ranges = append(ranges, start) count = v &#125; count++&#125;return ranges 完整程式碼:1234567891011121314151617181920func summaryRanges(nums []int) []string &#123; if len(nums) == 0 &#123; return []string&#123;&#125; &#125; count := nums[0] start := strconv.Itoa(count) ranges := []string&#123;start&#125; count++ for _, v := range nums[1:] &#123; if v == count &#123; ranges[len(ranges)-1] = start + \"-&gt;\" + strconv.Itoa(v) &#125; else &#123; start = strconv.Itoa(v) ranges = append(ranges, start) count = v &#125; count++ &#125; return ranges&#125; 總結:有一經由排序並不包含重覆值的數列，要將數列中的連續範圍給一一分別歸納出來，就只要一邊遍歷一邊確認當下的數字是否與前一個連續，如果是就更新先前所儲存的範圍，一直到發現不為連續的數字才又新增一個新的範圍，並將其值做為範圍的起始值，待遍歷結束後便回傳歸納出的各別範圍結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"}]},{"title":"Basic Calculator II","slug":"basic-calculator-II","date":"2017-07-13T16:00:00.000Z","updated":"2017-07-14T16:46:15.000Z","comments":true,"path":"2017/07/14/basic-calculator-II/","link":"","permalink":"https://blog.yunchen.tw/2017/07/14/basic-calculator-II/","excerpt":"","text":"Basic Calculator IIImplement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero. You may assume that the given expression is always valid. For examples:123&quot;3+2*2&quot; = 7&quot; 3/2 &quot; = 1&quot; 3+5 / 2 &quot; = 5 Note: Do not use the eval built-in library function. 提示 解題應用 String Reverse Polish Notation Default:123func calculate(s string) int &#123;&#125; 解答思路:給一四則運算的算式要求出結果，對於人來說要處理這種一般先乘除後加減的算式(中置式)相當容易，但對程式來說就比較困難，所以就需要先將算式轉化成程式比較容易處理的後置式之後再運算，先前有一篇Evaluate Reverse Polish Notation就是將後置式的結果做運算，總而言之如果要將一般的算式給程式做運算最主要分為兩個步驟，第一個就是將中置式轉為後置式，先遍歷原本的算式，碰到運算元就直接輸出，而碰到運算子就放入stack之中，如果stack已經有運算子在裡頭就與其比較優先順序(*,/的優先順序相同且比+,-大)，如果stack的比較大或相同就不斷的輸出，直到出現優先順序比較小的為止才放入stack，待算式轉為後置式接下來就是第二個步驟，將後置式的結果做運算(細節可以參考前一篇的實作)，遍歷後置式的算式，只要碰到運算元就放入stack之中，碰到運算子才從stack中取出兩個運算元做計算，並再將得到的結果再次放回stack，最後遍歷結束後在stack中唯一一個剩下的運算元就是我們要的結果。 程式碼解說:不論是先將中置式轉為後置式，還是將後置式的結果做運算都會用上stack，所以就先定義好stack的結構，這邊是以LinkedList來實作，而一開始就先將算式帶入toRPN轉為後置式，之後其回傳的結果再帶入evalRPN去做運算，最後便能得到算式的答案 1234567type StackNode struct &#123; Val string Next *StackNode&#125;func calculate(s string) int &#123; return evalRPN(toRPN(s))&#125; 要將中置式轉為後置式，先遍歷原本的算式，如果取出的字元為空白字元就跳過，取出的是運算子且為+,-的話，就不斷的將stack中的運算子輸出(因為優先順序相同或比較大輸出，而+,-是所有順序中最小的)，直到全數輸出完畢才放入stack，但取出的運算子為,/的話，就只能輸出\\,/的運算子直到出現+,-(優先順序比較小)為止才放入stack，如果取出的是數字，就要再檢查下一個值是否為是數字，因為我們遍歷字串是一個個字元取出沒辦法判斷運算元有多長，所以就只能不斷取到下一個字元為空白或運算子為止才將整個運算元輸出，最後待遍歷結束後要再檢查stack中是否還有剩餘的運算子，有的話便一律輸出才回傳整個後置式 123456789101112131415161718192021222324252627282930313233343536func toRPN(s string) []string &#123; var str string var num string var RPN []string var top *StackNode for i, v := range s &#123; str = string(v) if str == \" \" &#123; continue &#125; else if str == \"+\" || str == \"-\" &#123; for top != nil &#123; RPN = append(RPN, top.Val) top = top.Next &#125; top = &amp;StackNode&#123;str, top&#125; &#125; else if str == \"*\" || str == \"/\" &#123; for top != nil &amp;&amp; (top.Val == \"*\" || top.Val == \"/\") &#123; RPN = append(RPN, top.Val) top = top.Next &#125; top = &amp;StackNode&#123;str, top&#125; &#125; else &#123; num += str if i+1 &lt; len(s) &amp;&amp; s[i+1] &gt;= 48 &amp;&amp; s[i+1] &lt;= 57 &#123; continue &#125; RPN = append(RPN, num) num = \"\" &#125; &#125; for top != nil &#123; RPN = append(RPN, top.Val) top = top.Next &#125; return RPN&#125; 這邊的程式碼與先前求RPN的結果大致相同，詳細的說明可以參考前一篇，唯一的差別是為了與中置式轉為後置式時所使用的stack有相同的結構，因此存放進stack的運算元都是字串型別，待取出做運算時才將其轉為數字型別 1234567891011121314151617181920212223242526272829303132func evalRPN(tokens []string) int &#123; var tmp int var numFront int var numBack int var top *StackNode var newNode *StackNode for _, v := range tokens &#123; if v == \"+\" || v == \"-\" || v == \"*\" || v == \"/\" &#123; numBack, _ = strconv.Atoi(top.Val) top = top.Next numFront, _ = strconv.Atoi(top.Val) top = top.Next switch v &#123; case \"+\": tmp = numFront + numBack case \"-\": tmp = numFront - numBack case \"*\": tmp = numFront * numBack case \"/\": tmp = numFront / numBack &#125; newNode = &amp;StackNode&#123;strconv.Itoa(tmp), top&#125; top = newNode &#125; else &#123; newNode = &amp;StackNode&#123;v, top&#125; top = newNode &#125; &#125; tmp, _ = strconv.Atoi(top.Val) return tmp&#125; 完整程式碼:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475type StackNode struct &#123; Val string Next *StackNode&#125;func calculate(s string) int &#123; return evalRPN(toRPN(s))&#125;func toRPN(s string) []string &#123; var str string var num string var RPN []string var top *StackNode for i, v := range s &#123; str = string(v) if str == \" \" &#123; continue &#125; else if str == \"+\" || str == \"-\" &#123; for top != nil &#123; RPN = append(RPN, top.Val) top = top.Next &#125; top = &amp;StackNode&#123;str, top&#125; &#125; else if str == \"*\" || str == \"/\" &#123; for top != nil &amp;&amp; (top.Val == \"*\" || top.Val == \"/\") &#123; RPN = append(RPN, top.Val) top = top.Next &#125; top = &amp;StackNode&#123;str, top&#125; &#125; else &#123; num += str if i+1 &lt; len(s) &amp;&amp; s[i+1] &gt;= 48 &amp;&amp; s[i+1] &lt;= 57 &#123; continue &#125; RPN = append(RPN, num) num = \"\" &#125; &#125; for top != nil &#123; RPN = append(RPN, top.Val) top = top.Next &#125; return RPN&#125;func evalRPN(tokens []string) int &#123; var tmp int var numFront int var numBack int var top *StackNode var newNode *StackNode for _, v := range tokens &#123; if v == \"+\" || v == \"-\" || v == \"*\" || v == \"/\" &#123; numBack, _ = strconv.Atoi(top.Val) top = top.Next numFront, _ = strconv.Atoi(top.Val) top = top.Next switch v &#123; case \"+\": tmp = numFront + numBack case \"-\": tmp = numFront - numBack case \"*\": tmp = numFront * numBack case \"/\": tmp = numFront / numBack &#125; newNode = &amp;StackNode&#123;strconv.Itoa(tmp), top&#125; top = newNode &#125; else &#123; newNode = &amp;StackNode&#123;v, top&#125; top = newNode &#125; &#125; tmp, _ = strconv.Atoi(top.Val) return tmp&#125; 總結:要求出四則運算算式(中置式)的結果最主要分為兩個步驟，第一個就是將中置式轉為後置式(RPN)，遍歷原本的算式，碰到運算元就直接輸出，而碰到運算子就與stack裡的運算子比較優先順序，如果stack的比較大或相同就不斷的輸出，直到出現優先順序比較小的為止才放入stack，待算式轉為後置式接下來就是第二個步驟將後置式的結果做運算，遍歷後置式的算式，只要碰到運算元就放入stack之中，碰到運算子才從stack中取出兩個運算元做計算，並再將得到的結果再次放回stack，最後遍歷結束後在stack中唯一一個剩下的運算元就是我們要的結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"}]},{"title":"Rectangle Area","slug":"rectangle-area","date":"2017-07-12T16:00:00.000Z","updated":"2017-07-13T14:37:24.000Z","comments":true,"path":"2017/07/13/rectangle-area/","link":"","permalink":"https://blog.yunchen.tw/2017/07/13/rectangle-area/","excerpt":"","text":"Rectangle AreaFind the total area covered by two rectilinear rectangles in a 2D plane. Each rectangle is defined by its bottom left corner and top right corner as shown in the figure. Assume that the total area is never beyond the maximum possible value of int. 提示 解題應用 Math 規律觀查 Default:123func computeArea(A int, B int, C int, D int, E int, F int, G int, H int) int &#123;&#125; 解答思路:要算出一平面上兩個矩形所圍出的面積，當然就是分別將兩個的長與寬相乘後做相加，然而如果兩個矩形發生重疊的話將會導致該塊面積重覆做計算，因此萬一有重疊的話就必需要算出重疊的面積然後將其減去，至於要找出重疊面積的長與寬，以範例的圖來說，仔細觀查會發現到重疊部分左邊的邊其X軸的位置會是E，因為E比A大，但如果是下圖的話: 左邊的X軸位置會是A，因為A比E大，因此要找左邊的X軸就是比較A與E誰大，反之要找右邊的X軸就是比較C與G誰小，同理要找下方的Y軸就是比較B與F誰大，上方的Y軸就是比較D與H誰小，有了各邊的X軸與Y軸位置自然可以得出四個點座標，甚至可以推出該重疊面積，最後只要判斷右邊是否比左邊的X軸位置大，上方是否比下方的Y軸位置大就可以得知兩矩形是否產生重疊，進而決定是否要減去重疊的面積。 程式碼解說:如思路所述，先分別將兩個矩形的長與寬相乘後做相加，再求重疊矩形的相對位置，其中重疊矩形左邊的X軸就是比較A與E誰大，右邊的X軸就是比較C與G誰小，下方的Y軸就是比較B與F誰大，上方的Y軸就是比較D與H誰小，最後只要判斷右邊是否比左邊的X軸位置大，上方是否比下方的Y軸位置大就可以得知兩矩形是否產生重疊，進而決定是否要減去重疊的面積 1234567891011func computeArea(A int, B int, C int, D int, E int, F int, G int, H int) int &#123; area := (C-A)*(D-B) + (G-E)*(H-F) left := max(A, E) right := min(C, G) bottom := max(B, F) top := min(D, H) if right &gt; left &amp;&amp; top &gt; bottom &#123; return area - (right-left)*(top-bottom) &#125; return area&#125; 這部分就只是單純實作了比較兩個值的大小，並回傳對應的大小值 123456789101112func max(a int, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;func min(a int, b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125; 完整程式碼:1234567891011121314151617181920212223func computeArea(A int, B int, C int, D int, E int, F int, G int, H int) int &#123; area := (C-A)*(D-B) + (G-E)*(H-F) left := max(A, E) right := min(C, G) bottom := max(B, F) top := min(D, H) if right &gt; left &amp;&amp; top &gt; bottom &#123; return area - (right-left)*(top-bottom) &#125; return area&#125;func max(a int, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;func min(a int, b int) int &#123; if a &lt; b &#123; return a &#125; return b&#125; 總結:要算出一平面上兩個矩形所圍出的面積，先分別將兩個矩形的長與寬相乘後做相加，再藉由兩矩形的頂點座標進而推出重疊矩形的相對位置(座標)，最後透過重疊矩形的相對位置來判斷是否產生重疊，並決定是否要減去重疊的面積(細節請參考解答思路)。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"Maximal Square","slug":"maximal-square","date":"2017-07-10T16:00:00.000Z","updated":"2017-07-12T15:14:59.000Z","comments":true,"path":"2017/07/11/maximal-square/","link":"","permalink":"https://blog.yunchen.tw/2017/07/11/maximal-square/","excerpt":"","text":"Maximal SquareGiven a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. For example:Given the following matrix: 12341 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0 Return 4. Default:123func maximalSquare(matrix [][]byte) int &#123;&#125; 解答思路:要從一平面中找可圍出的最大正方形面積，只要從邊長為1開始找起，每當遍歷一個新的值時，就將該位置當作正方形最左上角的位置，檢查該正方形是否符合條件，如果是就記錄當下邊長所圍出的面積，再從頭遍歷整個二元陣列以找更長一點的邊長，而如果不符合條件則繼續往下遍歷，以下一個值來做為新正方形最左上角的位置，直到全數遍歷結束如果還是沒有找到該邊長符合條件的正方形，此時便直接回傳目前所找到的最大面積，因為如果面積較小的正方形不存在，鐵定不會有更大面積的正方形。 程式碼解說:一開始就從邊長為1開始，最多只能找到邊長跟整個平面的邊一樣大為止，之後以巢狀迴圈遍歷整個平面的值，每當遍歷一個新的值時，就將該位置當作正方形最左上角的位置，檢查該正方形是否符合條件，先判斷該正方形是否位於平面之中，再檢查正方形範圍內的值是否皆為1(這邊是帶入其它的函數來檢查)，如果都符合條件就記錄當下邊長所圍出的面積，再跳開巢狀迴圈從頭遍歷整個二元陣列以找更長一點的邊長，而如果直到全數遍歷結束還是沒有找到該邊長符合條件的正方形，此時便直接回傳目前所找到的最大面積 123456789101112131415161718192021222324252627func maximalSquare(matrix [][]byte) int &#123; var exist bool var maxArea int for side := 1; side &lt;= len(matrix); side++ &#123; exist = false for i := 0; i &lt; len(matrix); i++ &#123; for j := 0; j &lt; len(matrix[0]); j++ &#123; if i+side &lt;= len(matrix) &amp;&amp; j+side &lt;= len(matrix[0]) &#123; if checkSquare(matrix, i, j, side) &#123; exist = true maxArea = side * side break &#125; &#125; else &#123; break &#125; &#125; if exist &#123; break &#125; &#125; if !exist &#123; break &#125; &#125; return maxArea&#125; 這部分則是用來檢查正方形範圍內的值是否皆為1，如果出現值不等於1時便直接回傳false，否則直到全數範圍檢查完畢才回傳true 12345678910func checkSquare(matrix [][]byte, y int, x int, side int) bool &#123; for i := y; i &lt; y+side; i++ &#123; for j := x; j &lt; x+side; j++ &#123; if matrix[i][j] != '1' &#123; return false &#125; &#125; &#125; return true&#125; 完整程式碼:12345678910111213141516171819202122232425262728293031323334353637func maximalSquare(matrix [][]byte) int &#123; var exist bool var maxArea int for side := 1; side &lt;= len(matrix); side++ &#123; exist = false for i := 0; i &lt; len(matrix); i++ &#123; for j := 0; j &lt; len(matrix[0]); j++ &#123; if i+side &lt;= len(matrix) &amp;&amp; j+side &lt;= len(matrix[0]) &#123; if checkSquare(matrix, i, j, side) &#123; exist = true maxArea = side * side break &#125; &#125; else &#123; break &#125; &#125; if exist &#123; break &#125; &#125; if !exist &#123; break &#125; &#125; return maxArea&#125;func checkSquare(matrix [][]byte, y int, x int, side int) bool &#123; for i := y; i &lt; y+side; i++ &#123; for j := x; j &lt; x+side; j++ &#123; if matrix[i][j] != '1' &#123; return false &#125; &#125; &#125; return true&#125; 總結:要從一平面中找可圍出的最大正方形面積，只要從邊長為1開始找起，每遍歷一個新的值就將該位置當作正方形最左上角的位置，檢查該正方形是否符合條件，如果是就記錄當下邊長所圍出的面積，再從頭遍歷整個二元陣列以找更長一點的邊長，而如果不符合條件則繼續往下遍歷，以下一個值來做為新正方形最左上角的位置，直到全數遍歷結束如果還是沒有找到該邊長符合條件的正方形，此時便直接回傳目前所找到的最大面積。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"https://blog.yunchen.tw/tags/DynamicProgramming/"}]},{"title":"Combination Sum III","slug":"combination-sum-III","date":"2017-07-09T16:00:00.000Z","updated":"2017-07-10T08:07:15.000Z","comments":true,"path":"2017/07/10/combination-sum-III/","link":"","permalink":"https://blog.yunchen.tw/2017/07/10/combination-sum-III/","excerpt":"","text":"Combination Sum IIIFind all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Example 1:Input: k = 3, n = 7 Output: 1[[1,2,4]] Example 2:Input: k = 3, n = 9 Output: 1[[1,2,6], [1,3,5], [2,3,4]] 提示 解題應用 Backtracking Recursive Default:123func combinationSum3(k int, n int) [][]int &#123;&#125; 解答思路:建議可以先參考先前Combination Sum的解法，解說較為詳細，基本上概念完全一樣，只是稍微修改先前的程式碼而已，如果能找出數列中符合目標總合的所有組合，現在只要找出特定長度的組合就不會太困難。 這次數列為1~9而且每個只能取1次的情況下，要來找出符合目標總合的所有組合，其實就只要像先前一樣帶入一個包含1~9的陣列與多一個長度限制的參數至遞回函數之中，最後如果發現有符合目標總合且該組合的長度也符合長度限制就將其放入結果陣列，而如果總合小於目標總合則繼續往下做遞回，只是這次有說每個組合的每個值最多只能取一次，因此帶入遞回剩餘未取出的陣列元素不能包含自己的元素。 程式碼解說:這次數列為1~9而且每個只能取1次的情況下，要來找出符合目標總合的所有組合，其實就只要像先前一樣帶入一個包含1~9的陣列與多一個長度限制的參數至遞回函數之中(遞回函數的第二個參數) 1234567func combinationSum3(k int, n int) [][]int &#123; candidates := make([]int, 9) for i := 1; i &lt;= 9; i++ &#123; candidates[i-1] = i &#125; return combine(0, k, n, []int&#123;&#125;, candidates)&#125; 這部分只解說與先前題目程式碼的相異之處，如果發現有符合目標總合且該組合的長度也符合長度限制(能再放入組合的元素數為0)就將其放入結果陣列，而如果總合小於目標總合則繼續往下做遞回(長度限制也要記得-1)，只是這次有說每個組合的每個值最多只能取一次，因此帶入遞回剩餘未取出的陣列元素不能包含自己的元素 12345678910111213func combine(sum int, nums int, target int, curComb []int, candidates []int) [][]int &#123; var tmp [][]int var result [][]int if sum == target &amp;&amp; nums == 0 &#123; ... &#125; else if sum &lt; target &#123; for i, v := range candidates &#123; tmp = combine(sum+v, nums-1, target, append(curComb, v), candidates[i+1:]) result = append(result, tmp...) &#125; &#125; return result&#125; 完整程式碼:12345678910111213141516171819202122func combinationSum3(k int, n int) [][]int &#123; candidates := make([]int, 9) for i := 1; i &lt;= 9; i++ &#123; candidates[i-1] = i &#125; return combine(0, k, n, []int&#123;&#125;, candidates)&#125;func combine(sum int, nums int, target int, curComb []int, candidates []int) [][]int &#123; var tmp [][]int var result [][]int if sum == target &amp;&amp; nums == 0 &#123; tmpCurComb := make([]int, len(curComb)) copy(tmpCurComb, curComb) return [][]int&#123;tmpCurComb&#125; &#125; else if sum &lt; target &#123; for i, v := range candidates &#123; tmp = combine(sum+v, nums-1, target, append(curComb, v), candidates[i+1:]) result = append(result, tmp...) &#125; &#125; return result&#125; 總結:建議可以先參考先前Combination Sum的解法，解說較為詳細，基本上概念完全一樣，既然之前能找出數列中符合目標總合的所有組合，現在要找出特定長度的組合只要將其它的組合做篩選就沒有什麼大問題了。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"Backtracking","slug":"Backtracking","permalink":"https://blog.yunchen.tw/tags/Backtracking/"}]},{"title":"Kth Largest Element in an Array","slug":"Kth-largest-element-in-an-array","date":"2017-07-08T16:00:00.000Z","updated":"2017-07-09T13:05:10.000Z","comments":true,"path":"2017/07/09/Kth-largest-element-in-an-array/","link":"","permalink":"https://blog.yunchen.tw/2017/07/09/Kth-largest-element-in-an-array/","excerpt":"","text":"Kth Largest Element in an ArrayFind the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. For example,Given [3,2,1,5,6,4] and k = 2, return 5. Note: You may assume k is always valid, 1 ? k ? array’s length. Default:123func findKthLargest(nums []int, k int) int &#123;&#125; 解答思路:要從一數列中找第k大的數字，當然一看到就直接將數列由大至小做排序，然後回傳第k個位置的值就會是我們要的結果，唯一要注意的是需要檢查k是否符合範圍(1~n)，其它的就沒什麼大問題了。 程式碼解說:要找第k大的數字當然一開始就直接將陣列由大至小做排序，接著判斷如果k介於1~n符合範圍的話，便直接回傳陣列上第k個位置的值，否則如果位於條件範圍之外便回傳-1 12345sort.Sort(sort.Reverse(sort.IntSlice(nums)))if k &gt;= 1 &amp;&amp; k &lt;= len(nums) &#123; return nums[k-1]&#125;return -1 完整程式碼:1234567func findKthLargest(nums []int, k int) int &#123; sort.Sort(sort.Reverse(sort.IntSlice(nums))) if k &gt;= 1 &amp;&amp; k &lt;= len(nums) &#123; return nums[k-1] &#125; return -1&#125; 總結:要從一數列中找第k大的數字，做法是只要將數列由大至小做排序，該數列的第k個位置的值就會是我們要的結果，唯一要注意的是需要檢查k是否符合範圍(1~n)。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"DivideAndConquer","slug":"DivideAndConquer","permalink":"https://blog.yunchen.tw/tags/DivideAndConquer/"},{"name":"Heap","slug":"Heap","permalink":"https://blog.yunchen.tw/tags/Heap/"}]},{"title":"House Robber II","slug":"house-robber-II","date":"2017-07-07T16:00:00.000Z","updated":"2017-07-08T15:37:12.000Z","comments":true,"path":"2017/07/08/house-robber-II/","link":"","permalink":"https://blog.yunchen.tw/2017/07/08/house-robber-II/","excerpt":"","text":"House Robber IINote: This is an extension of House Robber. After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 提示 解題應用 DynamicProgramming 規律觀查 Default:123func rob(nums []int) int &#123;&#125; 解答思路:建議可以先參考先前House Robber的解法，解說較為詳細，基本上概念完全一樣，只是重覆使用先前的程式碼而已，如果能找出數列中不連續的極大值總合，現在該數列是表示為圓環要篩選頭尾為連續的情況就不會太困難。 與之前一樣將其分為左(index奇數)與右(index偶數)來區別，之後只要判斷如果輪到該數而那一側的總合結果比另一側小，這時另一側的總合就能取代原本那一側的總合，再分別繼續往下重覆上述動作，至於如果是圓環要如何避免頭尾連續，其實只要將陣列分作兩種情況(“陣列的開頭到尾巴的前一項”與”陣列的開頭下一項到尾巴”)，再分別當作普通數列找不連續的極大值總合，最後再比較哪一種情況總合比較大就會是我們要的結果。 程式碼解說:因為對於數列是圓環要避免頭尾連續，之後要將其分作兩種情況，分別是陣列不包含開頭的資料與陣列不包含結尾的資料，不過在那之前要先判斷如果陣列長度為0就回傳0，如果長度為1就回傳該個唯一的值，接著就可以將此兩種情況分別當作普通數列找不連續的極大值總合，最後再比較哪一種情況總合比較大就會是我們要的結果 12345678910111213func rob(nums []int) int &#123; if len(nums) == 0 &#123; return 0 &#125; else if len(nums) == 1 &#123; return nums[0] &#125; excludeFront := robSum(nums[1:]) excludeRear := robSum(nums[:len(nums)-1]) if excludeFront &gt; excludeRear &#123; return excludeFront &#125; return excludeRear&#125; 此部分與先前找出數列中不連續極大值總合的程式碼完全一模一樣就不再多做解說 123456789101112131415161718192021func robSum(nums []int) int &#123; var odd int var even int for i, v := range nums &#123; if i%2 != 0 &#123; odd = odd + v if even &gt; odd &#123; odd = even &#125; &#125; else &#123; even = even + v if odd &gt; even &#123; even = odd &#125; &#125; &#125; if odd &gt; even &#123; return odd &#125; return even&#125; 完整程式碼:12345678910111213141516171819202122232425262728293031323334func rob(nums []int) int &#123; if len(nums) == 0 &#123; return 0 &#125; else if len(nums) == 1 &#123; return nums[0] &#125; excludeFront := robSum(nums[1:]) excludeRear := robSum(nums[:len(nums)-1]) if excludeFront &gt; excludeRear &#123; return excludeFront &#125; return excludeRear&#125;func robSum(nums []int) int &#123; var odd int var even int for i, v := range nums &#123; if i%2 != 0 &#123; odd = odd + v if even &gt; odd &#123; odd = even &#125; &#125; else &#123; even = even + v if odd &gt; even &#123; even = odd &#125; &#125; &#125; if odd &gt; even &#123; return odd &#125; return even&#125; 總結:建議可以先參考先前House Robber的解法，解說較為詳細，基本上概念完全一樣，只是如果數列是圓環要如何避免頭尾連續，其實只要將陣列分作兩種情況(“陣列的開頭到尾巴的前一項”與”陣列的開頭下一項到尾巴”)，再分別當作普通數列找不連續的極大值總合，最後再比較哪一種情況總合比較大就會是我們要的結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"https://blog.yunchen.tw/tags/DynamicProgramming/"}]},{"title":"Add and Search Word - Data structure design","slug":"add-and-search-word-data-structure-design","date":"2017-07-06T16:00:00.000Z","updated":"2017-07-07T15:12:49.000Z","comments":true,"path":"2017/07/07/add-and-search-word-data-structure-design/","link":"","permalink":"https://blog.yunchen.tw/2017/07/07/add-and-search-word-data-structure-design/","excerpt":"","text":"Add and Search Word - Data structure designDesign a data structure that supports the following two operations: 12void addWord(word)bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. For example:1234567addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true Note: You may assume that all words are consist of lowercase letters a-z. 提示 解題應用 Backtracking Recursive Trie Tree Default:1234567891011121314151617181920212223242526272829type WordDictionary struct &#123; &#125;/** Initialize your data structure here. */func Constructor() WordDictionary &#123; &#125;/** Adds a word into the data structure. */func (this *WordDictionary) AddWord(word string) &#123; &#125;/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */func (this *WordDictionary) Search(word string) bool &#123; &#125;/** * Your WordDictionary object will be instantiated and called as such: * obj := Constructor(); * obj.AddWord(word); * param_2 := obj.Search(word); */ 解答思路:建議可以先參考先前Implement Trie (Prefix Tree)的解法，解說較為詳細，基本上概念完全一樣，只是這次在搜尋Trie的部分多了一個可以用”.”來取代任何值，這意味著當碰上”.”的時候要嘗試所有的可能，因此需要將原本的搜尋函數修改成以遞回的方式來做搜尋，當碰上”.”的時候就需要遞回以嘗試所有的可能，否則就只要像之前一樣直接繼續往下做檢查即可，至於搜尋函數以外的function則全數與先前完全一樣就不會有什麼大問題。 程式碼解說:這邊只解說與先前題目程式碼的相異之處，最主要就是將搜尋函數修改成以遞回的方式來嘗試所有的可能，所以一開始便將Trie的節點與要搜尋的目標帶入遞回函數之中，而如果沒有碰上”.”的情況下，基本上就與先前一樣利用迴圈取出字元的rune值-97當作index，如果中間字元不存在或者已經到最後一個字母卻發現其不為單字，便一律回傳false，如果單字取出檢查都沒有問題最後才回傳true 12345678910111213func (this *WordDictionary) Search(word string) bool &#123; return Match(this, word)&#125;func Match(this *WordDictionary, word string) bool &#123; for i, v := range word &#123; ... if (this.Node[v-97] == nil) || (i+1 == len(word) &amp;&amp; !this.Node[v-97].IsWord) &#123; return false &#125; this = this.Node[v-97] &#125; return true&#125; 萬一取出的字元是”.”，此時就需要另外做處理，因為”.”可以用來取代任何值，一開始便遍歷陣列所有不為nil的節點，如果該”.”所在位置是單字的最後一個字元，此時就只要檢查該節點是否標示為單字，而如果不是最後一個字元則以該節點作為”.”與單字剩餘的字元帶入遞回函數再次判斷此單字是否存在，最後如果exist為true表示至少有一個(或更多)符合搜尋的條件 12345678910111213var exist boolif string(v) == \".\" &#123; for _, n := range this.Node &#123; if n != nil &#123; if i+1 == len(word) &#123; exist = exist || n.IsWord &#125; else &#123; exist = exist || Match(n, word[i+1:]) &#125; &#125; &#125; return exist&#125; 完整程式碼:1234567891011121314151617181920212223242526272829303132333435363738394041type WordDictionary struct &#123; IsWord bool Node [26]*WordDictionary&#125;func Constructor() WordDictionary &#123; return WordDictionary&#123;&#125;&#125;func (this *WordDictionary) AddWord(word string) &#123; for _, v := range word &#123; if this.Node[v-97] == nil &#123; this.Node[v-97] = &amp;WordDictionary&#123;&#125; &#125; this = this.Node[v-97] &#125; this.IsWord = true&#125;func (this *WordDictionary) Search(word string) bool &#123; return Match(this, word)&#125;func Match(this *WordDictionary, word string) bool &#123; var exist bool for i, v := range word &#123; if string(v) == \".\" &#123; for _, n := range this.Node &#123; if n != nil &#123; if i+1 == len(word) &#123; exist = exist || n.IsWord &#125; else &#123; exist = exist || Match(n, word[i+1:]) &#125; &#125; &#125; return exist &#125; if (this.Node[v-97] == nil) || (i+1 == len(word) &amp;&amp; !this.Node[v-97].IsWord) &#123; return false &#125; this = this.Node[v-97] &#125; return true&#125; 總結:建議可以先參考先前Implement Trie (Prefix Tree)的解法，解說較為詳細，基本上概念完全一樣，只是這次在搜尋Trie的部分多了一個可以用”.”來取代任何值，這意味著當碰上”.”的時候，需要將原本的搜尋函數修改成以遞回的方式來嘗試所有的可能，否則就只要像之前一樣直接繼續往下做檢查即可。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Design","slug":"Design","permalink":"https://blog.yunchen.tw/tags/Design/"},{"name":"Backtracking","slug":"Backtracking","permalink":"https://blog.yunchen.tw/tags/Backtracking/"},{"name":"Trie","slug":"Trie","permalink":"https://blog.yunchen.tw/tags/Trie/"}]},{"title":"Course Schedule II","slug":"course-schedule-II","date":"2017-07-05T16:00:00.000Z","updated":"2017-07-06T15:36:23.000Z","comments":true,"path":"2017/07/06/course-schedule-II/","link":"","permalink":"https://blog.yunchen.tw/2017/07/06/course-schedule-II/","excerpt":"","text":"Course Schedule IIThere are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. For example:12, [[1,0]] There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] 14, [[1,0],[2,0],[3,1],[3,2]] There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3]. Note: The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites. 提示 解題應用 Graph 相鄰表製作 Default:123func findOrder(numCourses int, prerequisites [][]int) []int &#123;&#125; 解答思路:建議可以先參考先前Course Schedule的解法，解說較為詳細，基本上概念完全一樣，只是將先前題的程式碼稍做修改而已，如果能判斷是否能將課程全數修完，要列出合理的修課順序就不會太困難。 先將課程與擋修課程的關係整理成一份圖表，並計算各個課程共有多少門前置課程，接著從無前置的基本課程開始先修，每當發現某課程的前置課程完成就將其前置課程的總數-1，直到該課程的前置數為0就可當作基本課程來處理，最後只要判斷修課數與總課程數是否相同再回傳修課的順序即可。 程式碼解說:這邊只解說與先前題目程式碼的相異之處，原本只是計算已修課程數，現在要改為修課的課程順序，所以每次從隊列取出課程時就將其值放入修課順序的陣列之中，待隊列遍歷完畢判斷修課數(修課順序的陣列長度)與總課程數是否相同，如果不同就回傳空的陣列，否則才回傳整個修課順序的陣列 123456789101112...var take []intfor queue != nil &#123; pre = queue.Val take = append(take, pre) ... queue = queue.Next&#125;if len(take) != numCourses &#123; return []int&#123;&#125;&#125;return take 完整程式碼:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051type Node struct &#123; Val int Next *Node&#125;func findOrder(numCourses int, prerequisites [][]int) []int &#123; var take []int var pre int var course int var newNode *Node queue := &amp;Node&#123;&#125; rear := queue schedule := make([][]int, numCourses) degree := make([]int, numCourses) for i, _ := range schedule &#123; schedule[i] = make([]int, numCourses) &#125; for _, v := range prerequisites &#123; course = v[0] pre = v[1] schedule[course][pre] = 1 degree[course]++ &#125; for i, v := range degree &#123; if v == 0 &#123; newNode = &amp;Node&#123;i, nil&#125; rear.Next = newNode rear = newNode &#125; &#125; queue = queue.Next for queue != nil &#123; pre = queue.Val take = append(take, pre) for course := 0; course &lt; numCourses; course++ &#123; if schedule[course][pre] == 1 &#123; schedule[course][pre] = 0 degree[course]-- if degree[course] == 0 &#123; newNode = &amp;Node&#123;course, nil&#125; rear.Next = newNode rear = newNode &#125; &#125; &#125; queue = queue.Next &#125; if len(take) != numCourses &#123; return []int&#123;&#125; &#125; return take&#125; 總結:建議可以先參考先前Course Schedule的解法，解說較為詳細，基本上概念完全一樣，先將課程與擋修課程的關係整理成一份圖表，並計算各個課程共有多少門前置課程，接著從無前置的基本課程開始先修，每當發現某課程的前置課程完成就將其前置課程的總數-1，直到該課程的前置數為0就可當作基本課程來處理，最後只要判斷修課數與總課程數是否相同再回傳修課的順序即可。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"DepthFirstSearch","slug":"DepthFirstSearch","permalink":"https://blog.yunchen.tw/tags/DepthFirstSearch/"},{"name":"BreadthFirstSearch","slug":"BreadthFirstSearch","permalink":"https://blog.yunchen.tw/tags/BreadthFirstSearch/"},{"name":"Graph","slug":"Graph","permalink":"https://blog.yunchen.tw/tags/Graph/"},{"name":"TopologicalSort","slug":"TopologicalSort","permalink":"https://blog.yunchen.tw/tags/TopologicalSort/"}]},{"title":"Minimum Size Subarray Sum","slug":"minimum-size-subarray-sum","date":"2017-07-04T16:00:00.000Z","updated":"2017-07-06T15:04:23.000Z","comments":true,"path":"2017/07/05/minimum-size-subarray-sum/","link":"","permalink":"https://blog.yunchen.tw/2017/07/05/minimum-size-subarray-sum/","excerpt":"","text":"Minimum Size Subarray SumGiven an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. For example:Given the array [2,3,1,2,4,3] and s = 7,the subarray [4,3] has the minimal length under the problem constraint. 提示 解題應用 TwoPointers 紀錄index位置 Default:123func minSubArrayLen(s int, nums []int) int &#123;&#125; 解答思路:要從一陣列中找出最小子陣列且其總合大於等於目標值，只要一邊遍歷(當作子陣列的結尾)一邊計算目前陣列總和，如果發現將子陣列開頭向後推其總合仍能大於等於目標值，就一路推到不在大於等於目標值為止，此時再判斷如果目標子陣列長度小於最小長度就將其取代，最後待全數陣列遍歷完畢才向上回傳找出的最小長度。 程式碼解說:一開始先將最小長度設為陣列長度，接著就開始一邊遍歷一邊計算目前陣列總和，如果總合大於等於目標值，又剛好子陣列開頭向後推其總合仍能大於等於目標值，就一路推到不在大於等於目標值為止，此時再判斷目標子陣列長度是否小於最小長度，是的話就將其取代，最後待全數陣列遍歷完畢如果發現總合仍小於目標值便回傳0，否則才向上回傳找出的最小長度 12345678910111213141516171819var sum intvar front intminSize := len(nums)for i, v := range nums &#123; sum += v if sum &gt;= s &#123; for sum-nums[front] &gt;= s &#123; sum -= nums[front] front++ &#125; if i-front+1 &lt; minSize &#123; minSize = i - front + 1 &#125; &#125;&#125;if sum &lt; s &#123; return 0&#125;return minSize 完整程式碼:123456789101112131415161718192021func minSubArrayLen(s int, nums []int) int &#123; var sum int var front int minSize := len(nums) for i, v := range nums &#123; sum += v if sum &gt;= s &#123; for sum-nums[front] &gt;= s &#123; sum -= nums[front] front++ &#125; if i-front+1 &lt; minSize &#123; minSize = i - front + 1 &#125; &#125; &#125; if sum &lt; s &#123; return 0 &#125; return minSize&#125; 總結:要從一陣列中找出最小子陣列且其總合大於等於目標值，只要一邊遍歷(當作子陣列的結尾)一邊計算目前陣列總和，如果發現將子陣列開頭向後推其總合仍能大於等於目標值，就一路推到不在大於等於目標值為止，此時再判斷如果目標子陣列長度小於最小長度就將其取代，最後待全數陣列遍歷完畢才向上回傳找出的最小長度。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://blog.yunchen.tw/tags/BinarySearch/"}]},{"title":"Implement Trie (Prefix Tree)","slug":"implement-trie-prefix-tree","date":"2017-07-03T16:00:00.000Z","updated":"2017-07-05T16:14:59.000Z","comments":true,"path":"2017/07/04/implement-trie-prefix-tree/","link":"","permalink":"https://blog.yunchen.tw/2017/07/04/implement-trie-prefix-tree/","excerpt":"","text":"Implement Trie (Prefix Tree)Implement a trie with insert, search, and startsWith methods. Note: You may assume that all inputs are consist of lowercase letters a-z. 提示 解題應用 Trie Tree Default:123456789101112131415161718192021222324252627282930313233343536type Trie struct &#123; &#125;/** Initialize your data structure here. */func Constructor() Trie &#123; &#125;/** Inserts a word into the trie. */func (this *Trie) Insert(word string) &#123; &#125;/** Returns if the word is in the trie. */func (this *Trie) Search(word string) bool &#123; &#125;/** Returns if there is any word in the trie that starts with the given prefix. */func (this *Trie) StartsWith(prefix string) bool &#123; &#125;/** * Your Trie object will be instantiated and called as such: * obj := Constructor(); * obj.Insert(word); * param_2 := obj.Search(word); * param_3 := obj.StartsWith(prefix); */ 解答思路:這次要用Tree實作字典檔或稱前綴樹，大致如下圖所示: 圖片取自維基百科 相較於用hashmap的字典檔只有O(1)的時間複雜度，Trie最糟可能會到O(n)(n為字串長度)而且又會花費大量的空間，不過當有需要找字串間前綴的關連性才能發揮Trie的價值，至於要實作Trie只要注意到節點本身並不儲單一字元的值，而是一長度26(若字串只由a~z組成)陣列來各別放置下一節點的位置，如此一來就可以只透過位置的順序來知道該位置是哪個字母，此外在找下一個字母位置也就不必一個個遍歷，而是直接將字母當ascii減去97就會是對應陣列的index，接著再檢查該位置是否為nil就可以得知字母是否存在，最後節點還要標示到該位置時是否為單字，因為單字並非一定要到葉子節點，像是出現”in”及”inn”兩個字的情況便是如此。 程式碼解說:一開始先初始化Trie節點的結構，其中標示到該位置時是否為單字之外，還有長度26(若字串只由a~z組成)陣列來各別放置下一節點的位置 1234567type Trie struct &#123; IsWord bool Node [26]*Trie&#125;func Constructor() Trie &#123; return Trie&#123;&#125;&#125; 接著就是來實作將單字插入Trie的函數，利用迴圈從單字一一取出字元的rune值後-97當作index，並檢查陣列中該位置是否為nil，如果是就在該位置自行新增一個Trie的節點，否則就從該位置開始繼續往下遍歷，最後當到達單字的最後一個字母時，記得在該位置的節點要標示為單字 123456789func (this *Trie) Insert(word string) &#123; for _, v := range word &#123; if this.Node[v-97] == nil &#123; this.Node[v-97] = &amp;Trie&#123;&#125; &#125; this = this.Node[v-97] &#125; this.IsWord = true&#125; 搜尋函數則也是利用迴圈取出字元的rune值-97當作index，如果中間字元不存在或者已經到最後一個字母卻發現其不為單字，便一律回傳false，如果單字取出檢查都沒有問題最後才回傳true 123456789func (this *Trie) Search(word string) bool &#123; for i, v := range word &#123; if (this.Node[v-97] == nil) || (i+1 == len(word) &amp;&amp; !this.Node[v-97].IsWord) &#123; return false &#125; this = this.Node[v-97] &#125; return true&#125; 至於尋找是否有特定的前綴字串和搜尋函數非常相似，只是這次僅需確認前綴是否存在而非單字，所以就不需要檢查最後一個字母是否標示為單字 123456789func (this *Trie) StartsWith(prefix string) bool &#123; for _, v := range prefix &#123; if this.Node[v-97] == nil &#123; return false &#125; this = this.Node[v-97] &#125; return true&#125; 完整程式碼:12345678910111213141516171819202122232425262728293031323334type Trie struct &#123; IsWord bool Node [26]*Trie&#125;func Constructor() Trie &#123; return Trie&#123;&#125;&#125;func (this *Trie) Insert(word string) &#123; for _, v := range word &#123; if this.Node[v-97] == nil &#123; this.Node[v-97] = &amp;Trie&#123;&#125; &#125; this = this.Node[v-97] &#125; this.IsWord = true&#125;func (this *Trie) Search(word string) bool &#123; for i, v := range word &#123; if (this.Node[v-97] == nil) || (i+1 == len(word) &amp;&amp; !this.Node[v-97].IsWord) &#123; return false &#125; this = this.Node[v-97] &#125; return true&#125;func (this *Trie) StartsWith(prefix string) bool &#123; for _, v := range prefix &#123; if this.Node[v-97] == nil &#123; return false &#125; this = this.Node[v-97] &#125; return true&#125; 總結:要用Tree實作字典檔(前綴樹)，其節點本身並不儲單一字元的值，而是一長度26(若字串只由a~z組成)陣列來各別放置下一節點的位置，透過位置的順序來知道該位置的字母，而找下一個字母位置則是直接將字母當ascii減去97作為陣列的index，檢查該位置是否為nil就可以得知字母是否存在，最後節點還要標示到該位置時是否為單字，因為單字並非一定都到葉子節點。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Design","slug":"Design","permalink":"https://blog.yunchen.tw/tags/Design/"},{"name":"Trie","slug":"Trie","permalink":"https://blog.yunchen.tw/tags/Trie/"}]},{"title":"Course Schedule","slug":"course-schedule","date":"2017-07-02T16:00:00.000Z","updated":"2017-07-06T15:08:54.000Z","comments":true,"path":"2017/07/03/course-schedule/","link":"","permalink":"https://blog.yunchen.tw/2017/07/03/course-schedule/","excerpt":"","text":"Course ScheduleThere are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? For example:12, [[1,0]] There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. 12, [[1,0],[0,1]] There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. Note: The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites. 提示 解題應用 Graph 相鄰表製作 Default:123func canFinish(numCourses int, prerequisites [][]int) bool &#123;&#125; 解答思路:如果資料之間彼此的關係不僅僅只有上到下，也有可能出現下到上的情況甚至有一對多關係的時候，此時就不是Tree或LinkedList能表示，而是要用Graph(圖)像是本題的課程與擋修課程的關係，也就是說像在大學有些課程會被擋修，除非你完成前置的基本課程才能去修那門課，少數幾門課甚至有二個以上的前置要完成，要判斷是否能順利修完全數課程，只要先利用整理好的圖表得知課程的關係，並計算各個課程共有多少門前置課程，從無前置的基本課程開始先修，每當發現某課程的前置課程完成就將其前置課程的總數-1，直到該課程的前置數為0就可當作基本課程來處理，最後只要判斷修課數與總課程數是否相同即可，至於那些互斥的課程(彼此為前置)則會因為所有的基本課程都完成仍無法修課而被略過，導致修課數無法到達總課程數而判斷無法完成整個課表。 程式碼解說:利用圖(Graph以二元陣列儲存)來表示課程與擋修課程的關係，因此一開始就初始化一個二元陣列來儲存所有的關係，接著還需要一個陣列來儲存各個課程共有多少前置課程，前置作業\b準備好就開始遍歷課程與擋修課程的關係，每次取出一個關係就將課程作為x軸，前置課程作為y軸來當作座標，在二元陣列對應的位置以1作為值表示其關係，並同時計算該課程有多少門前置課程再以另一陣列做統計 12345678910111213var pre intvar course intschedule := make([][]int, numCourses)for i, _ := range schedule &#123; schedule[i] = make([]int, numCourses)&#125;degree := make([]int, numCourses)for _, v := range prerequisites &#123; course = v[0] pre = v[1] schedule[course][pre] = 1 degree[course]++&#125; 接著遍歷剛才統計每門課程有多少門前置課程的陣列，如果該門課並沒有任何的限制(前置課程為0)，表示其為基本課程可以先修，因此就將其放至隊列之中待後續處理，這邊隊列是以LinkedList做表示(有用頭節點來確保操作上的一致性)，所以每次放入隊列都要當作節點來新增 1234567891011121314type Node struct &#123; Val int Next *Node&#125;var newNode *Nodequeue := &amp;Node&#123;&#125;rear := queuefor i, v := range degree &#123; if v == 0 &#123; newNode = &amp;Node&#123;i, nil&#125; rear.Next = newNode rear = newNode &#125;&#125; 因為隊列的第一個節點是頭節點而非課程的資料，所以要先將隊列移到下一個節點才開始一一取出處理，如果隊列取出的節點存在，就將已修課程數+1，並將此課程當作前置課程帶入先前整理好的二元陣列課程關係，檢查是否有其它課程是以此課程作為前置課程，如果又剛好其為前置課程之一就將先前統計的前置課程總數-1，而如果發現前置課程總數變為0，該課程就可當作基本課程來處理放入隊列之中，最後待隊列的課程資料全數取出(表示能夠修的課都修完了)，此時再檢查修課數與總課程數是否相同即可知道能否完成整個課表 12345678910111213141516171819var take intqueue = queue.Nextfor queue != nil &#123; pre = queue.Val take++ for course := 0; course &lt; numCourses; course++ &#123; if schedule[course][pre] == 1 &#123; schedule[course][pre] = 0 degree[course]-- if degree[course] == 0 &#123; newNode = &amp;Node&#123;course, nil&#125; rear.Next = newNode rear = newNode &#125; &#125; &#125; queue = queue.Next&#125;return take == numCourses 完整程式碼:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748type Node struct &#123; Val int Next *Node&#125;func canFinish(numCourses int, prerequisites [][]int) bool &#123; var take int var pre int var course int var newNode *Node queue := &amp;Node&#123;&#125; rear := queue schedule := make([][]int, numCourses) degree := make([]int, numCourses) for i, _ := range schedule &#123; schedule[i] = make([]int, numCourses) &#125; for _, v := range prerequisites &#123; course = v[0] pre = v[1] schedule[course][pre] = 1 degree[course]++ &#125; for i, v := range degree &#123; if v == 0 &#123; newNode = &amp;Node&#123;i, nil&#125; rear.Next = newNode rear = newNode &#125; &#125; queue = queue.Next for queue != nil &#123; pre = queue.Val take++ for course := 0; course &lt; numCourses; course++ &#123; if schedule[course][pre] == 1 &#123; schedule[course][pre] = 0 degree[course]-- if degree[course] == 0 &#123; newNode = &amp;Node&#123;course, nil&#125; rear.Next = newNode rear = newNode &#125; &#125; &#125; queue = queue.Next &#125; return take == numCourses&#125; 總結:有一課表包含n個課程，而部分課程之間存在著擋修的機制，要判斷是否能修完整個課表，只要先將課程與擋修課程的關係整理成一份圖表，並計算各個課程共有多少門前置課程，接著從無前置的基本課程開始先修，每當發現某課程的前置課程完成就將其前置課程的總數-1，直到該課程的前置數為0就可當作基本課程來處理，最後只要判斷修課數與總課程數是否相同即可，至於那些互斥的課程(彼此為前置)則會因為所有的基本課程都完成仍無法修課而被略過，導致修課數無法到達總課程數而判斷無法完成整個課表。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"DepthFirstSearch","slug":"DepthFirstSearch","permalink":"https://blog.yunchen.tw/tags/DepthFirstSearch/"},{"name":"BreadthFirstSearch","slug":"BreadthFirstSearch","permalink":"https://blog.yunchen.tw/tags/BreadthFirstSearch/"},{"name":"Graph","slug":"Graph","permalink":"https://blog.yunchen.tw/tags/Graph/"},{"name":"TopologicalSort","slug":"TopologicalSort","permalink":"https://blog.yunchen.tw/tags/TopologicalSort/"}]},{"title":"Bitwise AND of Numbers Range","slug":"bitwise-AND-of-numbers-range","date":"2017-07-01T16:00:00.000Z","updated":"2017-07-01T07:36:58.000Z","comments":true,"path":"2017/07/02/bitwise-AND-of-numbers-range/","link":"","permalink":"https://blog.yunchen.tw/2017/07/02/bitwise-AND-of-numbers-range/","excerpt":"","text":"Bitwise AND of Numbers RangeGiven a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. For example, given the range [5, 7], you should return 4. 提示 解題應用 BitManipulation AND Default:123func rangeBitwiseAnd(m int, n int) int &#123;&#125; 解答思路:仔細觀查一數序做AND的話會發現存在一種規律，從範圍中最後一個數字往前做AND的時候，每往前做一次AND其二進位值最右側的1就會歸0，例如範圍[4, 7]: 7先與6做AND，7從111變為110最右側的1歸0 1237 1116 110&amp; 110 再繼續與5做AND，110變為100最右側的1歸0 1237&amp;6 1105 101&amp; 100 最後到範圍的第一個數字時，到目前為止的值剛好就與4相同，因此沒辦法將最右側的1歸0，但此時的值就會是我們要的結果 1237&amp;6&amp;5 1004 100&amp; 100 因此只要以範圍最後一個值為主不斷的將最右側的1歸0，直到該值小於等於範圍第一個值為止，意思就等同是整個範圍都做AND的結果。 程式碼解說:既然知道要以範圍的最後一個值為主不斷的將最右側的1歸0，其做法就只是將”該數”與”該數-1”做&amp;(AND)即可，這個技巧也可以用來判斷二進位有多少個1或判斷是否為2的n次方，最後就只是不斷重覆上述動作直到該值小於等於範圍的第一個值為止，此時剩餘的值就等同是整個範圍都做AND的結果 1234for m &lt; n &#123; n = n &amp; (n - 1)&#125;return n 完整程式碼:123456func rangeBitwiseAnd(m int, n int) int &#123; for m &lt; n &#123; n = n &amp; (n - 1) &#125; return n&#125; 總結:給一數序要將其範圍內的所有值做&amp;(AND)並回傳結果，只要以範圍最後一個值為主不斷的將二進位表示的最右側1歸0，直到該值小於等於範圍第一個值為止，意思就等同是整個範圍都做AND的結果，至於每次要如何將該數二進位的最右側1歸0只要將”該數”與”該數-1”做&amp;(AND)即可。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"BitManipulation","slug":"BitManipulation","permalink":"https://blog.yunchen.tw/tags/BitManipulation/"}]},{"title":"Number of Islands","slug":"number-of-islands","date":"2017-06-30T16:00:00.000Z","updated":"2017-06-30T15:03:55.000Z","comments":true,"path":"2017/07/01/number-of-islands/","link":"","permalink":"https://blog.yunchen.tw/2017/07/01/number-of-islands/","excerpt":"","text":"Number of IslandsGiven a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1:123411110110101100000000 Answer: 1 Example 2:123411000110000010000011 Answer: 3 Default:123func numIslands(grid [][]byte) int &#123;&#125; 解答思路:要找出共有幾座島嶼在地圖上，最簡單的方式就是先遍歷整個二元陣列，如果碰到島嶼的任一點陸地(值為1)就在計數器上+1，並以該點開始往上下左右延伸將整個島嶼移除就可以避免重覆計算，直到完全遍歷完整個二元陣列也表示將所有島嶼從地圖上移除，最後計數器的島嶼數就是我們要的答案。 程式碼解說:一開始便以巢狀迴圈來遍歷整個二元陣列，如果碰到島嶼的任一點陸地就在計數器上+1，並將整個二元陣列及該點座標帶入遞回函數以移除整座島嶼，直到完全遍歷完整個二元陣列便向上回傳計數器的結果 123456789101112func numIslands(grid [][]byte) int &#123; var count int for i, g := range grid &#123; for j, v := range g &#123; if string(v) == \"1\" &#123; count++ removeIsland(grid, i, j) &#125; &#125; &#125; return count&#125; 接著就是處理遞回函數的細節，如果座標位於地圖的範圍內且該點位置為陸地的話，便先將該點的陸地移除(1改為0)，之後以該座標為中心分別向上下左右鄰近的位置做遞回直到完全移除整座島嶼為止 123456789func removeIsland(grid [][]byte, i int, j int) &#123; if i &gt;= 0 &amp;&amp; i &lt; len(grid) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(grid[0]) &amp;&amp; grid[i][j] == '1' &#123; grid[i][j] = '0' removeIsland(grid, i+1, j) removeIsland(grid, i, j+1) removeIsland(grid, i-1, j) removeIsland(grid, i, j-1) &#125;&#125; 完整程式碼:123456789101112131415161718192021func numIslands(grid [][]byte) int &#123; var count int for i, g := range grid &#123; for j, v := range g &#123; if string(v) == \"1\" &#123; count++ removeIsland(grid, i, j) &#125; &#125; &#125; return count&#125;func removeIsland(grid [][]byte, i int, j int) &#123; if i &gt;= 0 &amp;&amp; i &lt; len(grid) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(grid[0]) &amp;&amp; grid[i][j] == '1' &#123; grid[i][j] = '0' removeIsland(grid, i+1, j) removeIsland(grid, i, j+1) removeIsland(grid, i-1, j) removeIsland(grid, i, j-1) &#125;&#125; 總結:給一二元陣列包含0(海水)與1(陸地)，要找出共有幾座島嶼在地圖上，最簡單的方式就是先遍歷整個二元陣列，如果碰到島嶼的任一點陸地就在計數器上+1，並以該點開始往上下左右延伸將整個島嶼移除就可以避免重覆計算，直到完全遍歷完整個二元陣列也表示將所有島嶼從地圖上移除，最後計數器的島嶼數就是我們要的答案。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"DepthFirstSearch","slug":"DepthFirstSearch","permalink":"https://blog.yunchen.tw/tags/DepthFirstSearch/"},{"name":"BreadthFirstSearch","slug":"BreadthFirstSearch","permalink":"https://blog.yunchen.tw/tags/BreadthFirstSearch/"},{"name":"UnionFind","slug":"UnionFind","permalink":"https://blog.yunchen.tw/tags/UnionFind/"}]},{"title":"Binary Tree Right Side View","slug":"binary-tree-right-side-view","date":"2017-06-29T16:00:00.000Z","updated":"2017-06-30T07:55:47.000Z","comments":true,"path":"2017/06/30/binary-tree-right-side-view/","link":"","permalink":"https://blog.yunchen.tw/2017/06/30/binary-tree-right-side-view/","excerpt":"","text":"Binary Tree Right Side ViewGiven a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. For example:Given the following binary tree, 12345 1 &lt;--- / \\2 3 &lt;--- \\ \\ 5 4 &lt;--- You should return [1, 3, 4]. 提示 解題應用 DepthFirstSearch PreorderTravel Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func rightSideView(root *TreeNode) []int &#123;&#125; 解答思路:題目主要的意思就是要輸出每層最右側的節點，所以可以用廣度優先搜尋的方式將每層的最後一個節點給放入結果之中，或者是像這次的解法一樣採用前序遍歷的方式，每次再往下遍歷之前先檢查該節點右側是否有子節點存在，如果存在且該層尚未有節點放入結果之中(結果陣列的長度小於目前樹的深度)就將右側子節點值放入，而如果右側子節點不存在但左側存在，且該層一樣尚未有節點放入就將左側子節點值放入，最後待操作完畢要向下遞回遍歷時，記得要先遍歷完右子樹才遍歷左子樹(因為是以輸出最右側的節點為主)。 程式碼解說:因為對於根節點來說不屬於左右兩側，所以為了確保操作上的一致性，就自行製做頭節點將根節點接於頭節點的右側並帶入前序遍歷的函數之中，其中第一個參數是遍歷的節點，第二個則是目前該節點在整個二元樹的深度，第三個才是目前已放入結果陣列的值 1234func rightSideView(root *TreeNode) []int &#123; head := &amp;TreeNode&#123;0, nil, root&#125; return preorderTravel(head, 0, []int&#123;&#125;)&#125; 再來是前序遍歷函數的細節，一開始先檢查目前遍歷的節點是否存在，如果不存在則回傳整個結果陣列，而如果存在就再檢查該節點右側子節點是否一樣存在，且該層尚未有節點放入結果之中(結果陣列的長度小於目前樹的深度)就將右側子節點值放入，而如果右側子節點不存在但左側存在，且該層一樣尚未有節點放入就將左側子節點值放入，待操作完畢要向下遞回遍歷時，記得要先遍歷完右子樹才遍歷左子樹(因為是以輸出最右側的節點為主)，最後兩側子樹都遍歷結束後才向上回傳整個結果陣列 1234567891011121314func preorderTravel(node *TreeNode, depth int, cur []int) []int &#123; if node == nil &#123; return cur &#125; if node.Right != nil &amp;&amp; len(cur) &lt; depth+1 &#123; cur = append(cur, node.Right.Val) &#125; if node.Left != nil &amp;&amp; len(cur) &lt; depth+1 &#123; cur = append(cur, node.Left.Val) &#125; cur = preorderTravel(node.Right, depth+1, cur) cur = preorderTravel(node.Left, depth+1, cur) return cur&#125; 完整程式碼:1234func rightSideView(root *TreeNode) []int &#123; head := &amp;TreeNode&#123;0, nil, root&#125; return preorderTravel(head, 0, []int&#123;&#125;)&#125; 1234567891011121314func preorderTravel(node *TreeNode, depth int, cur []int) []int &#123; if node == nil &#123; return cur &#125; if node.Right != nil &amp;&amp; len(cur) &lt; depth+1 &#123; cur = append(cur, node.Right.Val) &#125; if node.Left != nil &amp;&amp; len(cur) &lt; depth+1 &#123; cur = append(cur, node.Left.Val) &#125; cur = preorderTravel(node.Right, depth+1, cur) cur = preorderTravel(node.Left, depth+1, cur) return cur&#125; 總結:如果要輸出二元樹中每層最右側的節點，可以用廣度優先搜尋的方式將每層的最後一個節點給放入結果之中，或者採用前序遍歷的方式每次再往下遍歷之前先檢查該節點右側是否有子節點存在，如果存在且該層尚未有節點放入結果之中(結果陣列的長度小於目前樹的深度)就將右側子節點值放入，而如果右側子節點不存在但左側存在，且該層一樣尚未有節點放入就將左側子節點值放入，最後待操作完畢要向下遞回遍歷時，記得要先遍歷完右子樹才遍歷左子樹(因為是以輸出最右側的節點為主)。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"},{"name":"DepthFirstSearch","slug":"DepthFirstSearch","permalink":"https://blog.yunchen.tw/tags/DepthFirstSearch/"},{"name":"BreadthFirstSearch","slug":"BreadthFirstSearch","permalink":"https://blog.yunchen.tw/tags/BreadthFirstSearch/"}]},{"title":"Repeated DNA Sequences","slug":"repeated-DNA-sequences","date":"2017-06-28T16:00:00.000Z","updated":"2017-06-29T15:56:00.000Z","comments":true,"path":"2017/06/29/repeated-DNA-sequences/","link":"","permalink":"https://blog.yunchen.tw/2017/06/29/repeated-DNA-sequences/","excerpt":"","text":"Repeated DNA SequencesAll DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. For example:1234Given s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;,Return:[&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;]. 提示 解題應用 HashTable HashMap Default:123func findRepeatedDnaSequences(s string) []string &#123;&#125; 解答思路:這題最主要是要用hashmap來儲存所有的可能，並且如果發現該字串已經存於hashmap之中才將其放入結果之中，其中key為該字串而value則是boolean值用來確定是否已放入結果陣列已避免重覆放入，而如果想要省空間的話，由於ACGT只有四種字母組成，以十進制表示的話A:101,C:0103,G:0107,T:0124會發現到剛好最後一個數字都不相同，只取最後的數字再以二進制表示的話A:001,C:011,G:111,100，如果int是用32位元儲存的話，每個字母都用上3bits剛好足夠10個字母，也就是說只要用一個int32就可以表示字串，但是因為題目沒有要求，而且這麼做會搞的相當複雜，所以就直接以字串來當key做儲存。 程式碼解說:一開始先初始化hashmap以儲存所有可能，其中key為DNA序列而value則是boolean值用來確定是否已放入結果陣列已避免重覆放入，接著就從頭開始遍歷字串直到倒數第十個字母為止(因為每個序列最少有十個字母)，每次都從取出字母的位置往後算10個字母(包含取出的位置)當作一序列並檢查是否存在於hashmap，如果該序列存在就再檢查value值確定能否放入結果陣列之中，如果ok為false表示先前就曾出現過第二次並已存於結果中，ok為true則將字串放入結果陣列並將value值改為false，而如果該序列不存在則直接將其放入hashmap之中並將value設為true，最後待全數可能的序列遍歷完畢後才回傳整個結果陣列 1234567891011121314var substring stringvar result []stringhashMap := make(map[string]bool)for i := 0; i &lt; len(s)-9; i++ &#123; substring = s[i : i+10] ok, exist := hashMap[substring] if exist &amp;&amp; ok &#123; result = append(result, substring) hashMap[substring] = false &#125; else if !exist &#123; hashMap[substring] = true &#125;&#125;return result 完整程式碼:12345678910111213141516func findRepeatedDnaSequences(s string) []string &#123; var substring string var result []string hashMap := make(map[string]bool) for i := 0; i &lt; len(s)-9; i++ &#123; substring = s[i : i+10] ok, exist := hashMap[substring] if exist &amp;&amp; ok &#123; result = append(result, substring) hashMap[substring] = false &#125; else if !exist &#123; hashMap[substring] = true &#125; &#125; return result&#125; 總結:一字串表示\bDNA只由ACGT組成，其中每個序列由10個字母組成，找出重覆2次(含)以上的序列，最主要是要用hashmap來儲存所有的可能，並且如果發現該字串已經存於hashmap之中才將其放入結果之中，其中key為該字串而value則是boolean值用來確定是否已放入結果陣列已避免重覆放入。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"},{"name":"BitManipulation","slug":"BitManipulation","permalink":"https://blog.yunchen.tw/tags/BitManipulation/"}]},{"title":"Largest Number","slug":"largest-number","date":"2017-06-27T16:00:00.000Z","updated":"2017-06-26T15:53:06.000Z","comments":true,"path":"2017/06/28/largest-number/","link":"","permalink":"https://blog.yunchen.tw/2017/06/28/largest-number/","excerpt":"","text":"Largest NumberGiven a list of non negative integers, arrange them such that they form the largest number. For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330. Note: The result may be very large, so you need to return a string instead of an integer. 提示 解題應用 Sort 規律觀查 Default:123func largestNumber(nums []int) string &#123;&#125; 解答思路:這題最主要是要將陣列的元素按特定規律做排序，仔細觀查會發現不管幾位數，只要開頭數字誰大就表示誰要放在最前面，不過萬一碰到像[3,30]與[3,34]的話呢?這時只要把各自的元素放到對方後頭就可以比較了，像前面的例子會變成[330,303]與[334,343]，誰比較大誰該擺前面便馬上一目瞭然了，最做golang做排序會呼叫Len(),Swap(),Less()三個function做排序，只要針對Less()將比較的部分複寫成要的規則，最後在排序之後就會變成能組出最大值順序的結果。 程式碼解說:因為這次需要複寫成要的排序規則以組出最大值，注意在排序之前會先將原本陣列的數字全轉為字串，所以後續的比較全都是字串的比較，一開始便需要定義Len(),Swap(),Less()三個function，前面兩個function與一般排序規則並無差別，而主要複寫的便是Less()的比較，如思路\b所述每次都將各自的元素放到另一方後頭才開始比較，所以在兩兩元素都為字串的情況下便很容易得到兩個互相組合的字串，接著就開始一個個字元比較rune值以判斷index為i的元素是否真的比j小 1234567891011121314151617type Number []stringfunc (a Number) Len() int &#123; return len(a) &#125;func (a Number) Swap(i int, j int) &#123; a[i], a[j] = a[j], a[i] &#125;func (a Number) Less(i int, j int) bool &#123; var char rune ij := a[i] + a[j] ji := a[j] + a[i] for i, v := range ij &#123; char = rune(ji[i]) if v &lt; char &#123; return true &#125; else if v &gt; char &#123; return false &#125; &#125; return false&#125; 定義好排序規則之後剩下就是處理進來的資料，由於定義的排序規則是以字串來處理資料的比較，就要先產生一個一模一樣長度的陣列，再利用迴圈遍歷一個個將元素轉為字串放入對應的陣列位置之中，全數資料轉換為字串陣列後就開始照先前定義的規則做排序，排序的結果是由小排至大(開頭數字大的在後面)，所以每次取出字串都要將其放入結果字串的開頭，最後為了要避免陣列只有0的值而組出”000”的結果，要一邊檢查是否有非0的元素存在，如果元素皆為0的時候只要回傳一個”0”即可 12345678910111213141516171819func largestNumber(nums []int) string &#123; var result string allzero := true strNum := make([]string, len(nums)) for i, v := range nums &#123; strNum[i] = strconv.Itoa(v) &#125; sort.Sort(Number(strNum)) for _, v := range strNum &#123; if v != \"0\" &#123; allzero = false &#125; result = v + result &#125; if allzero &#123; return \"0\" &#125; return result&#125; 完整程式碼:123456789101112131415161718192021222324252627282930313233343536type Number []stringfunc (a Number) Len() int &#123; return len(a) &#125;func (a Number) Swap(i int, j int) &#123; a[i], a[j] = a[j], a[i] &#125;func (a Number) Less(i int, j int) bool &#123; var char rune ij := a[i] + a[j] ji := a[j] + a[i] for i, v := range ij &#123; char = rune(ji[i]) if v &lt; char &#123; return true &#125; else if v &gt; char &#123; return false &#125; &#125; return false&#125;func largestNumber(nums []int) string &#123; var result string allzero := true strNum := make([]string, len(nums)) for i, v := range nums &#123; strNum[i] = strconv.Itoa(v) &#125; sort.Sort(Number(strNum)) for _, v := range strNum &#123; if v != \"0\" &#123; allzero = false &#125; result = v + result &#125; if allzero &#123; return \"0\" &#125; return result&#125; 總結:要將陣列中的數字盡可能組成最大值，仔細觀查會發現不管幾位數，只要開頭數字誰大就表示誰要放在最前面，萬一碰到像[3,30]與[3,34]的話，就把各自的元素放到對方後頭如[330,303]與[334,343]，誰比較大誰該擺前面便馬上一目瞭然了，最做golang做排序會呼叫Len(),Swap(),Less()三個function做排序，只要針對Less()將比較的部分複寫成要的規則，最後在排序之後就會變成能組出最大值順序的結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Sort","slug":"Sort","permalink":"https://blog.yunchen.tw/tags/Sort/"}]},{"title":"Two Sum II - Input array is sorted","slug":"two-sum-II-input-array-is-sorted","date":"2017-06-26T16:00:00.000Z","updated":"2017-06-26T00:45:27.000Z","comments":true,"path":"2017/06/27/two-sum-II-input-array-is-sorted/","link":"","permalink":"https://blog.yunchen.tw/2017/06/27/two-sum-II-input-array-is-sorted/","excerpt":"","text":"Two Sum II - Input array is sortedGiven an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. 12Input: numbers=&#123;2, 7, 11, 15&#125;, target=9Output: index1=1, index2=2 提示 解題應用 Array Array/Slice TwoPointers 記錄index位置 Default:123func twoSum(numbers []int, target int) []int &#123;&#125; 解答思路:如果是在無序的狀況下可能要用hashmap來找，不過有事先排序的話就能同時從陣列左右兩邊開始找起，當陣列的最左與最右值相加大於目標值時，表示總合太大將右側的index向內推一點找比較小的值並重新判斷，又當總合小於目標值時表示太小，將左側的index向內推一點找比較大的值並再次判斷，最後如果找到剛好等於目標值的情況就放入結果之中並向上回傳。 程式碼解說:因為有事先排序所以就能同時從陣列左右兩邊開始找起，一開始當然就是先計算左右兩邊值的總合，如果總合剛好為目標值就將兩邊的index+1放入結果之中(因為題目要的index是從1開始而非0)並結束迴圈向上回傳，最後如果總合大於目標值表示太大，此時就將右邊的index向前推並再次判斷，反之如果總合小於目標值表示太小則將左邊的index向後推，一直找到當左邊的位置超過右邊才停止 12345678910111213141516var sum intvar front intvar result []intrear := len(numbers) - 1for front &lt; rear &#123; sum = numbers[front] + numbers[rear] if sum == target &#123; result = []int&#123;front + 1, rear + 1&#125; break &#125; else if sum &gt; target &#123; rear-- &#125; else &#123; front++ &#125;&#125;return result 完整程式碼:123456789101112131415161718func twoSum(numbers []int, target int) []int &#123; var sum int var front int var result []int rear := len(numbers) - 1 for front &lt; rear &#123; sum = numbers[front] + numbers[rear] if sum == target &#123; result = []int&#123;front + 1, rear + 1&#125; break &#125; else if sum &gt; target &#123; rear-- &#125; else &#123; front++ &#125; &#125; return result&#125; 總結:要從有序的陣列中找出2個值總合為目標值的結果，因為有事先排序所以就能同時從陣列左右兩邊開始找起，當陣列的最左與最右值相加大於目標值時，表示總合太大將右側的index向內推一點找比較小的值並重新判斷，又當總合小於目標值時表示太小，將左側的index向內推一點找比較大的值並再次判斷，最後如果找到剛好等於目標值的情況就放入結果之中並向上回傳。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://blog.yunchen.tw/tags/BinarySearch/"}]},{"title":"Find Peak Element","slug":"find-peak-element","date":"2017-06-25T16:00:00.000Z","updated":"2017-06-25T15:55:06.000Z","comments":true,"path":"2017/06/26/find-peak-element/","link":"","permalink":"https://blog.yunchen.tw/2017/06/26/find-peak-element/","excerpt":"","text":"Find Peak ElementA peak element is an element that is greater than its neighbors. Given an input array where num[i] ≠ num[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that num[-1] = num[n] = -∞. For example:In array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2. Note: Your solution should be in logarithmic complexity. 提示 解題應用 Array Array/Slice BinarySearch BinarySearch Default:123func findPeakElement(nums []int) int &#123;&#125; 解答思路:回傳陣列中比周圍大的任一個元素位置，直接遍歷來做的話其實只要檢查每個取出的元素是否比前一個與下一個大即可，但是如果要在時間複雜度O(logn)以內的話，表示每次取出元素至少都要篩選掉一半，但是要選擇用二元搜尋又很奇怪，因為根本不是有序的資料，說起來本來就不是要尋找特定的目標，所以要如何每次都篩選掉一半以上元素就是首要目標(因為解答只要其中一種即可)，一開始就取最中間的兩個值並比較兩者大小，看是要最中間的值與其下一個值或前一個值都可以，這邊以中間與下一個值與主，如果中間值比較大，接下來只要重覆上述動作找開頭到中間值的範圍即可，反之如果下一個值比較大就是找中間下一個值到結尾的範圍，最後透過從中間逐步向外的方式篩出其中一個解答，最好的情況是山峰的位置在最中間，而最糟的情況則是在陣列的最兩側。 程式碼解說:一開始都與普通的二元搜尋無異，只是這次比較的對象是中間與下一個值，如果中間值比較大，就將搜尋的範圍改為開頭到中間值(結尾指向的位置改到中間)，反之如果下一個值比較大就將範圍改為中間下一個值到結尾(開頭指向的位置改到中間下一個)，最後待開頭與結尾都指向同一個位置，該位置上的值就會是其中一個解答 123456789101112var mid intvar front intrear := len(nums) - 1for front &lt; rear &#123; mid = (front + rear) / 2 if nums[mid] &gt; nums[mid+1] &#123; rear = mid &#125; else &#123; front = mid + 1 &#125;&#125;return rear 完整程式碼:1234567891011121314func findPeakElement(nums []int) int &#123; var mid int var front int rear := len(nums) - 1 for front &lt; rear &#123; mid = (front + rear) / 2 if nums[mid] &gt; nums[mid+1] &#123; rear = mid &#125; else &#123; front = mid + 1 &#125; &#125; return rear&#125; 總結:要找出陣列中比周圍大的任一個元素位置並在時間複雜度O(logn)以內的話，由於資料不是排序加上沒有特定的目標要搜尋，因此如果選擇用二元搜尋，最主要每次取出元素都篩選掉一半就是首要目標，其做法是取最中間的兩個值並比較兩者大小(以中間與下一個值為例)，如果中間值比較大，接下來只要重覆上述動作找開頭到中間值的範圍即可，反之亦然，最後透過從中間逐步向外的方式篩出其中一個解答。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://blog.yunchen.tw/tags/BinarySearch/"}]},{"title":"Find Minimum in Rotated Sorted Array","slug":"find-minimum-in-rotated-sorted-array","date":"2017-06-24T16:00:00.000Z","updated":"2017-06-25T04:40:19.000Z","comments":true,"path":"2017/06/25/find-minimum-in-rotated-sorted-array/","link":"","permalink":"https://blog.yunchen.tw/2017/06/25/find-minimum-in-rotated-sorted-array/","excerpt":"","text":"Find Minimum in Rotated Sorted ArraySuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. You may assume no duplicate exists in the array. 提示 解題應用 Array Array/Slice BinarySearch BinarySearch Default:123func findMin(nums []int) int &#123;&#125; 解答思路:建議可以先參考先前Search in Rotated Sorted Array的解法，解說較為詳細，基本上概念完全一樣，之前是先找出這些有序的資料和正確位置有序相比位移了多少(找最小值的位置做比較)，接著在利用這個位移來邊做二分法等演算法找出目標位置，當然這次只是要找最小值而已，所以就只要省了一個步驟即可。 程式碼解說:程式碼與先前的題目完全一樣甚至更簡單，因為就只是省了後頭的步驟而已，尋找最小值的方式與二元搜尋脫不了關係，不過中位數比較的值是與最後一個值相比，如果中位數比最後一個值大表示最小值被移動到後頭，此時將開頭指向的index移到中位數的下一個，而如果比最後一個值小(題目有說彼此值不會重覆，故無相等情況)，就將尾巴指向的index移到中位數，記得不是移到中位數的前一個，因為我們要找的最小值也有可能是該中位數，所以也要包含在其中，最後當開頭位置超過尾巴的位置而跳開迴圈時，尾巴位置的值便是我們要的最小值 123456789101112var mid intfront := 0rear := len(nums) - 1for front &lt; rear &#123; mid = (front + rear) / 2 if nums[mid] &gt; nums[rear] &#123; front = mid + 1 &#125; else &#123; rear = mid &#125;&#125;return nums[rear] 完整程式碼:1234567891011121314func findMin(nums []int) int &#123; var mid int front := 0 rear := len(nums) - 1 for front &lt; rear &#123; mid = (front + rear) / 2 if nums[mid] &gt; nums[rear] &#123; front = mid + 1 &#125; else &#123; rear = mid &#125; &#125; return nums[rear]&#125; 總結:建議可以先參考先前Search in Rotated Sorted Array的解法，解說較為詳細，基本上概念完全一樣，這次只是要找最小值而已，所以只要找出這些有序的資料和正確位置有序相比位移了多少(也就找最小值的位置)，最後就只是把最小值所在位置的值取出而已。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"}]},{"title":"Maximum Product Subarray","slug":"maximum-product-subarray","date":"2017-06-23T16:00:00.000Z","updated":"2017-06-24T14:51:52.000Z","comments":true,"path":"2017/06/24/maximum-product-subarray/","link":"","permalink":"https://blog.yunchen.tw/2017/06/24/maximum-product-subarray/","excerpt":"","text":"Maximum Product SubarrayFind the contiguous subarray within an array (containing at least one number) which has the largest product. For example:12Given the array [2,3,-2,4],the contiguous subarray [2,3] has the largest product = 6. 提示 解題應用 Array Array/Slice DynamicProgramming 規律觀查 Default:123func maxProduct(nums []int) int &#123;&#125; 解答思路:之前有一篇Maximum Subarray是找出子陣列能組出的最大總合(其實就是每取出一個元素，如果目前的最大總合比取出元素小，就用該元素取代當作最大值陣列的開頭)，而這次則是要找出最大積合，兩者最大的差別是算總合只要找出最大值就好，而算積合除了找最大值也要一併找最小值，因為積合是由相乘而獲得，所以如果有負數存在，原本的最值在相乘後反而會變成最小值，反之原本最小值可能變為最大值，因此最後在求最大積合時，如果如果目前的最小積合比取出元素大就用該元素取代，同時目前的最大積合比取出元素小就用該元素取代，並每次都將目前的最大積合與最大值做比較，比最大值大就將其取代直到陣列遍歷結束才回傳最大值。 程式碼解說:一開始先判斷陣列長度是否為0，如果是便回傳0回去，而如果陣列有元素存在，便直接取第一個值作為暫存的最小值與最大值，接著才開始從第二個元素開始取出直到陣列遍歷結束才回傳最大值 12345678910if len(nums) == 0 &#123; return 0&#125;tmpMin := nums[0]tmpMax := nums[0]max := tmpMaxfor _, v := range nums[1:] &#123;...&#125;return max 正如思路所述，由於最小值可能變為最大值，最大值可能變為最小值，因此在取出元素並兩兩相乘後，都先將結果存至另外的暫存變數，然後從兩暫存變數與取出的該元素值做比較找出最小值，再將其值取代暫存的最小值 1234567891011var tmp1 intvar tmp2 inttmp1 = tmpMin * vtmp2 = tmpMax * vif tmp1 &lt;= tmp2 &amp;&amp; tmp1 &lt;= v &#123; tmpMin = tmp1&#125; else if tmp2 &lt;= tmp1 &amp;&amp; tmp2 &lt;= v &#123; tmpMin = tmp2&#125; else &#123; tmpMin = v&#125; 反之再從兩暫存變數與取出的該元素值做比較找出最大值，再將其值取代暫存的最大值，並每次都將暫存的最大值與最大值做比較，比最大值大就將其取代 12345678910if tmp1 &gt;= tmp2 &amp;&amp; tmp1 &gt;= v &#123; tmpMax = tmp1&#125; else if tmp2 &gt;= tmp1 &amp;&amp; tmp2 &gt;= v &#123; tmpMax = tmp2&#125; else &#123; tmpMax = v&#125;if tmpMax &gt; max &#123; max = tmpMax&#125; 完整程式碼:123456789101112131415161718192021222324252627282930313233func maxProduct(nums []int) int &#123; if len(nums) == 0 &#123; return 0 &#125; var tmp1 int var tmp2 int tmpMin := nums[0] tmpMax := nums[0] max := tmpMax for _, v := range nums[1:] &#123; tmp1 = tmpMin * v tmp2 = tmpMax * v if tmp1 &lt;= tmp2 &amp;&amp; tmp1 &lt;= v &#123; tmpMin = tmp1 &#125; else if tmp2 &lt;= tmp1 &amp;&amp; tmp2 &lt;= v &#123; tmpMin = tmp2 &#125; else &#123; tmpMin = v &#125; if tmp1 &gt;= tmp2 &amp;&amp; tmp1 &gt;= v &#123; tmpMax = tmp1 &#125; else if tmp2 &gt;= tmp1 &amp;&amp; tmp2 &gt;= v &#123; tmpMax = tmp2 &#125; else &#123; tmpMax = v &#125; if tmpMax &gt; max &#123; max = tmpMax &#125; &#125; return max&#125; 總結:要從一陣列中找出子陣列能組出的最大積合，其做法是每當從陣列取出一個新值，如果如果目前的最小積合比取出元素大就用該元素取代，同時目前的最大積合比取出元素小就用該元素取代，並每次都將目前的最大積合與最大值做比較，比最大值大就將其取代直到陣列遍歷結束才回傳最大值。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"https://blog.yunchen.tw/tags/DynamicProgramming/"}]},{"title":"Evaluate Reverse Polish Notation","slug":"evaluate-reverse-polish-notation","date":"2017-06-22T16:00:00.000Z","updated":"2017-06-23T16:12:03.000Z","comments":true,"path":"2017/06/23/evaluate-reverse-polish-notation/","link":"","permalink":"https://blog.yunchen.tw/2017/06/23/evaluate-reverse-polish-notation/","excerpt":"","text":"Evaluate Reverse Polish NotationEvaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. For examples:12[&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;] -&gt; ((2 + 1) * 3) -&gt; 9[&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] -&gt; (4 + (13 / 5)) -&gt; 6 提示 解題應用 Stack LinkedList Default:123func evalRPN(tokens []string) int &#123;&#125; 解答思路:這題要你將已經被逆波蘭表示法拆解的算式還原回去並計算結果，而RPN其實就是資料結構所提到堆疊運用的四則運算後置式(運算子在後頭)，最困難的部分都已經拆解好要再還原算式以計算結果就非常容易，遍歷已拆解的算式，只要碰到運算元就放入stack之中，碰到運算子才從stack中取出兩個運算元做計算，並再將得到的結果再次放回stack，最後遍歷結束後在stack中唯一一個剩下的運算元就是我們要的結果。 程式碼解說:因為stack是採用LinkedList的方式實作，所以一開始就先定義好節點的結構，包含其值與下一個節點的位置 1234type Node struct &#123; Val int Next *Node&#125; 接著就開始還原算式並計算結果，一開始先遍歷已拆解的字串，碰到運算子就從stack中取出兩個運算元做計算(第一個取出的運算元在運算子後面，第二個在前面)，並根據運算子的符號做對應的計算，再將計算結果包成stack的頭節點再次放回stack之中，而如果是碰到運算元則直接包裝成頭節點放入stack之中(記得要將字串轉成數字，後續取出才可以拿來計算)，最後遍歷結束後在stack中唯一一個剩下的運算元(也就是頭節點)就是我們要的結果。 1234567891011121314151617181920212223242526272829303132func evalRPN(tokens []string) int &#123; var tmp int var numFront int var numBack int var top *Node var newNode *Node for _, v := range tokens &#123; if v == \"+\" || v == \"-\" || v == \"*\" || v == \"/\" &#123; numBack = top.Val top = top.Next numFront = top.Val top = top.Next switch v &#123; case \"+\": tmp = numFront + numBack case \"-\": tmp = numFront - numBack case \"*\": tmp = numFront * numBack case \"/\": tmp = numFront / numBack &#125; newNode = &amp;Node&#123;tmp, top&#125; top = newNode &#125; else &#123; val, _ := strconv.Atoi(v) newNode = &amp;Node&#123;val, top&#125; top = newNode &#125; &#125; return top.Val&#125; 完整程式碼:123456789101112131415161718192021222324252627282930313233343536type Node struct &#123; Val int Next *Node&#125;func evalRPN(tokens []string) int &#123; var tmp int var numFront int var numBack int var top *Node var newNode *Node for _, v := range tokens &#123; if v == \"+\" || v == \"-\" || v == \"*\" || v == \"/\" &#123; numBack = top.Val top = top.Next numFront = top.Val top = top.Next switch v &#123; case \"+\": tmp = numFront + numBack case \"-\": tmp = numFront - numBack case \"*\": tmp = numFront * numBack case \"/\": tmp = numFront / numBack &#125; newNode = &amp;Node&#123;tmp, top&#125; top = newNode &#125; else &#123; val, _ := strconv.Atoi(v) newNode = &amp;Node&#123;val, top&#125; top = newNode &#125; &#125; return top.Val&#125; 總結:要將已經被RPN逆波蘭表示法拆解的算式還原回去並計算結果，只要遍歷已拆解的算式，只要碰到運算元就放入stack之中，碰到運算子才從stack中取出兩個運算元做計算，並再將得到的結果再次放回stack，最後遍歷結束後在stack中唯一一個剩下的運算元就是我們要的結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Stack","slug":"Stack","permalink":"https://blog.yunchen.tw/tags/Stack/"}]},{"title":"Sort List","slug":"sort-list","date":"2017-06-21T16:00:00.000Z","updated":"2017-06-22T07:33:42.000Z","comments":true,"path":"2017/06/22/sort-list/","link":"","permalink":"https://blog.yunchen.tw/2017/06/22/sort-list/","excerpt":"","text":"Sort ListSort a linked list in O(n log n) time using constant space complexity. 提示 解題應用 LinkedList Pointer Sort MergeSort Default:12345678910/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func sortList(head *ListNode) *ListNode &#123;&#125; 解答思路:要將資料做排序並且要在時間複雜度O(nlogn)之內完成，一開始當然就馬上想到快速排序，不過仔細看題目所給的資料是用LinkedList表示，如果用LinkedList直接硬做快速排序而不使用一些奇淫技巧的話會反而會非常慢，與其要去用那些技巧(像是把LinkedList轉為陣列等等)，倒不如去選擇適合LinkedList的方式，最恰當的當然就是用合併排序的方式來實作，基本上合併排序的概念就是先將資料拆解成細項(每次都將資料拆成兩塊)分別做排序，最後才將已排序的細項兩兩合併回去並再次整理成單一的排序資料，如下圖: 原始資料: [50,10,90,30,70,40,80,60,20] 取自 &lt;&lt;大話資料結構&gt;&gt; 程式碼解說:合併排序的概念就是先將資料拆解成細項分別做排序才合併回去成單一的排序資料，所以就直接帶入LinkedList至遞回函數來降低流程上的複雜度，其實也算是在解Dynamic Programming的意思 123func sortList(head *ListNode) *ListNode &#123; return msort(head)&#125; 再來處理遞回函數的細節，如果該LinkedList為空或只有一個節點便不需要再拆解成兩塊或排序，直接將該節點回傳回去即可，而如果該LinkedList有兩個節點以上，此時便需要將資料拆成兩塊來讓後續能做合併排序，先將LinkedList帶入其它函數以找出中間節點，接著將原LinkedList拆解成左(開頭到中間節點，並記得要將中間節點的下一個位址改成nil)、右(中間節點的下一個到結尾節點)兩塊，最後各別再次帶入遞回函數之中，並且因為拆解後還需兩兩合併回去做排序，所以將剛才兩個拆解的LinkedList遞回函數一起帶入合併函數之後才做回傳 123456789func msort(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil &#123; return head &#125; middle := getMiddle(head) right := middle.Next middle.Next = nil return merge(msort(head), msort(right))&#125; 合併的函數可以先自製一個頭節點來確保開頭節點與其它節點操作上的一致性，同時遍歷兩條LinkedList，如果哪條的開頭節點比較小就將其接到合併的LinkedList後頭(同時紀錄該節點的位置以利後續剩餘節點的嫁接)，並且在最後判斷哪一條的LinkedList已經為nil，才將另一條直接接到結果LinkedList的後頭，待合併結束便回傳自製頭節點的下一個位址(也就是合併排序後新LinkedList開頭節點的位置) 123456789101112131415161718192021func merge(left *ListNode, right *ListNode) *ListNode &#123; header := &amp;ListNode&#123;0, nil&#125; pre := header for left != nil &amp;&amp; right != nil &#123; if left.Val &lt; right.Val &#123; pre.Next = left pre = left left = left.Next &#125; else &#123; pre.Next = right pre = right right = right.Next &#125; &#125; if left == nil &#123; pre.Next = right &#125; else &#123; pre.Next = left &#125; return header.Next&#125; 這邊則是來找出中間節點的位置，同時兩個指標以1:2的速度來遍歷整個LinkedList，當速度比較快的指標到底時(或下一個節點不存在)，此時比較慢的指標會位在中間節點的位置上 123456789101112func getMiddle(head *ListNode) *ListNode &#123; var fast *ListNode slow := head if head != nil &#123; fast = head.Next &#125; for fast != nil &amp;&amp; fast.Next != nil &#123; slow = slow.Next fast = fast.Next.Next &#125; return slow&#125; 完整程式碼:123456789101112131415161718192021222324252627282930313233343536373839404142434445func sortList(head *ListNode) *ListNode &#123; return msort(head)&#125;func msort(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil &#123; return head &#125; middle := getMiddle(head) right := middle.Next middle.Next = nil return merge(msort(head), msort(right))&#125;func merge(left *ListNode, right *ListNode) *ListNode &#123; header := &amp;ListNode&#123;0, nil&#125; pre := header for left != nil &amp;&amp; right != nil &#123; if left.Val &lt; right.Val &#123; pre.Next = left pre = left left = left.Next &#125; else &#123; pre.Next = right pre = right right = right.Next &#125; &#125; if left == nil &#123; pre.Next = right &#125; else &#123; pre.Next = left &#125; return header.Next&#125;func getMiddle(head *ListNode) *ListNode &#123; var fast *ListNode slow := head if head != nil &#123; fast = head.Next &#125; for fast != nil &amp;&amp; fast.Next != nil &#123; slow = slow.Next fast = fast.Next.Next &#125; return slow&#125; 總結:要將LinkedList做排序並且要在時間複雜度O(nlogn)之內完成，最恰當的方式就是用合併排序的方式來實作，而如果是資料格式是陣列的話反而用快速排序會比較容易。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://blog.yunchen.tw/tags/LinkedList/"},{"name":"Sort","slug":"Sort","permalink":"https://blog.yunchen.tw/tags/Sort/"}]},{"title":"Insertion Sort List","slug":"insertion-sort-list","date":"2017-06-20T16:00:00.000Z","updated":"2017-06-20T15:57:42.000Z","comments":true,"path":"2017/06/21/insertion-sort-list/","link":"","permalink":"https://blog.yunchen.tw/2017/06/21/insertion-sort-list/","excerpt":"","text":"Insertion Sort ListSort a linked list using insertion sort. 提示 解題應用 LinkedList Pointer Sort Insertion Sort Default:12345678910/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func insertionSortList(head *ListNode) *ListNode &#123;&#125; 解答思路:這題要你實作LinkedList的插入排序，只要有玩過撲克牌的人都應該有整理排的經驗，如果卡片比前面的牌小就抽出該張卡往前面找，直到發現前面已排序的卡片有大小範圍最接近該張卡片的位置才做插入，不過因為是單向的LinkedList，所以在抽出節點之後是從最開頭向後找直到發現比該值大的節點才插在前面。 程式碼解說:為了確保能一直指向LinkedList最新的開頭節點(也能讓開頭節點與其它節點一樣有操作上的一致性)，一開始便自行製做一個頭節點並將LinkedList接在頭節點後頭才開始遍歷，每次比較就像是整理撲克牌一樣，如果節點值比前面的小就抽出該節點，而因為前面經整理後都會是由小排序至大的LinkedList，所以其實前一個節點都會是到該節點為止的最大值，如果目前遍歷到的節點值比最大值大，便將該節點值取代最大值並繼續往下遍歷(也要記得記錄前一個節點的位置以利後續發生要嫁接的情況)，如果遍歷到的節點值比最大值小，這時就需要將節點抽出(這邊是將抽出節點的前一個與下一個節點做嫁接)，並找出前面已排序LinkedList的適當位置做插入(這邊帶入頭節點與該節點的位置至其它函數處理)，待LinkedList排序完畢之後便回傳自製頭節點的下一個位址(也就是排序LinkedList最新的開頭節點) 123456789101112131415161718func insertionSortList(head *ListNode) *ListNode &#123; var next *ListNode header := &amp;ListNode&#123;0, head&#125; pre := header max := math.MinInt32 for head != nil &#123; next = head.Next if head.Val &gt;= max &#123; max = head.Val pre = head &#125; else &#123; pre.Next = head.Next insert(header, head) &#125; head = next &#125; return header.Next&#125; 這邊則是處理抽出來的節點所要插入的位置，先以一迴圈從頭開始遍歷節點，如果發現比抽出節點值大的節點，就將抽出的節點嫁接在較大節點值的前一個與該節點之間並結束迴圈 12345678910111213func insert(header *ListNode, node *ListNode) &#123; pre := header head := header.Next for head != nil &#123; if node.Val &lt; head.Val &#123; pre.Next = node node.Next = head break &#125; pre = head head = head.Next &#125;&#125; 完整程式碼:12345678910111213141516171819202122232425262728293031func insertionSortList(head *ListNode) *ListNode &#123; var next *ListNode header := &amp;ListNode&#123;0, head&#125; pre := header max := math.MinInt32 for head != nil &#123; next = head.Next if head.Val &gt;= max &#123; max = head.Val pre = head &#125; else &#123; pre.Next = head.Next insert(header, head) &#125; head = next &#125; return header.Next&#125;func insert(header *ListNode, node *ListNode) &#123; pre := header head := header.Next for head != nil &#123; if node.Val &lt; head.Val &#123; pre.Next = node node.Next = head break &#125; pre = head head = head.Next &#125;&#125; 總結:要實作LinkedList的插入排序其實就像整理撲克牌一樣，卡片比前面的牌小就抽出該張卡往前面找適當的位置，而如果是單向的LinkedList，在抽出節點之後要從最開頭向後找直到發現比該值大的節點才插在前面。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://blog.yunchen.tw/tags/LinkedList/"},{"name":"Sort","slug":"Sort","permalink":"https://blog.yunchen.tw/tags/Sort/"}]},{"title":"Binary Tree Preorder Traversal","slug":"binary-tree-preorder-traversal","date":"2017-06-19T16:00:00.000Z","updated":"2017-06-20T01:35:19.000Z","comments":true,"path":"2017/06/20/binary-tree-preorder-traversal/","link":"","permalink":"https://blog.yunchen.tw/2017/06/20/binary-tree-preorder-traversal/","excerpt":"","text":"Binary Tree Preorder TraversalGiven a binary tree, return the preorder traversal of its nodes’ values. For example:Given binary tree {1,#,2,3}, 123451 \\ 2 /3 return [1,2,3]. Note: Recursive solution is trivial, could you do it iteratively? 提示 解題應用 Tree 前序遍歷 Stack LinkedList Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func preorderTraversal(root *TreeNode) []int &#123;&#125; 解答思路:建議可以先參考先前Binary Tree Inorder Traversal的解法，解說較為詳細，基本上概念完全一樣，中序遍歷與前序遍歷的差別其實就只是對節點操作的時間不同而已，所以本題與先前的差異就只是節點值放入結果陣列的時機，差別僅此就不再多加著墨，一樣也是不透過遞回而由stack來完成實作。 程式碼解說:這邊只解說與先前題目程式碼的相異之處，因為中序遍歷與前序遍歷的差別其實就只是對節點操作的時間不同，所以原本中序遍歷對節點操作的時間是在從stack取頭節點出來之後，前序遍歷的時機則改為在節點放入stack之前就對節點進行操作，說操作其實就只是節點值放入結果陣列而已 1234567891011for tmp != nil || top != nil &#123; if tmp != nil &#123; top = &amp;StackNode&#123;tmp, top&#125; result = append(result, tmp.Val) tmp = tmp.Left &#125; else &#123; tmp = top.Node top = top.Next tmp = tmp.Right &#125;&#125; 完整程式碼:123456789101112131415161718192021type StackNode struct &#123; Node *TreeNode Next *StackNode&#125;func preorderTraversal(root *TreeNode) []int &#123; var result []int var top *StackNode tmp := root for tmp != nil || top != nil &#123; if tmp != nil &#123; top = &amp;StackNode&#123;tmp, top&#125; result = append(result, tmp.Val) tmp = tmp.Left &#125; else &#123; tmp = top.Node top = top.Next tmp = tmp.Right &#125; &#125; return result&#125; 總結:建議可以先參考先前Binary Tree Inorder Traversal的解法，解說較為詳細，基本上概念完全一樣，中序遍歷與前序遍歷的差別其實就只是對節點操作的時間不同而已。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Stack","slug":"Stack","permalink":"https://blog.yunchen.tw/tags/Stack/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"}]},{"title":"Reorder List","slug":"reorder-list","date":"2017-06-18T16:00:00.000Z","updated":"2017-06-19T16:13:12.000Z","comments":true,"path":"2017/06/19/reorder-list/","link":"","permalink":"https://blog.yunchen.tw/2017/06/19/reorder-list/","excerpt":"","text":"Reorder ListGiven a singly linked list L: L0→L1→…→Ln-1→Ln,reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You must do this in-place without altering the nodes’ values. For example:1Given &#123;1,2,3,4&#125;, reorder it to &#123;1,4,2,3&#125;. 提示 解題應用 LinkedList Pointer Default:12345678910/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func reorderList(head *ListNode) &#123;&#125; 解答思路:這題只要仔細觀查數列的規律，我想就可以很輕易的將題目解開，以[1,2,3,4,5,6,7,8,9]來說: 12原始LinkedList: [1,2,3,4,5,6,7,8,9]結果LinkedList: [1,9,2,8,3,7,4,6,5] 如果將結果LinkedList分段來看的話 12結果LinkedList(奇): [1, ,2, ,3, ,4, ,5]結果LinkedList(偶): [ ,9, ,8, ,7, ,6, ] 我們可以發現結果LinkedList奇數位置的值正好是原始LinkedList開頭到中間的值(如果LinkedList的節點數是偶數，以中間偏前面的節點為主)，而結果LinkedList偶數位置的值則是中間到後頭值的顛倒，剩下的只要知道怎麼找出”LinkedList的中間節點”與”顛倒中間到後頭LinkedList的節點”就只要嫁接就好，這兩個技巧的實作可以參考Palindrome Linked List。 程式碼解說:透過規律可得知結果LinkedList奇數的位置是開頭到中間節點的值，所以一開始就透過慢、快的速度(1:2)同時遍歷以找出中間的節點(結束後位於slow的位置上)，接著如果slow不為空就將該節點後頭的LinkedList做翻轉(也就是中間到後頭的LinkedList)，並再將該節點的下一個位置改為nil，如此一來就可以得到兩條LinkedList，一條是原LinkedList的開頭到中間節點，另一條則是原LinkedList的結尾到中間節點，最後就是在這兩條LinkedList的節點之間彼此來回嫁接直到全數節點嫁接完為止 123456789101112131415161718192021222324252627func reorderList(head *ListNode) &#123; var tmp *ListNode var fast *ListNode var reverse *ListNode slow := head if head != nil &#123; fast = head.Next &#125; for fast != nil &amp;&amp; fast.Next != nil &#123; slow = slow.Next fast = fast.Next.Next &#125; if slow != nil &#123; reverse = reverseList(slow.Next) slow.Next = nil &#125; for head != nil &#123; tmp = head head = head.Next tmp.Next = reverse if reverse != nil &#123; tmp = reverse reverse = reverse.Next tmp.Next = head &#125; &#125;&#125; 顛倒LinkedList節點的實作則是直接之前的文章: \bReverse Linked List，詳細的節說可以到該處查看 1234567891011func reverseList(node *ListNode) *ListNode &#123; var flag *ListNode var preNode *ListNode for node != nil &#123; flag = node node = node.Next flag.Next = preNode preNode = flag &#125; return flag&#125; 完整程式碼:1234567891011121314151617181920212223242526272829303132333435363738func reorderList(head *ListNode) &#123; var tmp *ListNode var fast *ListNode var reverse *ListNode slow := head if head != nil &#123; fast = head.Next &#125; for fast != nil &amp;&amp; fast.Next != nil &#123; slow = slow.Next fast = fast.Next.Next &#125; if slow != nil &#123; reverse = reverseList(slow.Next) slow.Next = nil &#125; for head != nil &#123; tmp = head head = head.Next tmp.Next = reverse if reverse != nil &#123; tmp = reverse reverse = reverse.Next tmp.Next = head &#125; &#125;&#125;func reverseList(node *ListNode) *ListNode &#123; var flag *ListNode var preNode *ListNode for node != nil &#123; flag = node node = node.Next flag.Next = preNode preNode = flag &#125; return flag&#125; 總結:要將LinkedList:L0→L1→…→Ln-1→Ln排序成L0→Ln→L1→Ln-1→L2→Ln-2→…，透過仔細觀查規律會發現奇數位置的值正好是原始LinkedList開頭到中間的值，偶數位置的值則是中間到後頭值的顛倒，剩下的只要知道怎麼找出”LinkedList的中間節點”與”顛倒中間到後頭LinkedList的節點”就只要嫁接就好。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://blog.yunchen.tw/tags/LinkedList/"}]},{"title":"Word Break","slug":"word-break","date":"2017-06-17T16:00:00.000Z","updated":"2017-06-19T07:44:33.000Z","comments":true,"path":"2017/06/18/word-break/","link":"","permalink":"https://blog.yunchen.tw/2017/06/18/word-break/","excerpt":"","text":"Word BreakGiven a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words. For example:Given 12s = &quot;leetcode&quot;,dict = [&quot;leet&quot;, &quot;code&quot;]. Return true because “leetcode” can be segmented as “leet code”. 提示 解題應用 DynamicProgramming 規律觀查 Default:123func wordBreak(s string, wordDict []string) bool &#123;&#125; 解答思路:一開始想到兩種作法，組合或是消除法，如果要用字典檔的詞來組合一來是會花費大量的時間，二來是字典檔也會包含亳不相關的詞(只要字典檔有包含結果的組合就好，且可重覆使用)，而如果使用消除法也就是如果字典檔的詞在字串之中就把字串中的該詞消除掉，然而最大的問題是像cac,[c,ca]，如果把開頭的c先消除就會導致後續沒辦法把剩下的a給消除(因為只能消除ca)，也就是說很難控制確定要消除的位置，如果再用遞回處理所有可能的情況一樣會花費大量的時間，所以最後用標註法也許是比較好的辦法，如果字典檔的詞在字串之中就把字串中的該詞所在的位置給標註起來而非消除，以剛才的例子來說: 字串: cac 字典檔: [c,ca] 第1個在字典檔在存在 標註1的位置 1&quot;c&quot;ac 第1~2個在字典檔在存在 標註2的位置 1&quot;ca&quot;c 第1~3個在字典檔在不存在 跳過 1&quot;cac&quot; 第2~3個在字典檔在不存在 跳過 1c&quot;ac&quot; 第3個在字典檔在存在 標註3的位置 1ca&quot;c&quot; 唯一要注意到的是在標註前都要檢查前一個的位置是否已標註存在，要從頭慢慢往後標註而非跳著做標註，如此一來才能確保前面的字串都能藉由字典檔的詞依序組出，標註結束後只要檢查最後一個位置是否有被標註就可以知道該字串是否能由字典檔組合出來了。 程式碼解說:既然要用標註的方法來紀錄字典檔的詞是否在字串之中，一開始就先初始化對應字串長度的boolean陣列，不過因為標註前都要檢查前一個的位置是否已標註存在，但最開頭的標註並沒有前一個可以判斷，所以標註的陣列就需要再多一格來當作開頭前一個並存放true以確保後續操作上的一致性，接著就是以巢狀迴圈從字串中取出子字串(i為子字串結尾位置的下一個，j則是子字串開頭位置)，再以一迴圈從字典檔中一一取詞做比對，如果前一個標註的位置存在(“前一個子字串結尾位置的下一個i”來代表詞的標註位置與下一個”子字串開頭位置j”相同)且子字串與字典檔的詞相同，就在i的位置標註為true並跳開兩層內層的迴圈以找出下一個字典檔對應的詞，待標註全數結束後只要檢查最後一個位置是否有被標註就可以知道該字串是否能由字典檔組合出來了 123456789101112131415161718var substring stringexist := make([]bool, len(s)+1)exist[0] = truefor i := 1; i &lt;= len(s); i++ &#123; for j := 0; j &lt; i; j++ &#123; substring = s[j:i] for _, v := range wordDict &#123; if exist[j] &amp;&amp; v == substring &#123; exist[i] = true break &#125; &#125; if exist[i] &#123; break &#125; &#125;&#125;return exist[len(s)] 完整程式碼:1234567891011121314151617181920func wordBreak(s string, wordDict []string) bool &#123; var substring string exist := make([]bool, len(s)+1) exist[0] = true for i := 1; i &lt;= len(s); i++ &#123; for j := 0; j &lt; i; j++ &#123; substring = s[j:i] for _, v := range wordDict &#123; if exist[j] &amp;&amp; v == substring &#123; exist[i] = true break &#125; &#125; if exist[i] &#123; break &#125; &#125; &#125; return exist[len(s)]&#125; 總結:要判斷字典檔中的詞是否能組出目標字串，做法是字典檔的詞如果在字串之中就把字串中的該詞所在的位置給標註起來，而要注意到的是在標註前都要檢查前一個的位置是否已標註存在，要從頭慢慢往後標註而非跳著做標註，如此一來才能確保前面的字串都能藉由字典檔的詞依序組出，標註結束後只要檢查最後一個位置是否有被標註就可以知道該字串是否能由字典檔組合出來了。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"https://blog.yunchen.tw/tags/DynamicProgramming/"}]},{"title":"Single Number II","slug":"single-number-II","date":"2017-06-16T16:00:00.000Z","updated":"2017-06-17T08:01:35.000Z","comments":true,"path":"2017/06/17/single-number-II/","link":"","permalink":"https://blog.yunchen.tw/2017/06/17/single-number-II/","excerpt":"","text":"Single Number IIGiven an array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 提示 解題應用 BitManipulation XOR,AND,NOT Default:123func singleNumber(nums []int) int &#123;&#125; 解答思路:雖然說之前有一篇Single Number，不過這次如果是重覆的資料出現三次而要找出落單的值，在同樣要時間複雜度要O(n)而空間複雜度則是O(1)的情況下，做法與概念跟先前只重覆兩次不同，摸索半天也無法藉由先前題目經驗來啟發，討論區有人提出了非常漂亮的解法，完全符合時間與空間複雜度的條件，主要就是以兩個變數(分為儲存與備份)來對位元的操作結果進行儲存，利用迴圈遍歷陣列取出每個元素來做以下動作(兩個變數save/backup初始值為0;value為元素值): 12save = (save ^ value) &amp;^ backupbackup = (backup ^ value) &amp;^ save 變數與元素做XOR其概念可參考前一篇，XOR能保留對應數量的位元組合，至於為何能將重覆三次的資料篩選掉，連續取出三個相同的值來看的話其流程大致如下: 第一次取出X值，save暫存X值而backup還尚未儲存 12save: Xbackup: 0 第二次再取出X值，save清除該值而backup會備份先前的X值 12save: 0backup: X 第三次仍是取出X值的話，save與backup最後都會彼此清空 12save: 0backup: 0 透過如此巧妙的篩選方式只要資料是重覆三次甚至更多，要來找出落單的值都能適用於該作法。 程式碼解說:程式碼相單純並不複雜，詳細的概念可以參考上述解答思路，建議可以自行推演一遍來加速理解 1234567var save intvar backup intfor _, v := range nums &#123; save = (save ^ v) &amp;^ backup backup = (backup ^ v) &amp;^ save&#125;return save 完整程式碼:123456789func singleNumber(nums []int) int &#123; var save int var backup int for _, v := range nums &#123; save = (save ^ v) &amp;^ backup backup = (backup ^ v) &amp;^ save &#125; return save&#125; 總結:陣列中重覆的資料會出現三次而要找出唯一落單的值，其作法是每次從陣列取出元素時，做以下的操作(兩個變數save/backup初始值為0;value為元素值): 12save = (save ^ value) &amp;^ backupbackup = (backup ^ value) &amp;^ save 如果連續取出三個相同的值，第一次進來的重覆值會暫存在save中，第二次重覆值進來save會清除該值而backup會備份該值，第三次再進來save與backup都會彼此清除該值，透過此作法來篩選只要資料是重覆三次甚至更多的情況都能用來找出落單的值。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"BitManipulation","slug":"BitManipulation","permalink":"https://blog.yunchen.tw/tags/BitManipulation/"}]},{"title":"Gas Station","slug":"gas-station","date":"2017-06-15T16:00:00.000Z","updated":"2017-06-16T13:35:11.000Z","comments":true,"path":"2017/06/16/gas-station/","link":"","permalink":"https://blog.yunchen.tw/2017/06/16/gas-station/","excerpt":"","text":"Gas StationThere are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1. Note: The solution is guaranteed to be unique. 提示 解題應用 Greedy 規律觀查 Default:123func canCompleteCircuit(gas []int, cost []int) int &#123;&#125; 解答思路:既然要找出哪裡開始加油起跑能順利繞完整個圓環，一開始當然就以\b一迴圈遍歷整個加油點來做為起始點，有了起始點後就再以內層迴圈作為巢狀迴圈嘗試繞整個圓環，而因為油箱沒有油量限制，所以每次經過加油點一定都要加到底並同時將總油量減去耗油量，如果總油量有剩表示能撐到下一個加油點，而如果油量不夠就放棄再重新以下一個新的加油點來做為起始點直到找出目標起始點，最後記得因為是以陣列來表示圓環，所以每次index都要記得與陣列長度相除取餘數，才能在index超出陣列範圍時能回到陣列開頭以繼續遍歷圓環。 程式碼解說:因為如果不存在能順利繞完整個圓環的起始點要回傳-1，所以先將結果值初始化為-1，接著以\b一迴圈遍歷整個加油點來做為起始點，每次開始一趟旅程當然也要先將油箱清空歸0才開始，並將結果值暫存目前的起始點，再以內層迴圈作為巢狀迴圈嘗試繞整個圓環(起始點位置+前進的距離作為index)，每次index都要記得與陣列長度相除取餘數以避免超出陣列範圍，經過加油點一定都要加到底並同時將總油量減去耗油量，如果總油量有剩(大於等於0)表示能撐到下一個加油點繼續往下開，否則將結果值改回-1，再以下一個新的加油點來做為起始點重新開始，最後如果發現結果值不為-1表示順利繞整個圓環，此時就不需要再找新的起始點便結束迴圈回傳該index 12345678910111213141516171819var index intvar gasSum intresult := -1for start, _ := range gas &#123; gasSum = 0 result = start for i := 0; i &lt; len(gas); i++ &#123; index = (start + i) % len(gas) gasSum += gas[index] - cost[index] if gasSum &lt; 0 &#123; result = -1 break &#125; &#125; if result != -1 &#123; break &#125;&#125;return result 完整程式碼:123456789101112131415161718192021func canCompleteCircuit(gas []int, cost []int) int &#123; var index int var gasSum int result := -1 for start, _ := range gas &#123; gasSum = 0 result = start for i := 0; i &lt; len(gas); i++ &#123; index = (start + i) % len(gas) gasSum += gas[index] - cost[index] if gasSum &lt; 0 &#123; result = -1 break &#125; &#125; if result != -1 &#123; break &#125; &#125; return result&#125; 總結:有兩串陣列分別記錄圓環路徑上能加油的量與耗油量，要回傳從哪裡開始加油起跑能順利繞完整個圓環，先以\b一迴圈遍歷整個加油點來做為起始點，再以內層迴圈作為巢狀迴圈嘗試繞整個圓環，每次經過加油點一定都要加到底並同時將總油量減去耗油量，如果總油量有剩表示能撐到下一個加油點，而如果油量不夠就放棄再重新以下一個新的加油點來做為起始點直到找出目標起始點為止。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Greedy","slug":"Greedy","permalink":"https://blog.yunchen.tw/tags/Greedy/"}]},{"title":"Palindrome Partitioning","slug":"palindrome-partitioning","date":"2017-06-14T16:00:00.000Z","updated":"2017-06-15T15:46:57.000Z","comments":true,"path":"2017/06/15/palindrome-partitioning/","link":"","permalink":"https://blog.yunchen.tw/2017/06/15/palindrome-partitioning/","excerpt":"","text":"Palindrome PartitioningGiven a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. For example:Given s = “aab”,Return 1234[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] 提示 解題應用 Backtracking Recursive Default:123func partition(s string) [][]string &#123;&#125; 解答思路:這題卡了很長一段時間，原因在於最初覺得應該要透過規定好的長度來找出範圍內的回文，並再將該範圍慢慢擴大最後至整個字串，然而題目要的是字串拆開後所有各別的子字串也都是回文，這種做法很難透過簡單的遞回實現，整個過程會變的相當複雜，當看到其它人的討論才豁然開朗，甚至還有人用畫題圖來解說讓人一看便完全理解，整個流程其實非常簡單，如下: charlie yupeng solution 其實就是從開頭開始慢慢增長子字串，每次檢查最前面增長的那一段字串是否符合回文，如果不符合就繼續增長再做檢查，而如果符合則將後面其餘的子字串做遞回並重覆上述動作，直到最後剛開始開頭增長的子字串已經到達與原字串相同長度並列出所有符合回文條件的子字串組合。 程式碼解說:因為是透過遞回來列出所有符合回文條件的子字串組合，所以一開始就將字串帶入遞回函數之中，其中第二個參數是目前已符合回文條件的子字串 123func partition(s string) [][]string &#123; return backTrack(s, []string&#123;&#125;)&#125; 接下來就是處理遞回函數的細節，如果進來的字串為空就直接回傳目前已符合回文條件的子字串，因為slice的特性所以這邊會需要將其複製一份再做回傳，而如果還有字串存在正如思路所述，從開頭開始慢慢增長子字串，每次檢查最前面增長的那一段字串是否符合回文，如果不符合就繼續增長再做檢查，符合的話則將後面其餘的子字串做遞回以重覆上述動作，並記得將最前面符合回文條件的增長字串放入子字串組合中再跟著帶入遞回，直到找出所有符合回文條件的子字串組合才向上回傳整個結果 12345678910111213141516171819func backTrack(s string, set []string) [][]string &#123; if len(s) == 0 &#123; tmpSet := make([]string, len(set)) copy(tmpSet, set) return [][]string&#123;tmpSet&#125; &#125; var subString string var tmp [][]string var result [][]string for i, _ := range s &#123; subString = s[:i+1] if !isPalindrome(subString) &#123; continue &#125; tmp = backTrack(s[i+1:], append(set, subString)) result = append(result, tmp...) &#125; return result&#125; 最後這部分的程式碼就只是用兩個指標分別指向字串的頭與尾，並逐漸向內縮檢查頭與尾所指向的字元兩邊是否相同，如果不同就回傳false直到兩個指標都指向同一個字元才停止迴圈並回傳true 123456789101112func isPalindrome(s string) bool &#123; rear := len(s) - 1 for i, v := range s &#123; if i == rear &#123; break &#125; else if v != rune(s[rear]) &#123; return false &#125; rear-- &#125; return true&#125; 完整程式碼:12345678910111213141516171819202122232425262728293031323334func partition(s string) [][]string &#123; return backTrack(s, []string&#123;&#125;)&#125;func backTrack(s string, set []string) [][]string &#123; if len(s) == 0 &#123; tmpSet := make([]string, len(set)) copy(tmpSet, set) return [][]string&#123;tmpSet&#125; &#125; var subString string var tmp [][]string var result [][]string for i, _ := range s &#123; subString = s[:i+1] if !isPalindrome(subString) &#123; continue &#125; tmp = backTrack(s[i+1:], append(set, subString)) result = append(result, tmp...) &#125; return result&#125;func isPalindrome(s string) bool &#123; rear := len(s) - 1 for i, v := range s &#123; if i == rear &#123; break &#125; else if v != rune(s[rear]) &#123; return false &#125; rear-- &#125; return true&#125; 總結:字串拆開後所有各別的子字串也都是回文並列出所有可能(可以參考解答思路的流程圖)，其實就是從開頭開始慢慢增長子字串，每次檢查最前面增長的那一段字串是否符合回文，如果不符合就繼續增長再做檢查，而如果符合則將後面其餘的子字串做遞回並重覆上述動作，直到最後剛開始開頭增長的子字串已經到達與原字串相同長度並列出所有符合回文條件的子字串組合。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Backtracking","slug":"Backtracking","permalink":"https://blog.yunchen.tw/tags/Backtracking/"}]},{"title":"Sum Root to Leaf Numbers","slug":"sum-root-to-leaf-numbers","date":"2017-06-13T16:00:00.000Z","updated":"2017-06-14T17:00:58.000Z","comments":true,"path":"2017/06/14/sum-root-to-leaf-numbers/","link":"","permalink":"https://blog.yunchen.tw/2017/06/14/sum-root-to-leaf-numbers/","excerpt":"","text":"Sum Root to Leaf NumbersGiven a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers. For example:123 1 / \\2 3 The root-to-leaf path 1-&gt;2 represents the number 12. The root-to-leaf path 1-&gt;3 represents the number 13. Return the sum = 12 + 13 = 25. 提示 解題應用 DepthFirstSearch PreorderTravel Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sumNumbers(root *TreeNode) int &#123;&#125; 解答思路:這題基本上就是一邊遍歷一邊將值做組合，最後發現到葉子節點的時候才一一將數值組合向上回傳做總合，至於數字要如何做組合也只是將之前的組合值乘上10之後再加上目前的節點值即可，待組合完畢後才將其帶入遞回函數繼續向下做前序遍歷。 程式碼解說:一開始先判斷根節點是否為空，如果是則直接回傳0，不為空才將根節點與目前的數值組合帶入遞回函數之中 123456func sumNumbers(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; return preOrderTravel(root, 0)&#125; 接著就是來處理前序遍歷的細節，因為要做數值組合再來等回傳才能做總合，所以先將之前的組合值乘上10之後再加上目前的節點值，之後判斷左右之節點是否存在，如果不存在表示已到達葉子節點回傳數值的組合，而如果任一邊不存在則繼續向另一邊做前序遍歷，最後如果兩邊子節點都存在，則兩邊都向下做前序遍歷，待兩邊的數值組合回來才做總合並向上回傳整個結果 1234567891011func preOrderTravel(node *TreeNode, sum int) int &#123; sum = sum*10 + node.Val if node.Left == nil &amp;&amp; node.Right == nil &#123; return sum &#125; else if node.Left == nil &#123; return preOrderTravel(node.Right, sum) &#125; else if node.Right == nil &#123; return preOrderTravel(node.Left, sum) &#125; return preOrderTravel(node.Left, sum) + preOrderTravel(node.Right, sum)&#125; 完整程式碼:1234567891011121314151617func sumNumbers(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; return preOrderTravel(root, 0)&#125;func preOrderTravel(node *TreeNode, sum int) int &#123; sum = sum*10 + node.Val if node.Left == nil &amp;&amp; node.Right == nil &#123; return sum &#125; else if node.Left == nil &#123; return preOrderTravel(node.Right, sum) &#125; else if node.Right == nil &#123; return preOrderTravel(node.Left, sum) &#125; return preOrderTravel(node.Left, sum) + preOrderTravel(node.Right, sum)&#125; 總結:找出所有二元樹根到葉子的路徑並將路徑上的節點值做組合，最後回傳所有數值組合的總合，基本上就是一邊做前序遍歷一邊將值做組合，最後發現到葉子節點的時候才一一將數值組合向上回傳做總合，至於數字要如何做組合也只是將之前的組合值乘上10之後再加上目前的節點值即可。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"},{"name":"DepthFirstSearch","slug":"DepthFirstSearch","permalink":"https://blog.yunchen.tw/tags/DepthFirstSearch/"}]},{"title":"Best Time to Buy and Sell Stock II","slug":"best-time-to-buy-and-sell-stock-II","date":"2017-06-12T16:00:00.000Z","updated":"2017-06-11T16:42:49.000Z","comments":true,"path":"2017/06/13/best-time-to-buy-and-sell-stock-II/","link":"","permalink":"https://blog.yunchen.tw/2017/06/13/best-time-to-buy-and-sell-stock-II/","excerpt":"","text":"Best Time to Buy and Sell Stock IISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 提示 解題應用 Array Array/Slice Greedy 規律觀查 Default:123func maxProfit(prices []int) int &#123;&#125; 解答思路:建議可以先參考先前Best Time to Buy and Sell Stock的解法，解說較為詳細，基本上概念完全一樣，只是將先前題的程式碼稍做修改而已，如果能找出最好的一筆利潤，當然這次能允許多筆交易的情況下要找出最大利潤就不會太困難。 變成要在多筆交易的情況下找出最大利潤其實透過觀查就會發現到一件事情，如果先前找出最好的一筆交易期間，在相同的時間內改成多筆交易的話利潤一定會比先前的一筆最佳交易更優(在不會笨到賠錢賣的運作下，最差的情況頂多與一筆交易的利潤相同)，所以只要有能賺取利潤的機會就只要馬上賣出，如下: 1234567891011121314151617181920 最好的一筆交易 | - - - - - - - - - - - - - - - |最低價 最高價 1 100 利潤: 100 - 1 = 99 多筆交易(1) | - - - - - - - | - - - - - - - |最低價 ( 賣出/買入 ) 最高價 1 50 100 利潤: (50-1) + (100-50) = 99 多筆交易(2) | - - - | - - - | - - - | - - - |最低價 ( 賣出/買入 ) 最高價 1 99 2 99 100 利潤: (99-1) + (99-2) + (100-99) = 196 最後再注意到同一天可以在賣出股票之後當場再買入股票，好比多筆交易(2)的第四天在以99元賣出之後，馬上又買了99元的股票再第五天才賣出就能多賺1元。 程式碼解說:因為在相同的時間內多筆交易利潤一定會比先前的一筆最佳交易更優，所以只是將先前的邏輯改成只要有能賺取利潤的機會就馬上賣出，這邊只會針對與先前不同的部分來解說，最主要就是當發現賣價比買價高能賺取利潤的時候，就將股票賣出(先前還會多判斷是否比目前的最大利潤大)，並從原本的取代最大利潤改為將每次得到的利潤做總合，最後同一天可以在賣出股票之後當場再買入股票，因此在賣出之後要記得馬上將買入股票的價格改成今日的價格 1234if buyPrice &lt; sellPrice &#123; maxProfit += sellPrice - buyPrice buyPrice = v&#125; 完整程式碼:12345678910111213141516171819202122func maxProfit(prices []int) int &#123; if len(prices) == 0 &#123; return 0 &#125; var maxProfit int buyPrice := prices[0] sellPrice := prices[0] for _, v := range prices[1:] &#123; if v &lt; buyPrice &#123; buyPrice = v sellPrice = 0 &#125; if v &gt; sellPrice &#123; sellPrice = v if buyPrice &lt; sellPrice &#123; maxProfit += sellPrice - buyPrice buyPrice = v &#125; &#125; &#125; return maxProfit&#125; 總結:建議可以先參考先前Best Time to Buy and Sell Stock的解法，解說較為詳細，基本上概念完全一樣，只是這次在允許多筆交易的情況下要找出最大利潤，透過觀查就會發現到如果先前找出最好的一筆交易期間，在相同的時間內改成多筆交易的話利潤一定會比先前的一筆最佳交易更優(最差的情況頂多相同)，所以只是將先前的邏輯改成只要有能賺取利潤的機會就馬上賣出即可。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"Greedy","slug":"Greedy","permalink":"https://blog.yunchen.tw/tags/Greedy/"}]},{"title":"Triangle","slug":"triangle","date":"2017-06-11T16:00:00.000Z","updated":"2017-06-10T16:41:24.000Z","comments":true,"path":"2017/06/12/triangle/","link":"","permalink":"https://blog.yunchen.tw/2017/06/12/triangle/","excerpt":"","text":"TriangleGiven a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example:Given the following triangle 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. 提示 解題應用 Array 要使空間複雜度降至最低需碰壞原始資料 DynamicProgramming 規律觀查 Default:123func minimumTotal(triangle [][]int) int &#123;&#125; 解答思路:這題與二元樹中要找最短路徑的意思一樣，只是這次是三角形或金字塔而且是陣列組合，相對二元樹來說能直接讀取每個位置的值就讓題目簡單很多，而題目只要求空間複雜度不要超過O(n)，但我們可以用的更少，一般來說通常是空間換取時間或時間換取空間，而如果在時間固定的情況下想要讓空間花費更少大多就只有碰壞儲存的原始資料，以這題來說就是只利用題目所給予的二元陣列來儲存結果，從最上層開始將路徑值向下做累加，如果有兩個路徑可能會累加至同一地方，就選擇最小的進行累加，最後在三角形底部的每個值就會是到該點的最短路徑，而題目只要求能到底部的最短路徑就好，因此只要再從中找出最小值即可。 程式碼解說:一開始先將最小值初始化為int的32位元極大值以方便後續進行比較，接著就從用巢狀迴圈取出三角形中的所有值進行累加，如果發現已經累加到三角形的底部，這時就開始比較哪一條到底部的路徑最短(值最小)，而如果尚未累加到底部就繼續做累加，這邊三角形任一層中的值分作四塊來比較，最左側的值、與左邊值的比較、與右邊值的比較、最右側的值，透過觀查可以發現到三角形的最左右兩側值都只能由前一層最左右兩側值來累加(路徑只有最外側會經過)，所以只要是最外側的值就直接向下往兩旁進行累加，至於同一層之中任意一個值左邊如果存在其它值，那麼向下累加時勢必會出現兩個路徑累加至同一地方，因此就要與左邊比較誰目前的路徑較短來做挑選，反之如果右邊存在其它值則做法一樣，最後要注意到的是如果同一層之中有值相同且相鄰的情況(或目前累加的路徑長度相同)，那麼在與左右兩邊存在值比較時的兩種情況，只要固定一邊向下做累加就好，就可以避免重覆累加的情況發生(ex: AB兩值相鄰且相同，兩個路徑向下都會累加至同一地方C，A的右側存在B，B的左側存在A，因此針對相同的情況只要固定一邊來向下累加就可以避免重覆累加)。 123456789101112131415161718192021222324min := math.MaxInt32for ir, row := range triangle &#123; for is, step := range row &#123; if ir+1 == len(triangle) &#123; if step &lt; min &#123; min = step &#125; continue &#125; if is == 0 &#123; triangle[ir+1][0] += step &#125; if is-1 &gt;= 0 &amp;&amp; step &lt; row[is-1] &#123; triangle[ir+1][is] += step &#125; if is+1 &lt; len(row) &amp;&amp; step &lt;= row[is+1] &#123; triangle[ir+1][is+1] += step &#125; if is+1 == len(row) &#123; triangle[ir+1][is+1] += step &#125; &#125;&#125;return min 完整程式碼:1234567891011121314151617181920212223242526func minimumTotal(triangle [][]int) int &#123; min := math.MaxInt32 for ir, row := range triangle &#123; for is, step := range row &#123; if ir+1 == len(triangle) &#123; if step &lt; min &#123; min = step &#125; continue &#125; if is == 0 &#123; triangle[ir+1][0] += step &#125; if is-1 &gt;= 0 &amp;&amp; step &lt; row[is-1] &#123; triangle[ir+1][is] += step &#125; if is+1 &lt; len(row) &amp;&amp; step &lt;= row[is+1] &#123; triangle[ir+1][is+1] += step &#125; if is+1 == len(row) &#123; triangle[ir+1][is+1] += step &#125; &#125; &#125; return min&#125; 總結:要從三角形/金字塔的陣列組合中找出從頂到到底部的最短路徑，如果又有要求空間複雜度不要超過O(n)，碰壞儲存的原始資料便能使空間複雜度降至最低，利用題目所給予的二元陣列來儲存結果，從最上層開始將路徑值向下做累加，如果有兩個路徑可能會累加至同一地方，就選擇最小的進行累加，最後在三角形底部的每個值就會是到該點的最短路徑，如果只要求能到底部的最短路徑，就只要再從中找出最小值即可。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"https://blog.yunchen.tw/tags/DynamicProgramming/"}]},{"title":"Flatten Binary Tree to Linked List","slug":"flatten-binary-tree-to-linked-list","date":"2017-06-10T16:00:00.000Z","updated":"2017-06-10T05:27:44.000Z","comments":true,"path":"2017/06/11/flatten-binary-tree-to-linked-list/","link":"","permalink":"https://blog.yunchen.tw/2017/06/11/flatten-binary-tree-to-linked-list/","excerpt":"","text":"Flatten Binary Tree to Linked ListGiven a binary tree, flatten it to a linked list in-place. For example:Given 12345 1 / \\ 2 5 / \\ \\3 4 6 The flattened tree should look like: 12345678910111 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 提示 解題應用 DepthFirstSearch PreOrderTravel Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func flatten(root *TreeNode) &#123;&#125; 解答思路:透過範例應該可以很明顯的發現二元樹的節點的順序是透過前序遍歷的方式來擺放，而且要將這棵二元樹轉成極端偏右的不平衡樹，既然此二元樹可以透過前序遍歷來取得節點順序，那麼只要先透過前序遍歷來將節點一一放入隊列之中，最後就可以透過隊列依序取出節點來構成極端偏右的不平衡樹。 程式碼解說:因為會使用隊列來儲存節點順序，所以開頭先定義好隊列的結構 1234type QueneNode struct &#123; Node *TreeNode Next *QueneNode&#125; 一開始先初始化隊列與極端偏右不平衡樹頭節節，以確保不論是在隊列還是建構二元樹上第一個節點都能與其它節點一樣有操作上的一致性，接著才將根節點與隊列頭節點帶入遞回函數之中，待遞回使所有節點都依序排入隊列之後，以兩個指標分別紀錄前一個節點的位置與當前節點的位置，不過因為最前面頭節點的位置是我們自行新增的，所以在遍歷隊列之前先將當前位置往後移再開始遍歷，每從隊列取出節點就先將左邊子節點的位置改為nil，接著才接到前一個節點右邊的位置，並再取出下一個隊列的節點之前，記得也要將前一個節點位置改為當前節點位置才再重覆先前的流程 123456789101112func flatten(root *TreeNode) &#123; header := &amp;QueneNode&#123;&amp;TreeNode&#123;&#125;, nil&#125; preOrderTravel(root, header) pre := header header = header.Next for header != nil &#123; header.Node.Left = nil pre.Node.Right = header.Node pre = header header = header.Next &#125;&#125; 前序遍歷的部分如果遍歷的節點不為空，就將該節點放入隊列之中並將隊列結尾的指標移到後頭，最後就是繼續前序遍歷分別往左右子樹再次進行遞回，並記得帶入每次回傳回來新的隊列結尾位置，待子樹都遍歷結束後，再向上回傳隊列結尾的指標，如果後續還有排序的節點才能繼續放入 123456789func preOrderTravel(node *TreeNode, quene *QueneNode) *QueneNode &#123; if node != nil &#123; quene.Next = &amp;QueneNode&#123;node, nil&#125; quene = quene.Next quene = preOrderTravel(node.Left, quene) quene = preOrderTravel(node.Right, quene) &#125; return quene&#125; 完整程式碼:12345678910111213141516171819202122232425type QueneNode struct &#123; Node *TreeNode Next *QueneNode&#125;func flatten(root *TreeNode) &#123; header := &amp;QueneNode&#123;&amp;TreeNode&#123;&#125;, nil&#125; preOrderTravel(root, header) pre := header header = header.Next for header != nil &#123; header.Node.Left = nil pre.Node.Right = header.Node pre = header header = header.Next &#125;&#125;func preOrderTravel(node *TreeNode, quene *QueneNode) *QueneNode &#123; if node != nil &#123; quene.Next = &amp;QueneNode&#123;node, nil&#125; quene = quene.Next quene = preOrderTravel(node.Left, quene) quene = preOrderTravel(node.Right, quene) &#125; return quene&#125; 總結:要將二元樹(節點的順序是透過前序遍歷的方式來擺放)轉成極端偏右的不平衡樹，只要先透過前序遍歷來將節點一一放入隊列之中，最後就可以透過隊列依序取出節點來構成極端偏右的不平衡樹。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"},{"name":"DepthFirstSearch","slug":"DepthFirstSearch","permalink":"https://blog.yunchen.tw/tags/DepthFirstSearch/"}]},{"title":"Path Sum II","slug":"path-sum-II","date":"2017-06-09T16:00:00.000Z","updated":"2017-06-09T15:35:28.000Z","comments":true,"path":"2017/06/10/path-sum-II/","link":"","permalink":"https://blog.yunchen.tw/2017/06/10/path-sum-II/","excerpt":"","text":"Path Sum IIGiven a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. For example:Given the below binary tree and sum = 22, 1234567 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\7 2 5 1 return 1234[ [5,4,11,2], [5,8,4,5]] 提示 解題應用 DepthFirstSearch PostOrderTravel Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func pathSum(root *TreeNode, sum int) [][]int &#123;&#125; 解答思路:建議可以先參考先前Path Sum的解法，解說較為詳細，基本上概念完全一樣，只是將先前題的程式碼稍做修改而已，如果能找出有多少條根到葉子的路徑能符合目標總合，當然這次要列出所有的路徑就不會太困難。 主要也是直接從節點判斷左右子節點是否存在，再考慮需不需要遍歷該子節點，並同時記錄一路上經過的節點值，最後如果需要遍歷子節點時，將已記錄的路徑再次帶入遞回之中直到路徑符合目標總合為止才向上回傳。 程式碼解說:一開始先判斷根節點是否存在，如果連根節點都不存在就直接回傳一個空的二元陣列，而如果根節點存在則將其帶入遞回函數之中，其中第三個參數是用來記錄已遍歷的節點值 123456func pathSum(root *TreeNode, sum int) [][]int &#123; if root == nil &#123; return [][]int&#123;&#125; &#125; return preOrderTravel(root, sum, []int&#123;&#125;)&#125; 再來就是處理遞回的細節，先將目前的節點值記錄到路徑之中，接著判斷左右子節點是否存在，如果兩邊子節點都不存在表示已經到了最尾端的葉子節點，這時就再檢查最後目前總合是否歸0(表示路徑總合符合目標值)，如果是就將此路徑向上回傳(因為slice的特性，這邊要複製到新的陣列再回傳)，如果路徑到底了與目標值不相符則回傳空的路徑回去，至於如果左右子節點任一邊存在就遞回遍歷、記錄那一邊的路徑，兩邊子節點都存在就兩邊都遍歷，只是最後回傳時要記得將兩邊的結果路徑合併才向上回傳 123456789101112131415161718func preOrderTravel(node *TreeNode, sum int, tmp []int) [][]int &#123; tmp = append(tmp, node.Val) if node.Left == nil &amp;&amp; node.Right == nil &#123; if sum - node.Val == 0 &#123; result := make([]int, len(tmp)) copy(result, tmp) return [][]int&#123;result&#125; &#125; return [][]int&#123;&#125; &#125;else if node.Left == nil &#123; return preOrderTravel(node.Right, sum-node.Val, tmp) &#125;else if node.Right == nil &#123; return preOrderTravel(node.Left, sum-node.Val, tmp) &#125; left := preOrderTravel(node.Left, sum-node.Val, tmp) right := preOrderTravel(node.Right, sum-node.Val, tmp) return append(left, right...)&#125; 完整程式碼:123456789101112131415161718192021222324func pathSum(root *TreeNode, sum int) [][]int &#123; if root == nil &#123; return [][]int&#123;&#125; &#125; return preOrderTravel(root, sum, []int&#123;&#125;)&#125;func preOrderTravel(node *TreeNode, sum int, tmp []int) [][]int &#123; tmp = append(tmp, node.Val) if node.Left == nil &amp;&amp; node.Right == nil &#123; if sum - node.Val == 0 &#123; result := make([]int, len(tmp)) copy(result, tmp) return [][]int&#123;result&#125; &#125; return [][]int&#123;&#125; &#125;else if node.Left == nil &#123; return preOrderTravel(node.Right, sum-node.Val, tmp) &#125;else if node.Right == nil &#123; return preOrderTravel(node.Left, sum-node.Val, tmp) &#125; left := preOrderTravel(node.Left, sum-node.Val, tmp) right := preOrderTravel(node.Right, sum-node.Val, tmp) return append(left, right...)&#125; 總結:建議可以先參考先前Path Sum的解法，解說較為詳細，基本上概念完全一樣，這次只是要從紀錄符合條件的路徑數改為列出所有的路徑，主要也是直接從節點判斷左右子節點是否存在，再考慮需不需要遍歷該子節點，並同時記錄一路上經過的節點值，最後如果需要遍歷子節點時，將已記錄的路徑再次帶入遞回之中直到路徑符合目標總合為止才向上回傳。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"},{"name":"DepthFirstSearch","slug":"DepthFirstSearch","permalink":"https://blog.yunchen.tw/tags/DepthFirstSearch/"}]},{"title":"Convert Sorted List to Binary Search Tree","slug":"convert-sorted-list-to-binary-search-tree","date":"2017-06-08T16:00:00.000Z","updated":"2017-06-08T01:34:14.000Z","comments":true,"path":"2017/06/09/convert-sorted-list-to-binary-search-tree/","link":"","permalink":"https://blog.yunchen.tw/2017/06/09/convert-sorted-list-to-binary-search-tree/","excerpt":"","text":"Convert Sorted List to Binary Search TreeGiven a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. 提示 解題應用 DepthFirstSearch InorderTravel LinkedList Pointer Default:123456789101112131415161718/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; *//** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sortedListToBST(head *ListNode) *TreeNode &#123;&#125; 解答思路:建議可以先參考先前Convert Sorted Array to Binary Search Tree的解法，解說較為詳細，基本上概念完全一樣，只是將先前題的程式碼稍做修改而已，如果能將排序陣列還原回二元搜尋、平衡樹，當然要將排序LinkedList也還原回二元搜尋、平衡樹就不會太困難。 排序陣列與排序LinkedList最大的差異是陣列能直接取出中間值來當作根節點，LinkedList只能先遍歷之後才能找出中間值，其實也不過是多了這一點點的難度而已，只要同時以快、慢(速度2:1，快的一次遍歷兩個節點，慢的一次只遍歷一個節點)兩個指標同時遍歷LinkedList，最後當比較快的指標到達LinkedList最後一個節點，此時比較慢的指標就會指向中間值的節點了，而知道LinkedList的中間值之後，剩下的處理方式就沒有什麼太大差異。 程式碼解說:這邊最初也是直接將由小至大排序好的LinkedList帶入遞回函數之中來還原回二元搜尋樹 123func sortedListToBST(head *ListNode) *TreeNode &#123; return construct(head)&#125; 接著一樣處理遞回的細節，因為空節點、1個節點的情況與2個節點(包含)以上的情況處理方法完全不同，所以一開始要先針對前兩個情況做處理，如果進來的節點為空就直接回傳空的節點位址，而如果進來的節點只有1個(下一個節點位置為空)，則將其做為新建的根節點回傳，再來便開始同時以快、慢(速度2:1)兩個指標同時遍歷LinkedList，兩個指標的初始位置當然分別是第1、2個節點，直到比較快的指標到達LinkedList最後一個節點才停止迴圈，這邊要注意到的是比較快的指標如果後頭的節點數不足兩個一樣停止遍歷，如此一來就可以讓比較慢的指標停在中間節點的前一個，因為中間節點之前的所有節點屬於左子樹，要記得將該串最後一個節點的下一個位置改為nil才能往下遞回(帶入整串LinkedList，也就是第一個節點的位置)，右子樹的還原則是帶入根節點的下一個位置到遞回函數，待兩側子樹的位址回來，最後才向上回傳新建的根節點位址並嫁接左右子樹 123456789101112131415161718func construct(head *ListNode) *TreeNode &#123; if head == nil &#123; return nil &#125; else if head.Next == nil &#123; return &amp;TreeNode&#123;head.Val, nil, nil&#125; &#125; slow := head fast := head.Next for fast != nil &amp;&amp; fast.Next != nil &amp;&amp; fast.Next.Next != nil &#123; slow = slow.Next fast = fast.Next.Next &#125; root := slow.Next slow.Next = nil left := construct(head) right := construct(root.Next) return &amp;TreeNode&#123;root.Val, left, right&#125;&#125; 完整程式碼:123456789101112131415161718192021func sortedListToBST(head *ListNode) *TreeNode &#123; return construct(head)&#125;func construct(head *ListNode) *TreeNode &#123; if head == nil &#123; return nil &#125; else if head.Next == nil &#123; return &amp;TreeNode&#123;head.Val, nil, nil&#125; &#125; slow := head fast := head.Next for fast != nil &amp;&amp; fast.Next != nil &amp;&amp; fast.Next.Next != nil &#123; slow = slow.Next fast = fast.Next.Next &#125; root := slow.Next slow.Next = nil left := construct(head) right := construct(root.Next) return &amp;TreeNode&#123;root.Val, left, right&#125;&#125; 總結:建議可以先參考先前Convert Sorted Array to Binary Search Tree的解法，解說較為詳細，基本上概念完全一樣，只是這次是要將排序LinkedList也還原回二元搜尋、平衡樹而非排序陣列，兩者最大的差異是陣列能直接取出中間值來當作根節點，不過LinkedList只要同時以快、慢(速度2:1，快的一次遍歷兩個節點，慢的一次只遍歷一個節點)兩個指標同時遍歷LinkedList，最後當比較快的指標到達LinkedList最後一個節點，此時比較慢的指標就會指向中間值的節點了，而知道LinkedList的中間值之後，剩下的處理方式就沒有什麼太大差異。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://blog.yunchen.tw/tags/LinkedList/"},{"name":"DepthFirstSearch","slug":"DepthFirstSearch","permalink":"https://blog.yunchen.tw/tags/DepthFirstSearch/"}]},{"title":"Convert Sorted Array to Binary Search Tree","slug":"convert-sorted-array-to-binary-search-tree","date":"2017-06-07T16:00:00.000Z","updated":"2017-06-07T12:26:04.000Z","comments":true,"path":"2017/06/08/convert-sorted-array-to-binary-search-tree/","link":"","permalink":"https://blog.yunchen.tw/2017/06/08/convert-sorted-array-to-binary-search-tree/","excerpt":"","text":"Convert Sorted Array to Binary Search TreeGiven an array where elements are sorted in ascending order, convert it to a height balanced BST. 提示 解題應用 DepthFirstSearch InorderTravel Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sortedArrayToBST(nums []int) *TreeNode &#123;&#125; 解答思路:如果知道二元搜尋樹經過中序遍歷得到的結果會是由小至大排序好的陣列，而且中序遍歷的結果陣列如果隨意指定任意值作為根節點的值，該根節點左邊全部的值就是左子樹的節點值，右邊全部的值就是右子樹的節點值，那麼現在給你一個小至大排序好的陣列，要還原成二元搜尋樹就不是什麼大問題，唯一要注意的就是要指定哪個值作為根節點就是問題所在，根據敘述可以得知該二元搜尋樹同時也要是一棵平衡樹，即然這樣當然每次就只挑陣列最中間的值來做為根節點，如此一來最後的二元搜尋樹就肯定會是平衡樹，至於如果陣列值的數量是偶數的話，本題是以中間偏後主為主，如[1,2,3,4]則取3作為根節點。 程式碼解說:如果知道了中序遍歷與排序陣列間關係的話，就直接將由小至大排序好的陣列帶入遞回函數之中來還原回二元搜尋樹 123func sortedArrayToBST(nums []int) *TreeNode &#123; return construct(nums)&#125; 接下來就是遞回還原二元樹的處理，如果進來的排序陣列為空，表示此節點不存在直接回傳nil位址，而如果不為空則從陣列中取出中間的值作為根節點值(這邊直接將陣列長度除以2來作為index)，並記得將根節點值左側全部帶入左子樹，根節點值右側全部帶入右子樹，分別再次往下遞回，待兩側子樹的位址回來，最後才向上回傳新建的根節點位址並嫁接左右子樹 123456789func construct(nums []int) *TreeNode &#123; if len(nums) == 0 &#123; return nil &#125; rootIndex := len(nums) / 2 left := construct(nums[:rootIndex]) right := construct(nums[rootIndex+1:]) return &amp;TreeNode&#123;nums[rootIndex], left, right&#125;&#125; 完整程式碼:123456789101112func sortedArrayToBST(nums []int) *TreeNode &#123; return construct(nums)&#125;func construct(nums []int) *TreeNode &#123; if len(nums) == 0 &#123; return nil &#125; rootIndex := len(nums) / 2 left := construct(nums[:rootIndex]) right := construct(nums[rootIndex+1:]) return &amp;TreeNode&#123;nums[rootIndex], left, right&#125;&#125; 總結:要將一個小至大排序好的陣列還原成二元搜尋、平衡樹的話，每次只挑陣列最中間的值來做為根節點，其中該根節點左邊全部的值就是左子樹的節點值，右邊全部的值就是右子樹的節點值，最後透過遞回不斷重覆上述動作便能順利將排序陣列還原回二元搜尋、平衡樹。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"},{"name":"DepthFirstSearch","slug":"DepthFirstSearch","permalink":"https://blog.yunchen.tw/tags/DepthFirstSearch/"}]},{"title":"Construct Binary Tree from Inorder and Postorder Traversal","slug":"construct-binary-tree-from-inorder-and-postorder-traversal","date":"2017-06-06T16:00:00.000Z","updated":"2017-06-06T16:00:23.000Z","comments":true,"path":"2017/06/07/construct-binary-tree-from-inorder-and-postorder-traversal/","link":"","permalink":"https://blog.yunchen.tw/2017/06/07/construct-binary-tree-from-inorder-and-postorder-traversal/","excerpt":"","text":"Construct Binary Tree from Inorder and Postorder TraversalGiven inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. 提示 解題應用 DepthFirstSearch InorderTravel/PostorderTravel Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func buildTree(inorder []int, postorder []int) *TreeNode &#123;&#125; 解答思路:先前有一篇Construct Binary Tree from Preorder and Inorder Traversal是透過前序遍歷與中序遍歷的結果來還原成一棵二元樹，而這次則是要透過中序遍歷與後序遍歷的結果來還原，中序遍歷仍是能藉由根節點的值來知道左右子樹有哪些節點值，後序遍歷雖然與前序遍歷一樣能藉由規律取得樹的根節點，不過這次不需要像前序遍歷一樣依序取出，後續遍歷的根節點一直都放在最後頭，如下: 中序遍歷: “ADEF” G ‘HMZ’ 後序遍歷: AEFDHZM “G” 一開始先透過後序遍歷陣列的最後一個值取得樹的根節點，首先是G為根節點 再來藉由根節點的值透過中序遍歷來知道左右子樹有哪些節點值，透過G的根節點得知左子樹有ADEF的節點值，右子樹有HMZ 123 G ↙ ↘ADEF HMZ 左子樹的中序遍歷: “A” D ‘EF’ 左子樹的後序遍歷: AEF “D” 接著因為從先前中序遍歷知道了左子樹有哪些節點值之後，再對照後序遍歷發現剛好是最前面的4個節點值，而該4個節點值在後序遍歷的陣列中排在最後一個為D，所以D就作為根節點並一樣透過該節點劃分左右子樹的節點值 12345 G ↙ ↘ D HMZ ↙ ↘A EF 後面的細節就不再全數推倒，總而言之就是從後序遍歷取出最後一個值作為樹的根節點，再至中序遍歷來推得左右子樹分別有哪些節點值，最後就是透過遞回來構成一棵二元樹。 程式碼解說:因為是直接藉由中序遍歷與後序遍歷的結果來還原成一棵二元樹，所以一開始便直接將中序遍歷與後序遍歷的陣列帶入遞回函數中 123func buildTree(inorder []int, postorder []int) *TreeNode &#123; return construct(inorder, postorder)&#125; 接下來就是遞回還原二元樹的處理，如果中序遍歷的陣列結果為空，表示此節點不存在直接回傳nil位址，而如果不為空則從後序遍歷陣列中取出最後一個值作為根節點，並從中序遍歷的陣列中尋找根節點值所在的位置以得知左右子樹有哪些節點值，這邊就單純用迴圈一個個比較直到發現相同值為止，此時就再次往下遞回左右子樹，並記得將中序遍歷陣列的根節點值左側全部帶入左子樹，根節點值右側全部帶入右子樹，後序遍歷陣列則是取陣列中最前面與中序遍歷陣列根節點值左側相同數量的值帶入左子樹，中序遍歷陣列根節點值右側相同數量的值帶入右子樹(從最前面左側相同數量的值後頭開始算才是屬於右側，到倒數第二個值因為最後一個值就是根節點的值)，待兩側子樹的位址回來，最後才向上回傳新建的根節點位址並嫁接左右子樹 123456789101112131415161718func construct(inorder []int, postorder []int) *TreeNode &#123; if len(inorder) == 0 &#123; return nil &#125; var left *TreeNode var right *TreeNode var leftInOrder []int root := postorder[len(postorder)-1] for i, v := range inorder &#123; if root == v &#123; leftInOrder = inorder[:i] left = construct(leftInOrder, postorder[:len(leftInOrder)]) right = construct(inorder[i+1:], postorder[len(leftInOrder):len(postorder)-1]) break &#125; &#125; return &amp;TreeNode&#123;root, left, right&#125;&#125; 完整程式碼:123456789101112131415161718192021func buildTree(inorder []int, postorder []int) *TreeNode &#123; return construct(inorder, postorder)&#125;func construct(inorder []int, postorder []int) *TreeNode &#123; if len(inorder) == 0 &#123; return nil &#125; var left *TreeNode var right *TreeNode var leftInOrder []int root := postorder[len(postorder)-1] for i, v := range inorder &#123; if root == v &#123; leftInOrder = inorder[:i] left = construct(leftInOrder, postorder[:len(leftInOrder)]) right = construct(inorder[i+1:], postorder[len(leftInOrder):len(postorder)-1]) break &#125; &#125; return &amp;TreeNode&#123;root, left, right&#125;&#125; 總結:要透過中序遍歷與後序遍歷的結果來還原成一棵二元樹，主要就是從後序遍歷取出最後一個值作為樹的根節點，再至中序遍歷來推得左右子樹分別有哪些節點值，最後就是透過遞回來構成一棵二元樹。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"},{"name":"DepthFirstSearch","slug":"DepthFirstSearch","permalink":"https://blog.yunchen.tw/tags/DepthFirstSearch/"}]},{"title":"Construct Binary Tree from Preorder and Inorder Traversal","slug":"construct-binary-tree-from-preorder-and-inorder-traversal","date":"2017-06-05T16:00:00.000Z","updated":"2017-06-06T15:43:26.000Z","comments":true,"path":"2017/06/06/construct-binary-tree-from-preorder-and-inorder-traversal/","link":"","permalink":"https://blog.yunchen.tw/2017/06/06/construct-binary-tree-from-preorder-and-inorder-traversal/","excerpt":"","text":"Construct Binary Tree from Preorder and Inorder TraversalGiven preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. 提示 解題應用 DepthFirstSearch PreorderTravel/InorderTravel Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func buildTree(preorder []int, inorder []int) *TreeNode &#123;&#125; 解答思路:這次要透過前序遍歷與中序遍歷的結果來還原成一棵二元樹，但是要注意到是還原成二元樹並不是二元搜尋樹，也就是說沒有經過排序，所以中序遍歷的參數才不是由小至大排序的結果，至於要如何透過這兩個線索來還原，前序遍歷的陣列值最主要就是能依序取得樹的根節點，而中序遍歷則是能藉由根節點的值來知道左右子樹有哪些節點值(根節點值左邊全部的值就是左子樹的節點值，反之右邊全部的值就是右子樹的節點值)，如下(因數字無關排序，以英文表示): 前序遍歷: “G” DAFEMHZ 中序遍歷: “ADEF” G ‘HMZ’ 一開始先透過前序遍歷依序取得樹的根節點，首先是G為根節點 再來藉由根節點的值透過中序遍歷來知道左右子樹有哪些節點值，透過G的根節點得知左子樹有ADEF的節點值，右子樹有HMZ 123 G ↙ ↘ADEF HMZ 前序遍歷: G “D” AFEMHZ 左子樹的中序遍歷: “A” D ‘EF’ 接著因為前序遍歷取得的根節點是D所以先處理左子樹(透過遞回將左右子樹視為樹來分別處理) 12345 G ↙ ↘ D HMZ ↙ ↘A EF 後面的細節就不再全數推倒，總而言之就是從前序遍歷取出值作為樹的根節點，再至中序遍歷來推得左右子樹分別有哪些節點值，最後就是透過遞回來構成一棵二元樹。 程式碼解說:因為是直接藉由前序遍歷與中序遍歷的結果來還原成一棵二元樹，所以一開始便直接將前序遍歷與中序遍歷的陣列帶入遞回函數中，而這邊還要多帶一個變數用來標示目前在前序遍歷陣列中所取出的根節點值到了第幾個，以利我們在同時遞回還原左右子樹時仍能順利的從中依序取出根節點值 1234func buildTree(preorder []int, inorder []int) *TreeNode &#123; var preTravel int return construct(&amp;preTravel, preorder, inorder)&#125; 接下來就是遞回還原二元樹的處理，如果中序遍歷的陣列結果為空，表示此節點不存在直接回傳nil位址，而如果不為空則從前序遍歷陣列中取出的根節點值，並從中序遍歷的陣列中尋找根節點值所在的位置以得知左右子樹有哪些節點值，這邊就單純用迴圈一個個比較直到發現相同值為止，此時就再次往下遞回左右子樹，並記得將中序遍歷陣列的根節點值左側全部帶入左子樹，根節點值右側全部帶入右子樹，待兩側子樹的位址回來，最後才向上回傳新建的根節點位址並嫁接左右子樹 1234567891011121314151617func construct(preTravel *int, preorder []int, inorder []int) *TreeNode &#123; if len(inorder) == 0 &#123; return nil &#125; var left *TreeNode var right *TreeNode root := preorder[*preTravel] *preTravel++ for i, v := range inorder &#123; if root == v &#123; left = construct(preTravel, preorder, inorder[:i]) right = construct(preTravel, preorder, inorder[i+1:]) break &#125; &#125; return &amp;TreeNode&#123;root, left, right&#125;&#125; 完整程式碼:123456789101112131415161718192021func buildTree(preorder []int, inorder []int) *TreeNode &#123; var preTravel int return construct(&amp;preTravel, preorder, inorder)&#125;func construct(preTravel *int, preorder []int, inorder []int) *TreeNode &#123; if len(inorder) == 0 &#123; return nil &#125; var left *TreeNode var right *TreeNode root := preorder[*preTravel] *preTravel++ for i, v := range inorder &#123; if root == v &#123; left = construct(preTravel, preorder, inorder[:i]) right = construct(preTravel, preorder, inorder[i+1:]) break &#125; &#125; return &amp;TreeNode&#123;root, left, right&#125;&#125; 總結:要透過前序遍歷與中序遍歷的結果來還原成一棵二元樹，主要就是從前序遍歷取出值作為樹的根節點，再至中序遍歷來推得左右子樹分別有哪些節點值，最後就是透過遞回來構成一棵二元樹。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"},{"name":"DepthFirstSearch","slug":"DepthFirstSearch","permalink":"https://blog.yunchen.tw/tags/DepthFirstSearch/"}]},{"title":"Binary Tree Zigzag Level Order Traversal","slug":"binary-tree-zigzag-level-order-traversal","date":"2017-06-04T16:00:00.000Z","updated":"2017-06-05T01:49:42.000Z","comments":true,"path":"2017/06/05/binary-tree-zigzag-level-order-traversal/","link":"","permalink":"https://blog.yunchen.tw/2017/06/05/binary-tree-zigzag-level-order-traversal/","excerpt":"","text":"Binary Tree Zigzag Level Order TraversalGiven a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 return its zigzag level order traversal as: 12345[ [3], [20,9], [15,7]] 提示 解題應用 BreadthFirstSearch Quene Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func zigzagLevelOrder(root *TreeNode) [][]int &#123;&#125; 解答思路:原本的想法是在做廣度優先遍歷時，在將節點放入隊列時原本是先放左節點再放右節點，到了下一列改成先放右節點再放左節點，但最後出來的節點順序會發現不太對，其實根本就不需要這麼麻煩，換一個角度來想只要照常做原本的廣度優先遍歷就好，最後只要在做儲存結果時改變儲存的順序就搞定了，從原本依序放入結果陣列後頭，到下一列就改為依序放入結果陣列的開頭，至於放入隊列後要如何知道每個節點原本是位在哪一列，只要隊列的結構再多儲存一個列數的參數就好，如此一來不但能知道哪幾列要將值依序放入結果陣列的後頭還前頭，也能透過列數來確定要放的結果陣列是二元陣列中的哪一列。 程式碼解說:既然要做廣度優先遍歷，一開始當然就先定義好隊列儲存LinkedList的結構，而為了要在節點放入後也能知道該節點的列數，隊列的結構還要再多儲存一個列數的參數 12345type QueneNode struct &#123; Row int Node *TreeNode Next *QueneNode&#125; 接下來就是實作遍歷的細節，一開始先將根節點放入隊列之中(參數分別為列數,節點位置,下一個隊列節點位置)，並以兩個指標來指向隊列的開頭與結尾，接著就是以迴圈不斷遍歷隊列的節點直到隊列為空為止，如果用結果二元陣列中有用來存放該節點列數的陣列(二元陣列中的陣列數大於等於節點的列數)，就再判斷節點的列數是否為2的倍數，如果是就將節點值放入對應列數陣列的開頭，而如果不是2的倍數則將節點值放入對應列數陣列的後頭，至於如果結果二元陣列中沒有用來存放該節點列數的陣列，表示要新增一個對應列數的陣列到二元陣列之中，此時節點值又是新增對應列數陣列的第一個值，所以就直接放進去沒有前後之分，最後待隊列開頭的節點存取完畢後，後續的過程就是正常的廣度優先遍歷，如果左或右子節點存在就將其放入隊列的後頭並移動隊列結尾指標到最後頭，確定將左或右子節點放入隊列之後才再把隊列開頭指標移到下一個 1234567891011121314151617181920212223242526func zigzagLevelOrder(root *TreeNode) [][]int &#123; var result [][]int front := &amp;QueneNode&#123;1, root, nil&#125; rear := front for front != nil &amp;&amp; front.Node != nil &#123; if len(result) &gt;= front.Row &#123; if front.Row%2 == 0 &#123; result[front.Row-1] = append([]int&#123;front.Node.Val&#125;, result[front.Row-1]...) &#125; else &#123; result[front.Row-1] = append(result[front.Row-1], front.Node.Val) &#125; &#125; else &#123; result = append(result, []int&#123;front.Node.Val&#125;) &#125; if front.Node.Left != nil &#123; rear.Next = &amp;QueneNode&#123;front.Row + 1, front.Node.Left, nil&#125; rear = rear.Next &#125; if front.Node.Right != nil &#123; rear.Next = &amp;QueneNode&#123;front.Row + 1, front.Node.Right, nil&#125; rear = rear.Next &#125; front = front.Next &#125; return result&#125; 完整程式碼:12345678910111213141516171819202122232425262728293031type QueneNode struct &#123; Row int Node *TreeNode Next *QueneNode&#125;func zigzagLevelOrder(root *TreeNode) [][]int &#123; var result [][]int front := &amp;QueneNode&#123;1, root, nil&#125; rear := front for front != nil &amp;&amp; front.Node != nil &#123; if len(result) &gt;= front.Row &#123; if front.Row%2 == 0 &#123; result[front.Row-1] = append([]int&#123;front.Node.Val&#125;, result[front.Row-1]...) &#125; else &#123; result[front.Row-1] = append(result[front.Row-1], front.Node.Val) &#125; &#125; else &#123; result = append(result, []int&#123;front.Node.Val&#125;) &#125; if front.Node.Left != nil &#123; rear.Next = &amp;QueneNode&#123;front.Row + 1, front.Node.Left, nil&#125; rear = rear.Next &#125; if front.Node.Right != nil &#123; rear.Next = &amp;QueneNode&#123;front.Row + 1, front.Node.Right, nil&#125; rear = rear.Next &#125; front = front.Next &#125; return result&#125; 總結:如果要將二元樹以鋸齒狀的方式來遍歷(同一層的節點先由左遍歷至右，到下一層再由右遍歷至左)，只要先照常做原本的廣度優先遍歷，最後在做儲存結果時改變儲存的順序並隨著列數的不同將值依序放入結果陣列的後頭或是前頭即可。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Stack","slug":"Stack","permalink":"https://blog.yunchen.tw/tags/Stack/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"},{"name":"BreadthFirstSearch","slug":"BreadthFirstSearch","permalink":"https://blog.yunchen.tw/tags/BreadthFirstSearch/"}]},{"title":"Validate Binary Search Tree","slug":"validate-binary-search-tree","date":"2017-06-03T16:00:00.000Z","updated":"2017-06-04T15:03:51.000Z","comments":true,"path":"2017/06/04/validate-binary-search-tree/","link":"","permalink":"https://blog.yunchen.tw/2017/06/04/validate-binary-search-tree/","excerpt":"","text":"Validate Binary Search TreeGiven a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example 1:123 2 / \\1 3 Binary tree [2,1,3], return true. Example 2:123 1 / \\2 3 Binary tree [1,2,3], return false. 提示 解題應用 DepthFirstSearch InOrderTravel Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func isValidBST(root *TreeNode) bool &#123;&#125; 解答思路:要檢查一個二元樹是否有排序其實非常簡單，如果是一個二元搜尋樹的話，那麼只要中序遍歷其結果就會很神奇的由小排至大，所以利用這個特性只要一邊用中序遍歷一邊檢查此節點值是否比前一個大，直到全數遍歷完畢就可以確認是否為合法的二元搜尋樹。 程式碼解說:因為要一邊用中序遍歷一邊檢查此節點值是否比前一個大，所以參數多一個變數用來儲存前一個節點的值以方便遍歷時能一邊比較，而因為比較的方式是檢查節點值是否比前一個大，所以一開始用0或是Int32位元的極小值做為初始值來讓根節點的值(第1個節點)能與暫存值比較，然而因為題目的測資都有設想到用這些值做為根節點的值，所以最後乾脆就直接用boolean值來判斷是否為初始值 12345func isValidBST(root *TreeNode) bool &#123; var pre int init := true return inOrderTravel(root, &amp;pre, &amp;init)&#125; 接著就是開始處理中序遍歷的細節，如果節點為nil，表示樹的分支檢查到該處都沒有問題因此回傳true，而如果尚未遍歷完畢便繼續中序遍歷，待左子樹結果回傳，如果左子樹回傳出現false或非為根節點初始值的情況下，該節點的值比前一個節點值還小就直接回傳false，否則才繼續中序遍歷，並記得在那之前先將前一個節點值改為目前的節點值，當然後頭的節點遍歷就不再是根節點也一併將boolean值改為false，最後才遍歷右子樹的節點 123456789101112func inOrderTravel(node *TreeNode, pre *int, init *bool) bool &#123; if node == nil &#123; return true &#125; tmp := inOrderTravel(node.Left, pre, init) if !tmp || (!*init &amp;&amp; node.Val &lt;= *pre) &#123; return false &#125; *pre = node.Val *init = false return inOrderTravel(node.Right, pre, init)&#125; 完整程式碼:1234567891011121314151617func isValidBST(root *TreeNode) bool &#123; var pre int init := true return inOrderTravel(root, &amp;pre, &amp;init)&#125;func inOrderTravel(node *TreeNode, pre *int, init *bool) bool &#123; if node == nil &#123; return true &#125; tmp := inOrderTravel(node.Left, pre, init) if !tmp || (!*init &amp;&amp; node.Val &lt;= *pre) &#123; return false &#125; *pre = node.Val *init = false return inOrderTravel(node.Right, pre, init)&#125; 總結:要檢查一個二元搜尋樹是否確實排序的話，那麼只要中序遍歷其結果就會由小排至大，所以利用這個特性只要一邊用中序遍歷一邊檢查此節點值是否比前一個大，直到全數遍歷完畢就可以確認是否為合法的二元搜尋樹。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"},{"name":"DepthFirstSearch","slug":"DepthFirstSearch","permalink":"https://blog.yunchen.tw/tags/DepthFirstSearch/"}]},{"title":"Unique Binary Search Trees II","slug":"unique-binary-search-trees-II","date":"2017-06-02T16:00:00.000Z","updated":"2017-06-02T15:30:17.000Z","comments":true,"path":"2017/06/03/unique-binary-search-trees-II/","link":"","permalink":"https://blog.yunchen.tw/2017/06/03/unique-binary-search-trees-II/","excerpt":"","text":"Unique Binary Search Trees IIGiven an integer n, generate all structurally unique BST’s (binary search trees) that store values 1…n. For example:Given n = 3, your program should return all 5 unique BST’s shown below. 123451 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\2 1 2 3 提示 解題應用 Tree Recursive DynamicProgramming 規律觀查 Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func generateTrees(n int) []*TreeNode &#123;&#125; 解答思路:先前有一篇Unique Binary Search Trees是在計算n個節點的情況下能組出幾種不同的BST，但是這次是要回傳所有不同的組合而非單單個數而已，所以沒有辦法用上公式來處理，透過先前題目可以知道二元樹經過排序的情況下，隨著根節點的值不同，底下的對應組合就是左右子樹的問題，只是這次我們在乎的就不僅僅只是左右子樹的節點數有多少個，而是要實作出所有組合，要實作出所有組合就會用上遞回的方式處理，再想一想對於那些左右子數來說不也是一樣是一棵二元樹，也是先決定根節點再次分成左右子樹，所以對於遞回來說1~n的節點如果取k作為根節點，1~k-1及k+1~n就會是左右子樹的範圍，剩下就是不斷重覆上述行為直到取的根節點是nil為止便能找出所有組合。 程式碼解說:一開始先將節點數為0的情況篩選掉，而因為接下來要透過遞回的方式不斷的在範圍之間取值來作為根節點，所以便以迴圈生成包含1~n的陣列，接著才將該陣列帶入遞回函數之中以取得所有組成的BST 12345678910func generateTrees(n int) []*TreeNode &#123; if n == 0 &#123; return []*TreeNode&#123;&#125; &#125; candidates := make([]int, n) for i := 1; i &lt;= n; i++ &#123; candidates[i-1] = i &#125; return combine(candidates)&#125; 再來就是處理遞回的部分，如果範圍為空就回傳一個包含nil的陣列位址，而之所以不回傳空的陣列是因為最後左右子節樹在與根節點做合併嫁接時，如果任一子樹不存在就假裝用nil節點位址在取代，以利後續能直接從左右子樹的陣列位址取值(空陣列就沒辦法取值來組合)來排列組合，範圍存在的話就先在最外層用迴圈一一取出範圍中的值以分別來做為二元樹的根節點，接著如先前思路所述如果取k作為根節點，1~k-1及k+1~n就會是左右子樹的範圍，就分別再將其再次帶入遞回以找出左右子樹的所有組合，待左右子樹的所有組合回來後，用巢狀迴圈來將左右子樹的所有組合再次進行排列組合，同時新增根節點將左右子樹嫁接並放入結果之中，最後等到範圍內的所有值一一做為根節點進而找出旗下的所有組合之後才向上回傳結果 1234567891011121314151617181920func combine(candidates []int) []*TreeNode &#123; if len(candidates) == 0 &#123; return []*TreeNode&#123;nil&#125; &#125; var new *TreeNode var left []*TreeNode var right []*TreeNode var result []*TreeNode for i, v := range candidates &#123; left = combine(candidates[:i]) right = combine(candidates[i+1:]) for _, lv := range left &#123; for _, rv := range right &#123; new = &amp;TreeNode&#123;v, lv, rv&#125; result = append(result, new) &#125; &#125; &#125; return result&#125; 完整程式碼:123456789101112131415161718192021222324252627282930func generateTrees(n int) []*TreeNode &#123; if n == 0 &#123; return []*TreeNode&#123;&#125; &#125; candidates := make([]int, n) for i := 1; i &lt;= n; i++ &#123; candidates[i-1] = i &#125; return combine(candidates)&#125;func combine(candidates []int) []*TreeNode &#123; if len(candidates) == 0 &#123; return []*TreeNode&#123;nil&#125; &#125; var new *TreeNode var left []*TreeNode var right []*TreeNode var result []*TreeNode for i, v := range candidates &#123; left = combine(candidates[:i]) right = combine(candidates[i+1:]) for _, lv := range left &#123; for _, rv := range right &#123; new = &amp;TreeNode&#123;v, lv, rv&#125; result = append(result, new) &#125; &#125; &#125; return result&#125; 總結:若有n個節點要組成BST，列出所有能組出的BST，要實作出所有組合就會用上遞回的方式處理，對於遞回來說1~n的節點如果取k作為根節點，1~k-1及k+1~n就會是左右子樹的範圍，剩下就是不斷重覆上述行為直到取的根節點是nil為止便能找出所有組合。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"https://blog.yunchen.tw/tags/DynamicProgramming/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"}]},{"title":"Unique Binary Search Trees","slug":"unique-binary-search-trees","date":"2017-06-01T16:00:00.000Z","updated":"2017-06-01T13:48:30.000Z","comments":true,"path":"2017/06/02/unique-binary-search-trees/","link":"","permalink":"https://blog.yunchen.tw/2017/06/02/unique-binary-search-trees/","excerpt":"","text":"Unique Binary Search TreesGiven n, how many structurally unique BST’s (binary search trees) that store values 1…n? For example:Given n = 3, there are a total of 5 unique BST’s. 123451 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\2 1 2 3 提示 解題應用 DynamicProgramming 規律觀查 Default:123func numTrees(n int) int &#123;&#125; 解答思路:這題一開始可以說是根本毫無頭緒，參考別人的思路似乎還是有點一知半解，所以最初就先試著完全理解題目也許就能透過這樣的方式來發現規律，仔細觀查範例會發現不僅僅單純是二元樹，該二元樹還有經過排序，隨著根節點的值不同，底下的對應組合就很單純(因為沒有重覆值，依大小排就固定那幾種)，也就是說在有排序的情況下我們只在乎因為根節點的值而造成左右子節點分別有多少個就好(比該值小的有多少個，而比該值大的又有多少個)，在知道了兩邊各有多少個之後，如果同意整個二元樹組合總數是根節點的左右子樹分別的組合數相乘，那麼n的所有BST組合是由1~n的每個元素當作根節點的二元樹組合總數相加，其中每個二元樹組合總數又是由左右子樹分別的組合數相乘，最後推出: f(0) = 1 (沒半個節點就只算1種組合) f(n) = f(0)*f(n-1) + f(1)*f(n-2) + … + f(n-2)*f(1) + f(n-1)*f(0) (第一組因為根節點是最小值開始，所以左側節點數為0，右側節點數為n-1…以此類推) 最後再有了公式作為結論之後，剩下就只是將公式實作而已。 程式碼解說:透過公式可以知道要求出n個節點共能組出幾種不同的BST之前，要先求出0~n-1個節點的情況下能組出幾種不同的BST，所以一開始就先以一陣列來儲存0~n各種不同節點數的情況下所有不同BST的組合有多少種，因為已經知道了沒有個節點就只算1種組合，就在index為0的位置放入1，接著才開始以巢狀迴圈找出n個節點的組合總數，最外層的迴圈的index最主要是用來指向陣列中尚待求值的位置1~n，而內層的迴圈則是實作公式f(k)，也就是將每個元素當作根節點的二元樹組合總數累加至陣列index為k之中，最後陣列index為n的值就是我們要的結果 12345678dp := make([]int, n+1)dp[0] = 1for i := 1; i &lt;= n; i++ &#123; for j := 0; j &lt; i; j++ &#123; dp[i] += dp[j] * dp[i-j-1] &#125;&#125;return dp[n] 完整程式碼:12345678910func numTrees(n int) int &#123; dp := make([]int, n+1) dp[0] = 1 for i := 1; i &lt;= n; i++ &#123; for j := 0; j &lt; i; j++ &#123; dp[i] += dp[j] * dp[i-j-1] &#125; &#125; return dp[n]&#125; 總結:若有n個節點要組成BST，找出共能組出幾種不同的BST，在二元樹還有經過排序的情況下就只關注因為根節點的值而造成左右子節點分別有多少個就好，接著如果同意整個二元樹組合總數是根節點的左右子樹分別的組合數相乘，那麼n的所有BST組合是由1~n的每個元素當作根節點的二元樹組合總數相加，其中每個二元樹組合總數又是由左右子樹分別的組合數相乘，最後推出公式: f(n) = f(0)*f(n-1) + f(1)*f(n-2) + … + f(n-2)*f(1) + f(n-1)*f(0)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"https://blog.yunchen.tw/tags/DynamicProgramming/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"}]},{"title":"Binary Tree Inorder Traversal","slug":"binary-tree-inorder-traversal","date":"2017-05-31T16:00:00.000Z","updated":"2017-06-01T01:07:02.000Z","comments":true,"path":"2017/06/01/binary-tree-inorder-traversal/","link":"","permalink":"https://blog.yunchen.tw/2017/06/01/binary-tree-inorder-traversal/","excerpt":"","text":"Binary Tree Inorder TraversalGiven a binary tree, return the inorder traversal of its nodes’ values. For example:Given binary tree [1,null,2,3], 123451 \\ 2 /3 return [1,3,2]. Note: Recursive solution is trivial, could you do it iteratively? 提示 解題應用 Tree 中序遍歷 Stack LinkedList Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func inorderTraversal(root *TreeNode) []int &#123;&#125; 解答思路:樹的遍歷一直都是很基本綀習，一般來說都會直接用遞回的方式來實作，中序遍歷的話大致如下: 123456789101112func inorderTraversal(root *TreeNode) []int &#123; return travel(root, []int&#123;&#125;)&#125;func travel(node *TreeNode, inOrderList []int) []int &#123; if node == nil &#123; return inOrderList &#125; inOrderList = travel(node.Left, inOrderList) inOrderList = append(inOrderList, node.Val) inOrderList = travel(node.Right, inOrderList) return inOrderList&#125; 但是這次還希望你可以嘗試不用遞回的方式來實作，這時就需要用上stack的方式來協助處理，概念上大致就是一開始不斷的遍歷左子節點並放入stack之中，待左側全數放入後才從stack取出最新的節點往右子節點移動一次，再重覆覆上述動作(遍歷左子節點)直到stack中的節點完全取出為止，而前序遍歷與中序遍歷只是差在對節點處理的時機而已，至於後序遍歷則稍為複雜點，處理節點的時機與前序遍歷相同但一開始是不斷的遍歷”右子節點”並放入stack之中，待右側全數放入後才從stack取出最新的節點往”左子節點”移動一次，也就是說後序遍歷與前序遍歷的差別是左右顛倒罷了，不過不管是遞回的方式來實作還是stack的方式來實作本質上其實是一樣的，遞回實作其實底層也是用上stack，何況兩者的時間、空間複雜度都一樣，所以說如果想要有更好的遍歷方式可以參考Morris Traversal，不用遞回也不用stack且空間複雜度只有O(1)。 程式碼解說:如果要用上stack的方式來協助處理，一開始就要先定義stack的結構，總之就是只存樹的節點位置與下一個stack節點位置而已 1234type StackNode struct &#123; Node *TreeNode Next *StackNode&#125; 接下來就是開始處理中序遍歷的部分，一開始先暫存根節點的位置就可以用迴圈來遍歷樹，暫存值的位置或stack最新的節點位置不為空就繼續以迴圈遍歷，如果暫存值的位置不為空就不斷的遍歷左子節點並放入stack之中，待左側全數放入後(暫存值的位置為nil)才從stack取出最新的節點(中序遍歷就是在此時對節點做處理)往右子節點移動一次，最後重覆覆上述動作直到stack中的節點完全取出為止才回傳結果陣列 1234567891011121314151617func inorderTraversal(root *TreeNode) []int &#123; var result []int var top *StackNode tmp := root for tmp != nil || top != nil &#123; if tmp != nil &#123; top = &amp;StackNode&#123;tmp, top&#125; tmp = tmp.Left &#125; else &#123; tmp = top.Node top = top.Next result = append(result, tmp.Val) tmp = tmp.Right &#125; &#125; return result&#125; 完整程式碼:123456789101112131415161718192021type StackNode struct &#123; Node *TreeNode Next *StackNode&#125;func inorderTraversal(root *TreeNode) []int &#123; var result []int var top *StackNode tmp := root for tmp != nil || top != nil &#123; if tmp != nil &#123; top = &amp;StackNode&#123;tmp, top&#125; tmp = tmp.Left &#125; else &#123; tmp = top.Node top = top.Next result = append(result, tmp.Val) tmp = tmp.Right &#125; &#125; return result&#125; 總結:樹的遍歷一直都是很基本綀習，一般來說都會直接用遞回的方式來實作，但如果不用遞回的方式來實作，這時就需要用上stack的方式來協助處理，不過不管是遞回的方式來實作還是stack的方式來實作本質上其實是一樣的，遞回實作其實底層也是用上stack，何況兩者的時間、空間複雜度都一樣，所以說如果想要有更好的遍歷方式可以參考Morris Traversal，不用遞回也不用stack且空間複雜度只有O(1)。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"},{"name":"Stack","slug":"Stack","permalink":"https://blog.yunchen.tw/tags/Stack/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"}]},{"title":"Restore IP Addresses","slug":"restore-IP-addresses","date":"2017-05-26T16:00:00.000Z","updated":"2017-05-28T01:01:14.000Z","comments":true,"path":"2017/05/27/restore-IP-addresses/","link":"","permalink":"https://blog.yunchen.tw/2017/05/27/restore-IP-addresses/","excerpt":"","text":"Restore IP AddressesGiven a string containing only digits, restore it by returning all possible valid IP address combinations. For example:123Given &quot;25525511135&quot;,return [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]. (Order does not matter) 提示 解題應用 Backtracking Recursive String 規律觀查 Default:123func restoreIpAddresses(s string) []string &#123;&#125; 解答思路:要將一串數字轉為合法的IP位址，首先就要先知道合法IP位址的規則是什麼，最主要是要符合三樣條件: IP位址共包含四段，不能多也不能少 每一段的範圍介於0~255之間 超過2位數以上(包含)的第一個數不得為0，例如: 01, 023 在了解規則之後，便能透過遞回的方式排列組合出所有符合條件的結果，而要注意的一點是在遞回的過程中除了帶入現已組出的IP網段與剩餘尚未組合的數字至遞回函數之外，還要記得再多帶一個數字參數用以計算目前已組出的IP網段到第幾段，以利後續判斷時確保網段共包含四段，並且完全使用所給予數字字串的每個數字。 程式碼解說:一開始便將初始值帶入遞回函數之中以組合出所有符合條件的結果，其中第一個參數為現已組出的IP網段字串，第二個則是數字參數用以計算目前已組出的IP網段字串到第幾段，最後才是剩餘尚未組合的數字 123func restoreIpAddresses(s string) []string &#123; return combine(\"\", 1, s)&#125; 接著便開始處理遞回時要做的細節，在組合符合條件的合法IP之前，先判斷目前已組出的IP網段字串已經到第幾段，如果已經到了第5段表示前面的4段已經組合完畢，這時再判斷剩餘尚未組合的數字是否為空，如果是就回傳已組合完畢的合法IP，這邊要注意到回傳的合法IP不包含最後一個字元，因為後續在做組合時，每段後頭都會再放上”.”，所以到了第4段之後就要將”.”給除去，而如果還有剩餘尚未組合的數字，此時則回傳一個空的字串陣列即可 123456789func combine(cur string, count int, s string) []string &#123; if count &gt; 4 &#123; if s == \"\" &#123; return []string&#123;cur[:len(cur)-1]&#125; &#125; return []string&#123;&#125; &#125; ...&#125; 如果IP網段字串尚未組合完畢，繼續從剩餘尚未組合的數字字串一一取值，再以一變數來暫存這一段網段的數字字串，如果目前的網段數字字串長度大於1且第一個字元為”0”的話，此為不合法的IP地址直接結束迴圈，而如果上述綱段符合條件再將字串轉為數字檢查符圍是否介於0~255之間，如果超出符圍一樣也是不合法的IP地址直接結束迴圈，最後如果該網段條件皆符合，將現已組出的IP網段與該網段組合並再最後加上”.”，隨後將已組出的IP網段數+1連同剩餘尚未組合的數字字串再次帶入遞回之中，待回傳完整的IP位址才放入結果陣列之中，在剩餘尚未組合的數字字串完全取完結束迴圈之後，最後便向上回傳整個結果陣列 1234567891011121314151617var subnet stringvar ip []stringvar result []stringfor i, digit := range s &#123; subnet += string(digit) if len(subnet) &gt; 1 &amp;&amp; subnet[0] == 48 &#123; break &#125; subInt, _ := strconv.Atoi(subnet) if subInt &lt;= 255 &#123; ip = combine(cur+subnet+\".\", count+1, s[i+1:]) result = append(result, ip...) &#125; else &#123; break &#125;&#125;return result 完整程式碼:12345678910111213141516171819202122232425262728func restoreIpAddresses(s string) []string &#123; return combine(\"\", 1, s)&#125;func combine(cur string, count int, s string) []string &#123; if count &gt; 4 &#123; if s == \"\" &#123; return []string&#123;cur[:len(cur)-1]&#125; &#125; return []string&#123;&#125; &#125; var subnet string var ip []string var result []string for i, digit := range s &#123; subnet += string(digit) if len(subnet) &gt; 1 &amp;&amp; subnet[0] == 48 &#123; break &#125; subInt, _ := strconv.Atoi(subnet) if subInt &lt;= 255 &#123; ip = combine(cur+subnet+\".\", count+1, s[i+1:]) result = append(result, ip...) &#125; else &#123; break &#125; &#125; return result&#125; 總結:要將一串數字轉為各種不同合法的IP位址陣列的話，只要能了解合法IP位址規則之後，便能透過遞回的方式排列組合出所有符合條件的結果，唯一要注意的是記得再多帶一個數字至遞回參數用以計算目前已組出的IP網段到第幾段，以利後續判斷時確保網段共包含四段，並且完全使用所給予數字字串的每個數字。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"},{"name":"Backtracking","slug":"Backtracking","permalink":"https://blog.yunchen.tw/tags/Backtracking/"}]},{"title":"Reverse Linked List II","slug":"reverse-linked-list-II","date":"2017-05-24T16:00:00.000Z","updated":"2017-05-25T14:03:50.000Z","comments":true,"path":"2017/05/25/reverse-linked-list-II/","link":"","permalink":"https://blog.yunchen.tw/2017/05/25/reverse-linked-list-II/","excerpt":"","text":"Reverse Linked List IIReverse a linked list from position m to n. Do it in-place and in one-pass. For example:123Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. Note: Given m, n satisfy the following condition: 1 ≤ m ≤ n ≤ length of list. 提示 解題應用 LinkedList Pointer Default:12345678910/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func reverseBetween(head *ListNode, m int, n int) *ListNode &#123;&#125; 解答思路:很早之前曾寫過Reverse Linked List，當初只是要將整個LinkedList做翻轉，所以難度不會太高，這次雖然與先前一樣可以只遍歷一遍就完成部分區塊的翻轉，但要考慮的事情就會稍為多一點，好比說整個LinkedList翻轉最後只要將原本最後一個節點的位置做回傳即可(因為翻轉後會變到第一個)，可是部分區塊的翻轉就不一定了，有可能還是原本是節點位置或是LinkedList上的任一點，端看要翻轉的區塊落在哪裡，所以就需要再自行新增一個頭節點，用以回傳在該節點後頭翻轉完新LinkedList的第一個節點位置，最後就是部分區塊的翻轉還要稍為思考要如何與未翻轉的區塊做連結，大致流程如下: 原本的LinkedList: 11 → 3 → 5 → 7 → 9 部分區塊翻轉後的LinkedList(2~4): 11 → 3 ← 5 ← 7 → 9 最後翻轉後的區塊與未翻轉的區塊做連結: 123 ┌ – – – – – ↓1 3 ← 5 ← 7 9∟ – – – – – ↑ 程式碼解說:因為這次要做的是區塊的翻轉，所以除了要自行新增一個頭節點以回傳後頭新LinkedList的第一個節點位置之外，翻轉後的區塊要與未翻轉的區塊做連結時，要多紀錄翻轉區塊m~n的前一個節點的位置(m-1)與在該區塊中翻轉後最後一個節點的位置(也就是該區塊翻轉前第一個節點的位置:m)以利後續做嫁接連結，這邊以preFront與rear分別表示，隨後就是正式開始遍歷原始的LinkedList並一邊計算節點數，用以知曉是否已到達要翻轉的範圍之中，如果遍歷的節點數尚未到達m就繼續向下遍歷(到達m-1與m就先紀錄當下的位置到preFront與rear)，直到範圍落在m~n之中才開始翻轉節點(翻轉細節解說可以參考之前的文章)，最後如果知道下一個節點會超過m~n之間的範圍並且不再需要再翻轉的話，此時就可以將翻轉後的區塊與未翻轉的區塊做嫁接，也就是m-1的位置(preFront)接到n的位置，m的位置(rear)接到n+1的位置，連結完後便可以結束遍歷，直接回傳先前自製頭節點的下一個位置 1234567891011121314151617181920212223242526var flag *ListNodevar rear *ListNodevar preNode *ListNodecount := 1header := &amp;ListNode&#123;0, head&#125;preFront := headerfor head != nil &#123; if count &lt; m &#123; preFront = head &#125; else if count == m &#123; rear = head &#125; flag = head head = head.Next if count &gt;= m &amp;&amp; count &lt;= n &#123; flag.Next = preNode &#125; preNode = flag if count+1 &gt; n &#123; preFront.Next = flag rear.Next = head break &#125; count++&#125;return header.Next 完整程式碼:12345678910111213141516171819202122232425262728func reverseBetween(head *ListNode, m int, n int) *ListNode &#123; var flag *ListNode var rear *ListNode var preNode *ListNode count := 1 header := &amp;ListNode&#123;0, head&#125; preFront := header for head != nil &#123; if count &lt; m &#123; preFront = head &#125; else if count == m &#123; rear = head &#125; flag = head head = head.Next if count &gt;= m &amp;&amp; count &lt;= n &#123; flag.Next = preNode &#125; preNode = flag if count+1 &gt; n &#123; preFront.Next = flag rear.Next = head break &#125; count++ &#125; return header.Next&#125; 總結:可以先參考之前寫的Reverse Linked List，翻轉的做法一樣，只是先前是翻轉整個LinkedList，現在則是再給予範圍要將區塊內的節點全數做翻轉，相較先前翻轉整個LinkedList來說，原本只要將最後一個節點的位置做回傳即可(因為翻轉後會變到第一個)，可是部分區塊的翻轉就不一定了，有可能還是原本是節點位置或是LinkedList上的任一點，端看要翻轉的範圍落在哪裡，所以就需要再自行新增一個頭節點，用以回傳在該節點後頭翻轉完新LinkedList的第一個節點位置，最後就是部分區塊的翻轉後要如何與未翻轉的區塊做連結才是一大重點。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://blog.yunchen.tw/tags/LinkedList/"}]},{"title":"Subsets II","slug":"subsets-II","date":"2017-05-20T16:00:00.000Z","updated":"2017-05-20T15:05:14.000Z","comments":true,"path":"2017/05/21/subsets-II/","link":"","permalink":"https://blog.yunchen.tw/2017/05/21/subsets-II/","excerpt":"","text":"Subsets IIGiven a collection of integers that might contain duplicates, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example:If nums = [1,2,2], a solution is: 12345678[ [2], [1], [1,2,2], [2,2], [1,2], []] 提示 解題應用 Array Array/Slice Backtracking Recursive Default:123func subsetsWithDup(nums []int) [][]int &#123;&#125; 解答思路:建議可以先參考先前Subsets的解法，解說較為詳細，基本上概念完全一樣，只是將先前題的程式碼稍作修改而已，如果之前在元素不重覆的情況下能找出陣列中長度0~n的所有組合，那麼現在在元素重覆的情況下要篩選掉相同的組合就不會太困難。 程式碼解說:這邊只解說與先前題目程式碼的相異之處，一開始最主要是先做排序，排序的主要目地就是要讓相同的元素能鄰近在一起，如此一來在取出的元素時，發現和前一個所取出的元素相同就跳過 1234func subsetsWithDup(nums []int) [][]int &#123; sort.Ints(nums) ...&#125; 接下來就是在取出元素並與現階段已組合好的陣列再次做組合之前，判斷index值是否大於0，並且如果發現目前所取出的元素和前一個所取出的元素相同就跳過，最後就不會在結果之中發現相同的組合 12345678910func recursive(curComb []int, k int, candidates []int) [][]int &#123; ... for i, v := range candidates &#123; if i &gt; 0 &amp;&amp; v == candidates[i-1] &#123; continue &#125; ... &#125; return result&#125; 完整程式碼:123456789101112131415161718192021222324252627282930func subsetsWithDup(nums []int) [][]int &#123; sort.Ints(nums) var tmp [][]int var result [][]int for i := 0; i &lt;= len(nums); i++ &#123; tmp = combine(nums, i) result = append(result, tmp...) &#125; return result&#125;func combine(nums []int, k int) [][]int &#123; return recursive([]int&#123;&#125;, k, nums)&#125;func recursive(curComb []int, k int, candidates []int) [][]int &#123; var tmp [][]int var result [][]int if len(curComb) == k &#123; tmpCurComb := make([]int, len(curComb)) copy(tmpCurComb, curComb) return [][]int&#123;tmpCurComb&#125; &#125; for i, v := range candidates &#123; if i &gt; 0 &amp;&amp; v == candidates[i-1] &#123; continue &#125; tmp = recursive(append(curComb, v), k, candidates[i+1:]) result = append(result, tmp...) &#125; return result&#125; 總結:建議可以先參考先前Subsets的解法，解說較為詳細，基本上概念完全一樣，只是將先前題的程式碼稍作修改而已，現在在元素重覆的情況下要篩選掉相同組合的話，基本上就是先做排序，排序的主要目地就是要讓相同的元素能鄰近在一起，接下來就只要在取出元素以再次做組合時，如果發現現在取出的元素和前一個所取出的元素相同就跳過，如此一來最後就不會出現相同的組合結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"Backtracking","slug":"Backtracking","permalink":"https://blog.yunchen.tw/tags/Backtracking/"}]},{"title":"Gray Code","slug":"gray-code","date":"2017-05-19T16:00:00.000Z","updated":"2017-05-20T09:16:26.000Z","comments":true,"path":"2017/05/20/gray-code/","link":"","permalink":"https://blog.yunchen.tw/2017/05/20/gray-code/","excerpt":"","text":"Gray CodeThe gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. For example:Given n = 2, return [0,1,3,2]. Its gray code sequence is: 123400 - 001 - 111 - 310 - 2 Note: For a given n, a gray code sequence is not uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence according to the above definition. For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that. 提示 解題應用 Backtracking 規律觀查 Default:123func grayCode(n int) []int &#123;&#125; 解答思路:碰到這種排類組合的題目通常第一個直覺會是要用遞回的方式處理，雖然沒有問題不過就根本上來說，因為是要列出所有可能，並以十進位的方式呈現，如果給的二進位長度為n就直接將0~2的n次方-1的所有值放入十進位的結果之中就搞定，然而題目註明了結果只能以特定的排序方式呈現，依序塞的方式不適用特定的排序的話，要用遞回的方式實作出特定的排序方式也相當麻煩，所以倒不如就直接觀查特定排序二進位與十進位的規律變化來試著找出規律，如下(二進位/十進位): 二進位長度: 1 120 01 1 二進位長度: 2 123400 001 111 310 2 二進位長度: 3 12345678000 0001 1011 3010 2110 6111 7101 5100 4 最後可以發現到長度每增加1，就是先將前一個二進位的結果複製一份到後頭並翻轉，最後才再開頭補上0與1各一半，如下(二進位長度: 1→2): 將前一個二進位的結果複製一份到後頭並翻轉 12340 01 11 10 0 最後再開頭補上0與1各一半 123400 001 111 310 2 完全理解特定排序二進位與十進位的規律變化之後，僅憑二進位長度來直接輸出最後的十進位結果陣列就不是什麼大問題了。 程式碼解說:在完全理解特定排序二進位與十進位的規律變化之後，就可以僅憑二進位長度來直接輸出最後的十進位結果陣列，所以在操作上完全只有十進位數，一開始先初始化要放十進位的結果陣列並放入數字0為起始值，接著再初始化暫存值為1以隨著二進位長度n的增加，十進位遞增的值(2的n-1次方)也跟著增加，根據先前的思路所得到的規律，我們每次都將前一份結果倒著取出(翻轉)並加上遞增的暫存值(新的二進位在開頭補上1的意思)再將其放入結果後頭之中，待到達題目所指定的二進位長度，才結束重覆上述動作並回傳整個十進位所呈現的所有結果陣列 12345678910result := []int&#123;0&#125;tmp := 1for n &gt; 0 &#123; for i := len(result) - 1; i &gt;= 0; i-- &#123; result = append(result, result[i]+tmp) &#125; tmp *= 2 n--&#125;return result 完整程式碼:123456789101112func grayCode(n int) []int &#123; result := []int&#123;0&#125; tmp := 1 for n &gt; 0 &#123; for i := len(result) - 1; i &gt;= 0; i-- &#123; result = append(result, result[i]+tmp) &#125; tmp *= 2 n-- &#125; return result&#125; 總結:要找出二進位長度n的所有組合，並以十進位方式來呈現，如果沒有特別規定輸出的排序方式，可以用遞回方式來推出結果或是直接將0~2的n次方-1的所有值放入結果之中，然而如果有要求特定的排序方式，與其要用遞回的方式實作出特定的排序方式，倒不如就直接觀查特定排序二進位與十進位的規律變化，最後就能僅憑二進位長度來直接輸出最後的十進位結果陣列。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Backtracking","slug":"Backtracking","permalink":"https://blog.yunchen.tw/tags/Backtracking/"}]},{"title":"Partition List","slug":"partition-list","date":"2017-05-18T16:00:00.000Z","updated":"2017-05-18T05:32:27.000Z","comments":true,"path":"2017/05/19/partition-list/","link":"","permalink":"https://blog.yunchen.tw/2017/05/19/partition-list/","excerpt":"","text":"Partition ListGiven a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. For example:12Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5. 提示 解題應用 LinkedList Pointer TwoPointers Two LinkedList Default:12345678910/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func partition(head *ListNode, x int) *ListNode &#123;&#125; 解答思路:如果能搞懂題目意思，那麼只需要幾秒的時間就可以想出解法了，最主要就是要將LinkedList分類，如果值比x小就將該節點分一類，如果比x大或相等就分另一類，重點是當節點被歸納至某一類時並不需要做排序，因為只是要相對位置而已，所以被分配到該類時只要接在後頭即可，最後就只要將相對較小的那串LinkedList與相對較較大的另一串LinkedList相接就搞定了。 程式碼解說:要將LinkedList分配為相對較小的一類與相對較大(或相同)的一類就需要兩個新的LinkedList來分別儲存，所以這邊就初始化一個small與一個big的頭節點來分別儲存(頭節點也能確保之後第一個新加入節點與其它節點一樣有操作上的一致性)，並分別用header來暫存之後兩個LinkedList的第一個節點位置(也就是先前剛新增的頭節點)，接下來就是開始遍歷原本題目給的LinkedList，如果節點的值比目標值小就將該節點接到small那串LinkedList的後頭，反之如果值比較大或相等則接到big那串LinkedList的後頭，待遍歷結束後，最後只要將兩個分配好的LinkedList嫁接(small的下一個節點位置接到big頭節點的下一個位置)，接著再將big的下一個位置改為nil就可以回傳新重組完LinkList的位置了(也就是small頭節點的下一個位置) 1234567891011121314151617small := &amp;ListNode&#123;&#125;smallHeader := smallbig := &amp;ListNode&#123;&#125;bigHeader := bigfor head != nil &#123; if head.Val &lt; x &#123; small.Next = head small = head &#125; else &#123; big.Next = head big = head &#125; head = head.Next&#125;small.Next = bigHeader.Nextbig.Next = nilreturn smallHeader.Next 完整程式碼:12345678910111213141516171819func partition(head *ListNode, x int) *ListNode &#123; small := &amp;ListNode&#123;&#125; smallHeader := small big := &amp;ListNode&#123;&#125; bigHeader := big for head != nil &#123; if head.Val &lt; x &#123; small.Next = head small = head &#125; else &#123; big.Next = head big = head &#125; head = head.Next &#125; small.Next = bigHeader.Next big.Next = nil return smallHeader.Next&#125; 總結:若LinkedList需要依某個特定的值來分類，並依該值將LinkedList重新組合(比該值小的就依相對位置放置前頭;比該值大或相等就依相對位置放置後頭)，其做法是如果值比該值小就將該節點分一類(放置於新的LinkedList)，如果比該值大或相等就分另一類，被分配到該類時直接在後頭即可，最後就只要將相對較小的那串LinkedList與相對較較大的另一串LinkedList相接就搞定了。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://blog.yunchen.tw/tags/LinkedList/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"}]},{"title":"Remove Duplicates from Sorted List II","slug":"remove-duplicates-from-sorted-list-II","date":"2017-05-17T16:00:00.000Z","updated":"2017-05-17T11:03:24.000Z","comments":true,"path":"2017/05/18/remove-duplicates-from-sorted-list-II/","link":"","permalink":"https://blog.yunchen.tw/2017/05/18/remove-duplicates-from-sorted-list-II/","excerpt":"","text":"Remove Duplicates from Sorted List IIGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. For example:12Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3. 提示 解題應用 LinkedList Pointer Default:12345678910/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func deleteDuplicates(head *ListNode) *ListNode &#123;&#125; 解答思路:之前有一遍Remove Duplicates from Sorted List，原先是先不管後頭的值是否出現重覆，先將第一個節點保留於原LinkedList之中，當後頭出現重覆的值才做嫁接跳過該節點，不過這次是只要該值重覆就要完全跳過，所以做法上有很大的不同，要遍歷到目前的節點與前一個的節點不同值才考慮是否要保留先前的節點，如果前一個是沒有重覆的節點可以保留下來的話，還要記得將前一個節點做註記，以利接下來如果後續再次出現沒有重覆的節點時，可以拿來與先前未重覆的節點做嫁接。 程式碼解說:因為這次操作會影響到原本LinkedList中第一個節點的存留，所以就需要再最前頭新增一個頭節點來確保第一個節點能與其它節點一樣能有操作上的一致性，而頭節點的預設值為int的32位元極大值，原本的LinkedList則是接在頭節點的後頭，並先將前一個節點與前一個不重覆的節點都指向頭節點接著才開始遍歷原本的LinkedList，一邊遍歷的同時一樣一邊記錄前一個節點的位置，而如思路所寫，這邊的做法是遍歷到與前一個的節點不同值才考慮是否要保留先前的節點，所以當目前節點的值與前一個節點的值不同，除了將暫存值改為目前節點的值與重置重覆的註記之外，在其之前判斷前一個節點是否曾出現重覆值的情況，如果沒有才與之前也沒有重覆、獨特的節點做嫁接，再將前一個節點註記為新的嫁接點，而如果目前節點的值與前一個節點的值相同則將重覆的註記設為true 12345678910111213141516171819isDuplicate := truetmp := math.MaxInt32header := &amp;ListNode&#123;tmp, head&#125;preNode := headerprimeNode := headerfor head != nil &#123; if tmp != head.Val &#123; if !isDuplicate &#123; primeNode.Next = preNode primeNode = preNode &#125; tmp = head.Val isDuplicate = false &#125; else &#123; isDuplicate = true &#125; preNode = head head = head.Next&#125; 因為判斷是要到下一個節點之後才決定前一個節點是否要保留，所以可能最後一個節點就沒有被判斷到，因此還要再次判斷剩下的節點是否重覆，如果是則一樣做嫁接，否則就將要嫁接到的位置指向nil，最後便回傳之前所新增頭節點所連結的下一個位置(也就是新的LinkedList起頭的位置) 123456if !isDuplicate &#123; primeNode.Next = preNode&#125; else &#123; primeNode.Next = nil&#125;return header.Next 完整程式碼:123456789101112131415161718192021222324252627func deleteDuplicates(head *ListNode) *ListNode &#123; isDuplicate := true tmp := math.MaxInt32 header := &amp;ListNode&#123;tmp, head&#125; preNode := header primeNode := header for head != nil &#123; if tmp != head.Val &#123; if !isDuplicate &#123; primeNode.Next = preNode primeNode = preNode &#125; tmp = head.Val isDuplicate = false &#125; else &#123; isDuplicate = true &#125; preNode = head head = head.Next &#125; if !isDuplicate &#123; primeNode.Next = preNode &#125; else &#123; primeNode.Next = nil &#125; return header.Next&#125; 總結:給予LinkedList，如果當中出現有重覆值的節點就要將其完全跳過，其做法是要遍歷到目前的節點與前一個的節點不同值才考慮是否要保留先前的節點，如果前一個是沒有重覆的節點可以保留下來的話，還要記得將前一個節點做註記，以利接下來如果後續再次出現沒有重覆的節點時，可以拿來與先前未重覆的節點做嫁接。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://blog.yunchen.tw/tags/LinkedList/"}]},{"title":"Search in Rotated Sorted Array II","slug":"search-in-rotated-sorted-array-II","date":"2017-05-16T16:00:00.000Z","updated":"2017-05-12T11:13:09.000Z","comments":true,"path":"2017/05/17/search-in-rotated-sorted-array-II/","link":"","permalink":"https://blog.yunchen.tw/2017/05/17/search-in-rotated-sorted-array-II/","excerpt":"","text":"Search in Rotated Sorted Array II Follow up for “Search in Rotated Sorted Array”: What if duplicates are allowed? Would this affect the run-time complexity? How and why? Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Write a function to determine if a given target is in the array. The array may contain duplicates. 提示 解題應用 Array Array/Slice BinarySearch BinarySearch Default:123func search(nums []int, target int) bool &#123;&#125; 解答思路:之前有一遍Search in Rotated Sorted Array，其做法是先找出最小值並以此來推算整個array位移了多少格，在沒有重覆值的情況下可以在時間O(logN)的複雜度下完成，但如果是重覆值存在的情況下最糟會需要O(N)的複雜度，而且這次就沒辦法像之前一樣先找出最小值來先得知位移多少格，因為在極端的情況下如果有大量的重覆值出現，而且重覆的值都剛為最小值的話，就算找到最小值的位置也未必代表是原陣列的第一個位置，因此也無法推出位移了多少格，與其這樣倒不如就想辦法直接找目標值，直接透過二分法比較目標值與開頭值、中間值、結尾值來得出目標值是落在開頭到中間的區塊還是落在中間到結尾的區塊，最後透過這樣不斷的篩選來逐步找出結果，當然這樣的方法也適用於前一題之中(沒有重覆值的情況下)。 程式碼解說:要直接透過二分法的方式來找出目標值的話需要在判斷式上面多下點功夫，一開始頭與尾的初始index值分別為陣列的第一個與與最後一個，並開始以迴圈篩選出目標值存在的範圍直到開頭的index值超過結尾，接著就將開頭與結尾的index相加再除2取得中間的index，如果該中間值為目標值就直接回傳true，到這邊都與基本的二分法一樣，因為接下來要找目標值是落在陣列的前半部還是後半部，這邊先拿中間值與結尾值做比較(要一一分別將目標值與開頭值、中間值、結尾值做比較也行)，如果中間值比結尾值大的話，接著就判斷目標值是不是落在中間值與開頭之間，如果是的話就將結尾的index移動到中間index的前一個(表示落在前半部)，否則則是將開頭的index移動到中間index的下一個(落在後半)，反之如果中間值比結尾值小則情況相反，最後如果是中間值與結尾相等的情況，這個時候就需要將開頭或結尾移動向內移動一格來尋找相異值以繼續做比較，這邊是以移動結尾為主，在迴圈結束之後，還需要再做一次檢查用以對應陣列長度只有0,1,2的情況，而因為陣列長度為1或2的情況下，開頭與結尾的index最後都會相同，因此只要長度大於1就只檢查其中一個即可，如果與目標值相同就回傳true，否則就回傳false 123456789101112131415161718192021222324252627var mid intfront := 0rear := len(nums) - 1for front &lt; rear &#123; mid = (front + rear) / 2 if nums[mid] == target &#123; return true &#125; else if nums[mid] &gt; nums[rear] &#123; if nums[mid] &gt; target &amp;&amp; nums[front] &lt;= target &#123; rear = mid - 1 &#125; else &#123; front = mid + 1 &#125; &#125; else if nums[mid] &lt; nums[rear] &#123; if nums[mid] &lt; target &amp;&amp; nums[rear] &gt;= target &#123; front = mid + 1 &#125; else &#123; rear = mid - 1 &#125; &#125; else &#123; rear-- &#125;&#125;if len(nums) &gt; 0 &amp;&amp; nums[front] == target &#123; return true&#125;return false 完整程式碼:1234567891011121314151617181920212223242526272829func search(nums []int, target int) bool &#123; var mid int front := 0 rear := len(nums) - 1 for front &lt; rear &#123; mid = (front + rear) / 2 if nums[mid] == target &#123; return true &#125; else if nums[mid] &gt; nums[rear] &#123; if nums[mid] &gt; target &amp;&amp; nums[front] &lt;= target &#123; rear = mid - 1 &#125; else &#123; front = mid + 1 &#125; &#125; else if nums[mid] &lt; nums[rear] &#123; if nums[mid] &lt; target &amp;&amp; nums[rear] &gt;= target &#123; front = mid + 1 &#125; else &#123; rear = mid - 1 &#125; &#125; else &#123; rear-- &#125; &#125; if len(nums) &gt; 0 &amp;&amp; nums[front] == target &#123; return true &#125; return false&#125; 總結:陣列中資料有序且包含重覆值的情況下，雖然元素的位置經過位移(旋轉)，但還是能直接透過二分法比較目標值與開頭值、中間值、結尾值來得出目標值是落在開頭到中間的區塊還是落在中間到結尾的區塊，最後透過這樣不斷的篩選來逐步找出結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://blog.yunchen.tw/tags/BinarySearch/"}]},{"title":"Remove Duplicates from Sorted Array II","slug":"remove-duplicates-from-sorted-array-II","date":"2017-05-11T16:00:00.000Z","updated":"2017-05-09T19:00:19.000Z","comments":true,"path":"2017/05/12/remove-duplicates-from-sorted-array-II/","link":"","permalink":"https://blog.yunchen.tw/2017/05/12/remove-duplicates-from-sorted-array-II/","excerpt":"","text":"Remove Duplicates from Sorted Array IIFollow up for “Remove Duplicates”:What if duplicates are allowed at most twice? For example:123Given sorted array nums = [1,1,1,2,2,3],Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn&apos;t matter what you leave beyond the new length. 提示 解題應用 Array Array/Slice TwoPointers 紀錄index位置 Default:123func removeDuplicates(nums []int) int &#123;&#125; 解答思路:建議可以先參考先前Remove Duplicates from Sorted Array的解法，解說較為詳細，基本上概念完全一樣，只是將先前題的程式碼做修改而已，如果能移除重覆的元素，當然最多要保留相同元素就不會太困難。 一開始一樣先遍歷一次對照前後是否相同，如果相同再判斷是否已經重覆超過2個以上，並一邊算出最後陣列的長度多少個(超過2個重覆就只以2個計算)，同時將超過2個以上多餘的相同值賦予標示，例如極大值後做簡易選擇交換便能達成目標。 程式碼解說:這邊只解說與先前題目程式碼的相異之處，因為這次最多能重覆1個值，所以就需要在第一次遍歷的時候稍做修改，這邊以一個boolean值來註記是否已經出現了兩次，如果遍歷到的值與上一個不相同就重設註記為false，如果發現與先前相同但尚未重覆超過2個(註記為false)時，就將註記改為true並將最後陣列長度的計數+1(因為最多能包含一個重覆值)，而如果重覆已經超過2個便將該值賦予極大值做為標示，最後則是與先前一樣將極大值做簡易選擇交換篩至後頭即可 123456789101112131415var twice boolvar count inttmp := math.MaxInt32for i, v := range nums &#123; if tmp != v &#123; tmp = v twice = false count++ &#125; else if !twice &#123; twice = true count++ &#125; else &#123; nums[i] = math.MaxInt32 &#125;&#125; 完整程式碼:1234567891011121314151617181920212223242526272829303132func removeDuplicates(nums []int) int &#123; var twice bool var count int tmp := math.MaxInt32 for i, v := range nums &#123; if tmp != v &#123; tmp = v twice = false count++ &#125; else if !twice &#123; twice = true count++ &#125; else &#123; nums[i] = math.MaxInt32 &#125; &#125; for i, v := range nums &#123; if v == math.MaxInt32 &#123; for j, vv := range nums[i+1:] &#123; if vv != math.MaxInt32 &#123; nums[i] = vv nums[i+j+1] = math.MaxInt32 break &#125; &#125; &#125; if i+1 == count &#123; break &#125; &#125; return count&#125; 總結:建議可以先參考先前Remove Duplicates from Sorted Array的解法，解說較為詳細，基本上概念完全一樣，欲刪除一陣列中超過2個以上多餘的重覆值，可先遍歷一次對照前後是否相同，如果相同再判斷是否已經重覆超過2個以上，並一邊算出最後陣列的長度多少個(超過2個重覆就只以2個計算)，同時將超過2個以上多餘的相同值賦予標示，例如極大值後做簡易選擇交換便能達成目標。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"}]},{"title":"Word Search","slug":"word-search","date":"2017-05-10T16:00:00.000Z","updated":"2017-05-09T14:13:52.000Z","comments":true,"path":"2017/05/11/word-search/","link":"","permalink":"https://blog.yunchen.tw/2017/05/11/word-search/","excerpt":"","text":"Word SearchGiven a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example:Given board = 12345[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]] word = “ABCCED”, -&gt; returns true, word = “SEE”, -&gt; returns true, word = “ABCB”, -&gt; returns false. 提示 解題應用 Array Array/Slice Backtracking Recursive Default:123func exist(board [][]byte, word string) bool &#123;&#125; 解答思路:這題最初是直接遍歷整個二元陣列，每遍歷一個字母時就將該字母放入遞回之中找出所有可能(從該字母的上下左右做延伸)，但是接下來就碰上了問題，因為每個位置字母只能夠組合一次，在做上下左右延伸的話很有可能會把同一個位置的字母重覆組合，因此就需要想個辦法來避免這類情況，一開始是打算限制延伸的方向，好比只能向右或向下這類固定的方向延伸，但是題目很清楚的表示只要是鄰近的格子都能延伸，可能某個單字在表上的結果是個S型，所以限制方向這個辦法就沒辦法使用，最後看到比較好的做法是將組合過的字母暫存起來，並再向下遞回延伸之前將該位置的字母替換成特殊字元，待遞回延伸結束後才將該位置的值改回原字母，如此一來如果重覆組合該位置也會因為組合的結果包含特殊字元而與目標值不同回傳false，最後如果發現該單字能由此二元陣列的元素延伸所組成便回傳true，否則就回傳false。 程式碼解說:如思路所述，因為是先遍歷每個字母當作起頭才做遞回延伸，所以一開始便以兩個迴圈遍歷整個二元陣列，並將每個遍歷字母的位置放入遞回之中，其中第一個參數是已組出的字串，第二、三個參數則用以表示目前遍歷的位置在二元陣列上的第幾橫排第幾直列，第四個與第五個參數則是題目所給予的目標單字與二元陣列，如果該字母起頭做遞回延伸能組出目標單字便直接回傳true，否則就繼續以下一個字母起頭來尋找，待整個二元陣列都遍歷結束如果都還是沒找到符合條件的結果才回傳false 12345678910func exist(board [][]byte, word string) bool &#123; for i := 0; i &lt; len(board); i++ &#123; for j := 0; j &lt; len(board[0]); j++ &#123; if combine(\"\", i, j, word, board) &#123; return true &#125; &#125; &#125; return false&#125; 接下來就是處理遞回延伸的細節，如果上下左右延伸到的位置不在二元陣列的範圍之內便回傳false，取出延伸所在位置的字母做暫存並將該字母與現有字串做組合，組合完畢後便與目標單字做比較，如果完全相同便回傳true，如果與目標單字的前綴不同則直接回傳false，最後就是現有字串與目標單字的前綴暫時相同的情況下要繼續做延伸直到發現完全相的結果，而再次延伸之前先將目前位置的字母替換成特殊字元，接著才往該位置的上下左右做遞回延伸，待遞回延伸結束得到後續結果之後，才將該位置的值改回原字母並向上回傳後續做遞回延伸的結果 12345678910111213141516func combine(cur string, row int, col int, word string, board [][]byte) bool &#123; if row &lt; 0 || col &lt; 0 || row == len(board) || col == len(board[0]) &#123; return false &#125; char := board[row][col] cur = cur + string(char) if cur == word &#123; return true &#125; else if cur != word[:len(cur)] &#123; return false &#125; board[row][col] = '#' result := combine(cur, row-1, col, word, board) || combine(cur, row, col-1, word, board) || combine(cur, row+1, col, word, board) || combine(cur, row, col+1, word, board) board[row][col] = char return result&#125; 完整程式碼:1234567891011121314151617181920212223242526func exist(board [][]byte, word string) bool &#123; for i := 0; i &lt; len(board); i++ &#123; for j := 0; j &lt; len(board[0]); j++ &#123; if combine(\"\", i, j, word, board) &#123; return true &#125; &#125; &#125; return false&#125;func combine(cur string, row int, col int, word string, board [][]byte) bool &#123; if row &lt; 0 || col &lt; 0 || row == len(board) || col == len(board[0]) &#123; return false &#125; char := board[row][col] cur = cur + string(char) if cur == word &#123; return true &#125; else if cur != word[:len(cur)] &#123; return false &#125; board[row][col] = '#' result := combine(cur, row-1, col, word, board) || combine(cur, row, col-1, word, board) || combine(cur, row+1, col, word, board) || combine(cur, row, col+1, word, board) board[row][col] = char return result&#125; 總結:有一二元陣列其中每個元素各代表一個字母，給予一個單字找出該單字是否由能由二元陣列的字母所組成，其中該單字每個元素字母的位置一定要相鄰且不得重覆使用，做法是先直接遍歷整個二元陣列，每遍歷一個字母時就將該字母放入遞回之中找出所有可能(從該字母的上下左右做延伸)，而在延伸的途中將組合過的字母暫存起來，並再向下遞回延伸之前將該位置的字母替換成特殊字元，待遞回延伸結束後才將該位置的值改回原字母，如此一來如果重覆組合該位置也會因為組合的結果包含特殊字元而與目標值不同回傳false，最後如果發現該單字能由此二元陣列的元素延伸所組成便回傳true，否則就回傳false。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"Backtracking","slug":"Backtracking","permalink":"https://blog.yunchen.tw/tags/Backtracking/"}]},{"title":"Subsets","slug":"subsets","date":"2017-05-09T16:00:00.000Z","updated":"2017-05-04T15:42:04.000Z","comments":true,"path":"2017/05/10/subsets/","link":"","permalink":"https://blog.yunchen.tw/2017/05/10/subsets/","excerpt":"","text":"SubsetsGiven a set of distinct integers, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example:If nums = [1,2,3], a solution is: 12345678910[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 提示 解題應用 Array Array/Slice Backtracking Recursive Default:123func subsets(nums []int) [][]int &#123;&#125; 解答思路:建議可以先參考先前Combinations的解法，解說較為詳細，基本上概念完全一樣，只是將先前題的程式碼重覆利用而已，如果之前要找陣列中長度為k的所有組合，那麼現在要找陣列中長度為0~n的所有組合當然就只需要重覆呼叫之前的程式碼以此得到所有長度的所有組合。 程式碼解說:這邊只解說與先前題目程式碼的相異之處，其實就只是將先前題的程式碼重覆利用而已，因為要列出所有長度的所有組合，所以就用迴圈從0到n開始將長度帶入先前程式碼的function之中，這邊要注意的是先前combine的function第一個參數是n，進而初始化一個包含1~n的陣列，這次就直接帶入原本題目給的陣列即可，最後將每次得到的回傳放入結果之中，待找出所有長度的所有組合就是我們要的結果 123456789func subsets(nums []int) [][]int &#123; var tmp [][]int var result [][]int for i := 0; i &lt;= len(nums); i++ &#123; tmp = combine(nums, i) result = append(result, tmp...) &#125; return result&#125; 完整程式碼:1234567891011121314151617181920212223242526func subsets(nums []int) [][]int &#123; var tmp [][]int var result [][]int for i := 0; i &lt;= len(nums); i++ &#123; tmp = combine(nums, i) result = append(result, tmp...) &#125; return result&#125;func combine(nums []int, k int) [][]int &#123; return recursive([]int&#123;&#125;, k, nums)&#125;func recursive(curComb []int, k int, candidates []int) [][]int &#123; var tmp [][]int var result [][]int if len(curComb) == k &#123; tmpCurComb := make([]int, len(curComb)) copy(tmpCurComb, curComb) return [][]int&#123;tmpCurComb&#125; &#125; for i, v := range candidates &#123; tmp = recursive(append(curComb, v), k, candidates[i+1:]) result = append(result, tmp...) &#125; return result&#125; 總結:建議可以先參考先前Unique Paths的解法，解說較為詳細，基本上概念完全一樣，只是將先前題的程式碼重覆利用而已，如果之前要找陣列中長度為k的所有組合，那麼現在要找陣列中長度為0~n的所有組合當然就只需要重覆呼叫之前的程式碼以此得到所有長度的所有組合。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"BitManipulation","slug":"BitManipulation","permalink":"https://blog.yunchen.tw/tags/BitManipulation/"},{"name":"Backtracking","slug":"Backtracking","permalink":"https://blog.yunchen.tw/tags/Backtracking/"}]},{"title":"Combinations","slug":"combinations","date":"2017-05-08T16:00:00.000Z","updated":"2017-05-04T12:43:44.000Z","comments":true,"path":"2017/05/09/combinations/","link":"","permalink":"https://blog.yunchen.tw/2017/05/09/combinations/","excerpt":"","text":"CombinationsGiven two integers n and k, return all possible combinations of k numbers out of 1 … n. For example:If n = 4 and k = 2, a solution is: 12345678[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 提示 解題應用 Backtracking Recursive Default:123func combine(n int, k int) [][]int &#123;&#125; 解答思路:先前也有不少這種類似的題目，最主要是要用遞回的方式將現有的組合陣列與尚未被組合的陣列再次做組合，而且仔細觀查會發現為了要避免重覆的情況，每一次從尚未被組合的陣列取新的元素來跟現有陣列再次做組合時，該元素一定比現有陣列中的所有元素來的大，現有陣列的長度到達指定的長度才向上回傳存至結果之中，最後就是不斷透過遞回直到找出所有可能為止。 程式碼解說:因為是要將1~n做排序組合，所以一開始就需要先準備儲有1~n的陣列，接著才將其帶入遞回中，其中第一個參數為現有的組合陣列，第二個則是要到達指定的長度數，最後一個則是尚未被組合的陣列 1234567func combine(n int, k int) [][]int &#123; candidates := make([]int, n) for i := 1; i &lt;= n; i++ &#123; candidates[i-1] = i &#125; return recursive([]int&#123;&#125;, k, candidates)&#125; 接下來就是處理遞回之中的組合，如果現有陣列的長度到達指定的長度就向上回傳，注意在golang中不能直接回傳[][]int{curComb}，而是要再複製到空的陣列之中才做回傳，原因和slice特性有關，詳情可以到這邊看Go Slices，至於如果現有的陣列長度尚未到達直定長度，就從尚未被組合的陣列取新的元素來跟現有陣列做組合並再次放入遞回之中，而新的待組合陣列則是帶入自身之後的所有元素以避免之後的組合出現重覆，最後將每次得到的回傳放入結果之中，待找出所有組合最後才向上回傳現有的結果組合 1234567891011121314func recursive(curComb []int, k int, candidates []int) [][]int &#123; var tmp [][]int var result [][]int if len(curComb) == k &#123; tmpCurComb := make([]int, len(curComb)) copy(tmpCurComb, curComb) return [][]int&#123;tmpCurComb&#125; &#125; for i, v := range candidates &#123; tmp = recursive(append(curComb, v), k, candidates[i+1:]) result = append(result, tmp...) &#125; return result&#125; 完整程式碼:123456789101112131415161718192021func combine(n int, k int) [][]int &#123; candidates := make([]int, n) for i := 1; i &lt;= n; i++ &#123; candidates[i-1] = i &#125; return recursive([]int&#123;&#125;, k, candidates)&#125;func recursive(curComb []int, k int, candidates []int) [][]int &#123; var tmp [][]int var result [][]int if len(curComb) == k &#123; tmpCurComb := make([]int, len(curComb)) copy(tmpCurComb, curComb) return [][]int&#123;tmpCurComb&#125; &#125; for i, v := range candidates &#123; tmp = recursive(append(curComb, v), k, candidates[i+1:]) result = append(result, tmp...) &#125; return result&#125; 總結:數序1~n要找出長度為k的所有組合，最主要是要用遞回的方式將現有的組合陣列與尚未被組合的陣列再次做組合，為了要避免重覆的情況，每一次從尚未被組合的陣列取新的元素來跟現有陣列再次做組合時，該元素一定要比現有陣列中的所有元素來的大，最後就是不斷透過遞回直到找出所有符合長度陣列的組合為止。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Backtracking","slug":"Backtracking","permalink":"https://blog.yunchen.tw/tags/Backtracking/"}]},{"title":"Sort Colors","slug":"sort-colors","date":"2017-05-07T16:00:00.000Z","updated":"2017-05-02T06:07:49.000Z","comments":true,"path":"2017/05/08/sort-colors/","link":"","permalink":"https://blog.yunchen.tw/2017/05/08/sort-colors/","excerpt":"","text":"Sort ColorsGiven an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library’s sort function for this problem. Follow up: A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s. Could you come up with an one-pass algorithm using only constant space? 提示 解題應用 Array Array/Slice TwoPointers 紀錄index位置 Default:123func sortColors(nums []int) &#123;&#125; 解答思路:一開始看到直接用氣泡排序就完成了，然而用排序的方式來解此題會浪費不少時間，因為陣列中的所有元素只由三個不同的數字所組成，再加上又知道是哪三個數字的前提之下就應該要有更好的方式來善用這些已知道的資訊，在Follow up中有提到遍歷兩次就可以解決，第一次是紀鍵三個不同的數字0,1,2分別有多少個(是我會用hashmap來儲存)，第二次就是根據次數由三個數字小至大直接取代掉整個陣列，然而其實有更佳的方法就是只遍歷一次的情況下便可以搞定，概念上其實不會差太多，就是想辦法一邊遍歷取代一邊紀錄次數(更準確的說法是紀錄位置)，先試想有三個變數來紀錄0,1,2在排序後陣列上最後一個值的位置(一開始index都為0)，當在遍歷尚未排序的陣列時，如果出現0除了要將0紀錄的位置向後推，連同1、2也要向後推(因為0在最前面)，出現1除了要將1紀錄的位置向後推，連2也要向後推，而出現2就只有2紀錄的位置向後推就好，因為2後頭沒有其它數字，因此不會影響其它數字的位置，待遍歷結束後三個變數就已經分別代表0,1,2在排序後陣列上最後一個值的位置，最後再想一想如果一邊在將位置後推的同時一邊取代一路上的值，先是2後推的同時將一路上的值轉為2到陣列底，接著是1後推的同時將一路上的值轉為1到最後一個值的位置(將部分才剛取代為2的值取代為1)，再來才是0後推的同時將一路上的值轉為0到最後一個值的位置(將部分才剛取代為1的值取代為0)，如此一來三個變數所紀錄0,1,2的位置在分別到達最後一個值位置的同時也排序完整個陣列了。 程式碼解說:因為要紀錄下0,1,2在排序後陣列上最後一個值的位置，所以就先初始化三個變數來分別代表目前最後一個值的位置，接著就是開始遍歷尚未排序的陣列，如果取出的值為0就將0,1,2紀錄的位置向後推，同時先由2開始取代一路上的值(取代最後一個值所在的該位置)，接著才換1取代，再來才是換0取代，而取出的值為1則是將1,2的位置向後推，也是先由2開始取代接著才輪到1，最後如果取出的值為2就只將2的位置向後推，並只以2取代一路上的值 123456789101112131415161718192021zero := 0one := 0two := 0for _, v := range nums &#123; if v == 0 &#123; nums[two] = 2 nums[one] = 1 nums[zero] = 0 two++ one++ zero++ &#125; else if v == 1 &#123; nums[two] = 2 nums[one] = 1 two++ one++ &#125; else &#123; nums[two] = 2 two++ &#125;&#125; 完整程式碼:1234567891011121314151617181920212223func sortColors(nums []int) &#123; zero := 0 one := 0 two := 0 for _, v := range nums &#123; if v == 0 &#123; nums[two] = 2 nums[one] = 1 nums[zero] = 0 two++ one++ zero++ &#125; else if v == 1 &#123; nums[two] = 2 nums[one] = 1 two++ one++ &#125; else &#123; nums[two] = 2 two++ &#125; &#125;&#125; 總結:若一陣列要做排序，在僅由少數元素組成的情況下且知道少數元素的值分別為多少，最快只要一次遍歷就能排序完所有的元素，要想辦法在一邊遍歷取代的同時一邊紀錄各元素在排序後陣列上最後一個值的位置，以0,1,2組成的情況下來說，當在遍歷尚未排序的陣列時，如果出現0除了要將0紀錄的位置向後推，連同1、2也要向後推，出現1除了要將1紀錄的位置向後推，連2也要向後推，而出現2就只有2紀錄的位置向後推就好，因為2後頭沒有其它數字，因此不會影響其它數字的位置，最後在先前2後推的同時將一路上的值轉為2到陣列底，接著是1後推的同時將一路上的值轉為1到最後一個值的位置，再來才是0後推的同時將一路上的值轉為0到最後一個值的位置，如此一來三個變數所紀錄0,1,2的位置在分別到達最後一個值位置的同時也排序完整個陣列了。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"},{"name":"Sort","slug":"Sort","permalink":"https://blog.yunchen.tw/tags/Sort/"}]},{"title":"Search a 2D Matrix","slug":"search-a-2D-matrix","date":"2017-05-06T16:00:00.000Z","updated":"2017-05-01T13:17:41.000Z","comments":true,"path":"2017/05/07/search-a-2D-matrix/","link":"","permalink":"https://blog.yunchen.tw/2017/05/07/search-a-2D-matrix/","excerpt":"","text":"Search a 2D MatrixWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. For example:Consider the following matrix: 12345[ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]] Given target = 3, return true. 提示 解題應用 Array Array/Slice BinarySearch BinarySearch Default:123func searchMatrix(matrix [][]int, target int) bool &#123;&#125; 解答思路:要從一個由小至大排序好的mxn二元陣列(左上到右下)之中找出目標值，這邊共用了兩次二分法來找出目標值，第一次先用二分法從最左方直列[0~m-1,0]的所有元素中找出該值落在第幾橫排，如果剛好目標值在第一次就能找出來就回傳true，接著才再用第二次二分法找出目標值落在該橫排第幾個，一樣找出目標值就回傳true，而如果最後都沒有找到目標值才回傳false。 程式碼解說:因為可能會有空陣列的情況，像是[]與\b[[]]都要篩選掉才能夠開始來尋找目標值 123if len(matrix) == 0 || len(matrix[0]) == 0 &#123; return false&#125; 一開始先以找出目標值是落在第幾橫排為主，所以就先用二分法從最左方直列[0~m-1,0]的所有元素中找起，如果剛好目標值在最左方直列中就回傳true，待找出最接近目標值(橫排的第一個值)的位置後，因為該值有可能比目標值大或比目標值小，所以先判斷如果該值比目標值大表示目標值落在前一個橫排，而比較小的話則目標值就是在該值所在的橫排上(至於如果相等的話先前就早已回傳true了) 12345678910111213141516171819var x intvar mid intfront := 0rear := len(matrix) - 1for front &lt;= rear &#123; mid = (front + rear) / 2 if target &gt; matrix[mid][0] &#123; front = mid + 1 &#125; else if target &lt; matrix[mid][0] &#123; rear = mid - 1 &#125; else &#123; return true &#125;&#125;if mid &gt; 0 &amp;&amp; target &lt; matrix[mid][0] &#123; x = mid - 1&#125; else &#123; x = mid&#125; 在知道目標值是落在哪一橫排之後，最後就是再對該橫排用二分法找出目標值，如果該橫排上找出與目標值相等的元素就直接回傳true，而如果不存在於該橫排上，肯定也不存在於其它位置便回傳false 12345678910111213front = 0rear = len(matrix[0]) - 1for front &lt;= rear &#123; mid = (front + rear) / 2 if target &gt; matrix[x][mid] &#123; front = mid + 1 &#125; else if target &lt; matrix[x][mid] &#123; rear = mid - 1 &#125; else &#123; return true &#125;&#125;return false 完整程式碼:12345678910111213141516171819202122232425262728293031323334353637func searchMatrix(matrix [][]int, target int) bool &#123; if len(matrix) == 0 || len(matrix[0]) == 0 &#123; return false &#125; var x int var mid int front := 0 rear := len(matrix) - 1 for front &lt;= rear &#123; mid = (front + rear) / 2 if target &gt; matrix[mid][0] &#123; front = mid + 1 &#125; else if target &lt; matrix[mid][0] &#123; rear = mid - 1 &#125; else &#123; return true &#125; &#125; if mid &gt; 0 &amp;&amp; target &lt; matrix[mid][0] &#123; x = mid - 1 &#125; else &#123; x = mid &#125; front = 0 rear = len(matrix[0]) - 1 for front &lt;= rear &#123; mid = (front + rear) / 2 if target &gt; matrix[x][mid] &#123; front = mid + 1 &#125; else if target &lt; matrix[x][mid] &#123; rear = mid - 1 &#125; else &#123; return true &#125; &#125; return false&#125; 總結:要從一個由小至大排序好的mxn二元陣列(左上到右下)之中找出目標值，要共用了兩次二分法來找出目標值，第一次先用二分法從最左方直列[0~m-1,0]的所有元素中找出該值落在第幾橫排，如果剛好目標值在第一次就能找出來就回傳true，接著才再用第二次二分法找出目標值落在該橫排第幾個，一樣找出目標值就回傳true，而如果最後都沒有找到目標值才回傳false。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://blog.yunchen.tw/tags/BinarySearch/"}]},{"title":"Set Matrix Zeroes","slug":"set-matrix-zeroes","date":"2017-05-05T16:00:00.000Z","updated":"2017-05-01T11:46:27.000Z","comments":true,"path":"2017/05/06/set-matrix-zeroes/","link":"","permalink":"https://blog.yunchen.tw/2017/05/06/set-matrix-zeroes/","excerpt":"","text":"Set Matrix ZeroesGiven a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. Follow up: Did you use extra space? A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? 提示 解題應用 Array Array/Slice Default:123func setZeroes(matrix [][]int) &#123;&#125; 解答思路:正如Follow up所述，一開始就想直接用mxn與資料相同的陣列大小來各別儲存所有0的位置，再好一點的作法就是只用m+n格陣列，如果[x,y]的位置為0就在m[x]與n[y]註記該行與列要全為0，至於最好的做法就是不再另外用空間來儲存0的位置，而是直接在資料陣列上註記，也就是說如果[x,y]的位置為0就將[x,0]與[0,y]原本的值取代為0(順便紀鍵最上方的橫排[0~m-1,0]與最左方的直列[0,0~n-1]原始值是否有任一個為值為0)，接著只遍歷[1,1] ~ [m-1,n-1]，如果某位置[x,y]發現[x,0]或[0,y]任一位置的值為0，就將[x,y]原本的值取代為0，最後如果[0~m-1,0]與[0,0~n-1]先前所註記該橫排或直列存在0的值，就將該橫排或直列的所有值取代為0。 程式碼解說:如先前思路所述，為了不使用任何額外空間，要直接在資料陣列上註記哪行與哪列要全為0，所以一開始便遍歷整個二元陣列，如果[x,y]的位置為0就將[x,0]與[0,y]原本的值取代為0，稍後便能藉由這些0的位置來知道要將哪行或哪列上的所有值取代為0，而在確定該位置的值為0同時如果是x為0就註記最後要將最上方橫排的全部元素取代為0，如果是y為0就註記最後要將最左方直列的全部元素取代為0 12345678910111213141516var row boolvar col boolfor i := 0; i &lt; len(matrix); i++ &#123; for j := 0; j &lt; len(matrix[0]); j++ &#123; if matrix[i][j] == 0 &#123; if i == 0 &#123; row = true &#125; if j == 0 &#123; col = true &#125; matrix[i][0] = 0 matrix[0][j] = 0 &#125; &#125;&#125; 在註記完哪行與哪列要全為0後，接著從[1,1] ~ [m-1,n-1]，如果某位置[x,y]發現[x,0]或[0,y]任一位置的值為0，就將[x,y]原本的值取代為0 1234567for i := 1; i &lt; len(matrix); i++ &#123; for j := 1; j &lt; len(matrix[0]); j++ &#123; if matrix[i][0] == 0 || matrix[0][j] == 0 &#123; matrix[i][j] = 0 &#125; &#125;&#125; 最後只剩最上方的橫排[0~m-1,0]與最左方的直列[0,0~n-1]還未判斷，藉由先前所註記該橫排或直列存在0的值，就將該橫排或直列的所有值取代為0 12345678910if col &#123; for i := 0; i &lt; len(matrix); i++ &#123; matrix[i][0] = 0 &#125;&#125;if row &#123; for j := 0; j &lt; len(matrix[0]); j++ &#123; matrix[0][j] = 0 &#125;&#125; 完整程式碼:1234567891011121314151617181920212223242526272829303132333435func setZeroes(matrix [][]int) &#123; var row bool var col bool for i := 0; i &lt; len(matrix); i++ &#123; for j := 0; j &lt; len(matrix[0]); j++ &#123; if matrix[i][j] == 0 &#123; if i == 0 &#123; row = true &#125; if j == 0 &#123; col = true &#125; matrix[i][0] = 0 matrix[0][j] = 0 &#125; &#125; &#125; for i := 1; i &lt; len(matrix); i++ &#123; for j := 1; j &lt; len(matrix[0]); j++ &#123; if matrix[i][0] == 0 || matrix[0][j] == 0 &#123; matrix[i][j] = 0 &#125; &#125; &#125; if col &#123; for i := 0; i &lt; len(matrix); i++ &#123; matrix[i][0] = 0 &#125; &#125; if row &#123; for j := 0; j &lt; len(matrix[0]); j++ &#123; matrix[0][j] = 0 &#125; &#125;&#125; 總結:在mxn的二元陣列中，若任一值為0則將該值位置上行與列的所有元素取代為0，最好的做法就是不再另外用空間來儲存0的位置，而是直接在資料陣列上註記，也就是說如果[x,y]的位置為0就將[x,0]與[0,y]原本的值取代為0(順便紀鍵最上方的橫排[0~m-1,0]與最左方的直列[0,0~n-1]原始值是否有任一個為值為0)，接著只遍歷[1,1] ~ [m-1,n-1]，如果某位置[x,y]發現[x,0]或[0,y]任一位置的值為0，就將[x,y]原本的值取代為0，最後如果[0~m-1,0]與[0,0~n-1]先前所註記該橫排或直列存在0的值，就將該橫排或直列的所有值取代為0。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"}]},{"title":"Sqrt(x)","slug":"sqrt","date":"2017-05-04T16:00:00.000Z","updated":"2017-04-26T16:09:13.000Z","comments":true,"path":"2017/05/05/sqrt/","link":"","permalink":"https://blog.yunchen.tw/2017/05/05/sqrt/","excerpt":"","text":"Sqrt(x)Implement int sqrt(int x). Compute and return the square root of x. 提示 解題應用 Math 規律觀查 Default:123func mySqrt(x int) int &#123;&#125; 解答思路:這題姑且只用最簡單的方式去解決，當然有人用牛頓法的方法來找出結果，不過一開始我就是只用最簡單的方式去處理問題，至於用數學的方式來看待題目就等到回頭復習時再來修正了，畢竟我沒把握能夠當場想到用牛頓法來處理類似的問題，如果要找出一數值開根號後的結果(不取小數點)，最簡單的方式就是用迴圈從1的平方開始一直到平方值超過該數值，此時前一個未超過該數值的平方值其遞增數就會是我們要找的結果。 程式碼解說:很簡單的利用迴圈從1的平方開始一直到平方值超過該數值，此時如果遞增數的平方值未超過該數值，就用一變數暫存當下的遞增數，待迴圈結束後便直接回傳先前的暫存值 12345var tmp intfor i := 1; i*i &lt;= x; i++ &#123; tmp = i&#125;return tmp 完整程式碼:1234567func mySqrt(x int) int &#123; var tmp int for i := 1; i*i &lt;= x; i++ &#123; tmp = i &#125; return tmp&#125; 總結:如果要找出一數值開根號後的結果(不取小數點)，最簡單的方式就是用迴圈從1的平方開始一直到平方值超過該數值，此時前一個未超過該數值的平方值其遞增數就會是我們要找的結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://blog.yunchen.tw/tags/BinarySearch/"}]},{"title":"Simplify Path","slug":"simplify-path","date":"2017-05-03T16:00:00.000Z","updated":"2017-04-26T14:28:43.000Z","comments":true,"path":"2017/05/04/simplify-path/","link":"","permalink":"https://blog.yunchen.tw/2017/05/04/simplify-path/","excerpt":"","text":"Simplify PathGiven an absolute path for a file (Unix-style), simplify it. For example:12path = &quot;/home/&quot;, =&gt; &quot;/home&quot;path = &quot;/a/./b/../../c/&quot;, =&gt; &quot;/c&quot; 提示 解題應用 Stack LinkedList String 規律觀查 Default:123func simplifyPath(path string) string &#123;&#125; 解答思路:一開始是將整個路徑以”/“來分割字串，之後就是一一取出陣列中分割完得到的資料夾名稱，並分別對”.”、”..”及其它狀況做處理，最初並沒有想到要用stack來實作儲存，而是直接使用slice的伸縮來取代，如果碰上資料夾名稱則append至slice之中，而如果碰上”..”的情況就直接移除slice的最後一個元素，最後仍可以通過測資，不過用stack的好處就是能使整個邏輯更加好懂，資料夾名稱就新增一個頭節點並將舊的推向後頭，而”..”則直接拿掉頭節點(頭節點移動到下一個)，但不論何種方式碰上”.”就是直接跳過取下一個資料夾名稱，待全數放入slice/stack並處理完後，最後再一口氣遍歷組成新的路徑字串回傳即可。 程式碼解說:因為stack我是以節點的方式實作，故一開始就要先初始化節點的結構(包含要儲存的資料夾名稱字串與下一個節點的位置)，接著就是將整個路徑以”/“來分割字串，之後一一取出陣列中分割完得到的資料夾名稱，如果碰上”.”或得到的資料夾名稱為空(例://///)就是直接跳過，而如果是”..”且頭節點不為空，則直接拿掉頭節點(頭節點移動到下一個)，至於一般的資料夾名稱就新增一個頭節點並將舊的推向後頭 123456789101112131415161718type stackNode struct &#123; S string Next *stackNode&#125;var result stringvar top *stackNodefolders := strings.Split(path, \"/\")for _, v := range folders &#123; if v == \".\" || v == \"\" &#123; continue &#125; else if v == \"..\" &#123; if top != nil &#123; top = top.Next &#125; &#125; else &#123; top = &amp;stackNode&#123;v, top&#125; &#125;&#125; 待全數放入stack並處理完後，如果頭節點不為空就遍歷stack節點組回路徑字串(注意遍歷stack取值順序是從路徑的後頭開始)，如果最後的路徑字串長度為0(例:///// 先前因資料夾名稱為空都被跳過)就回傳”/“根目錄，否則就直接回傳路徑字串的結果 12345678for top != nil &#123; result = \"/\" + top.S + result top = top.Next&#125;if len(result) == 0 &#123; return \"/\"&#125;return result 完整程式碼:12345678910111213141516171819202122232425262728type stackNode struct &#123; S string Next *stackNode&#125;func simplifyPath(path string) string &#123; var result string var top *stackNode folders := strings.Split(path, \"/\") for _, v := range folders &#123; if v == \".\" || v == \"\" &#123; continue &#125; else if v == \"..\" &#123; if top != nil &#123; top = top.Next &#125; &#125; else &#123; top = &amp;stackNode&#123;v, top&#125; &#125; &#125; for top != nil &#123; result = \"/\" + top.S + result top = top.Next &#125; if len(result) == 0 &#123; return \"/\" &#125; return result&#125; 總結:若給一個Unix路徑字串包含”.”與”..”，要將其做簡化並回傳新的字串，一開始先將整個路徑以”/“來分割字串，之後就是一一取出陣列中分割完得到的資料夾名稱，分別對”.”、”..”及其它狀況做處理，並以stack來儲存新的路徑資料，如果碰上”.”就是直接跳過取下一個資料夾名稱，而”..”則直接拿掉頭節點(頭節點移動到下一個)，至於一般的資料夾名稱就新增一個頭節點並將舊的推向後頭，待全數放入stack並處理完後，最後再一口氣遍歷組成新的路徑字串回傳即可。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://blog.yunchen.tw/tags/Stack/"}]},{"title":"Minimum Path Sum","slug":"minimum-path-sum","date":"2017-05-02T16:00:00.000Z","updated":"2017-05-02T04:23:43.000Z","comments":true,"path":"2017/05/03/minimum-path-sum/","link":"","permalink":"https://blog.yunchen.tw/2017/05/03/minimum-path-sum/","excerpt":"","text":"Minimum Path SumGiven a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. 提示 解題應用 Array Array/Slice DynamicProgramming 規律觀查 Default:123func minPathSum(grid [][]int) int &#123;&#125; 解答思路:建議可以先參考先前Unique Paths的解法，大致上概念類似，只是這次所有的格子都有了加權數，也就是說明明同樣是一格但實際長度卻不一樣的意思，要找出最短路徑的話從原本到該格的走法做總合改為選擇到該格最短路徑的距離才做累加，一開始走到最左側或最下側因為只有一種可能，所以加權數的路徑便分別一路累加到底(走法只有一種但路徑是要算長度所以要總合先前走過的長度)，接著從起點鄰近的格子慢慢推會發現到該格最短的距離都是比較左側格子已累加的距離與上側格子已累加的距離，如果哪側比較短就只將那一側的距離與該格的加權數做累加，最後不斷推倒到最右下角的格子就是我們要的結果，再理解了如此的規律後便可以很容易的寫出要的程式碼。 程式碼解說:因為這次二元陣列要儲存的是加權數(路徑長度)到該格的累加，所以就不再初始化一個新的二元陣列來分開儲存，直接拿原本每格儲存的加權值來做累加，一開始先取出二元陣列的大小有幾橫排m與幾直列n以方便我們做遍歷，接著因為從開始走到最左側或最下側因為只有一種可能，所以加權數的路徑便分別一路累加到底 12345678m := len(grid)n := len(grid[0])for i := 1; i &lt; m; i++ &#123; grid[i][0] += grid[i-1][0]&#125;for j := 1; j &lt; n; j++ &#123; grid[0][j] += grid[0][j-1]&#125; 最後則是根據先前所發現的規律，到該格最短的距離都是比較左側格子已累加的距離與上側格子已累加的距離，如果哪側比較短就只將那一側的距離與該格的加權數做累加，待最右下角格子的最短距離算出來後就是我們要的結果 12345678910for i := 1; i &lt; m; i++ &#123; for j := 1; j &lt; n; j++ &#123; if grid[i-1][j] &lt; grid[i][j-1] &#123; grid[i][j] += grid[i-1][j] &#125; else &#123; grid[i][j] += grid[i][j-1] &#125; &#125;&#125;return grid[m-1][n-1] 完整程式碼:1234567891011121314151617181920func minPathSum(grid [][]int) int &#123; m := len(grid) n := len(grid[0]) for i := 1; i &lt; m; i++ &#123; grid[i][0] += grid[i-1][0] &#125; for j := 1; j &lt; n; j++ &#123; grid[0][j] += grid[0][j-1] &#125; for i := 1; i &lt; m; i++ &#123; for j := 1; j &lt; n; j++ &#123; if grid[i-1][j] &lt; grid[i][j-1] &#123; grid[i][j] += grid[i-1][j] &#125; else &#123; grid[i][j] += grid[i][j-1] &#125; &#125; &#125; return grid[m-1][n-1]&#125; 總結:建議可以先參考先前Unique Paths的解法，大致上概念類似，只是這次所有的格子都有了加權數，要找出最短路徑的話從原本到該格的走法做總合改為選擇到該格最短路徑的距離才做累加，一開始走到最左側或最下側因為只有一種可能，所以加權數的路徑便分別一路累加到底，接著從起點鄰近的格子慢慢推會發現到該格最短的距離都是比較到左側格子已累加的距離與上側格子已累加的距離，比較短的那側才與該格的加權數做累加，最後不斷推倒到最右下角的格子就是我們要的結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"https://blog.yunchen.tw/tags/DynamicProgramming/"}]},{"title":"Unique Paths II","slug":"unique-paths-II","date":"2017-05-01T16:00:00.000Z","updated":"2017-05-02T04:23:32.000Z","comments":true,"path":"2017/05/02/unique-paths-II/","link":"","permalink":"https://blog.yunchen.tw/2017/05/02/unique-paths-II/","excerpt":"","text":"Unique Paths IIFollow up for “Unique Paths”: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. ###For example: There is one obstacle in the middle of a 3x3 grid as illustrated below. 12345[ [0,0,0], [0,1,0], [0,0,0]] The total number of unique paths is 2. Note: m and n will be at most 100. 提示 解題應用 Array Array/Slice DynamicProgramming 規律觀查 Default:123func uniquePathsWithObstacles(obstacleGrid [][]int) int &#123;&#125; 解答思路:建議可以先參考先前Unique Paths的解法，解說較為詳細，基本上概念完全一樣，只是將先前題的程式碼做修改而已，如果能找出mxn走到最右下角的所有組合數，當然要再篩選掉不能走的路線就不會太困難。 一開始也是初始化一相同大小的二元陣列用來紀錄mxn走到每格的所有組合數，接著從起點走到最左側或最下側雖然只有一種可能，但如果中間出現障礙物的話就沒辦法走到後頭初始值就要為0(障礙物到最左側或最下側之間的所有格子走法皆為0)，而再從起點鄰近的格子慢慢推算該格的走法是由到左側格子的走法再加上上側格子的走法時，如果該格本身的位置就是障礙物的位置，就直接將0取代原本要相加的總走法，最後不斷推倒到最右下角的格子就是我們要的結果 程式碼解說:一樣在一開始就需要初始化二元陣列來紀錄mxn走到每格的所有組合數，所以就先取得包含障礙物的二元陣列的大小有幾橫排m與幾直列n，使我們能初始化一模一樣大小的二元陣列 1234567var paths [][]intvar obstacle boolm := len(obstacleGrid)n := len(obstacleGrid[0])for k := 1; k &lt;= m; k++ &#123; paths = append(paths, make([]int, n))&#125; 接著如果第一橫排與第一直列中間沒有出現障礙物的話就設初始值為1，因為一開始走到最左側或最下側都只有一種可能，但如果中間出現障礙物的話，障礙物到最左側或最下側之間的所有格子走法皆為0 1234567891011121314151617for i := 0; i &lt; m; i++ &#123; if obstacleGrid[i][0] == 1 &#123; obstacle = true &#125; if !obstacle &#123; paths[i][0] = 1 &#125;&#125;obstacle = falsefor j := 0; j &lt; n; j++ &#123; if obstacleGrid[0][j] == 1 &#123; obstacle = true &#125; if !obstacle &#123; paths[0][j] = 1 &#125;&#125; 最後則是根據先前所發現的規律，每格的走法都是由到左側格子的走法再加上上側格子的走法，將剩下的格子依序由左上到右下推倒，如果該格本身的位置就是障礙物的位置，就直接將0取代原本要相加的總走法，待最右下角格子的走法數算出來後就是我們要的結果 12345678910for i := 1; i &lt; m; i++ &#123; for j := 1; j &lt; n; j++ &#123; if obstacleGrid[i][j] == 1 &#123; paths[i][j] = 0 &#125; else &#123; paths[i][j] = paths[i-1][j] + paths[i][j-1] &#125; &#125;&#125;return paths[m-1][n-1] 完整程式碼:123456789101112131415161718192021222324252627282930313233343536func uniquePathsWithObstacles(obstacleGrid [][]int) int &#123; var paths [][]int var obstacle bool m := len(obstacleGrid) n := len(obstacleGrid[0]) for k := 1; k &lt;= m; k++ &#123; paths = append(paths, make([]int, n)) &#125; for i := 0; i &lt; m; i++ &#123; if obstacleGrid[i][0] == 1 &#123; obstacle = true &#125; if !obstacle &#123; paths[i][0] = 1 &#125; &#125; obstacle = false for j := 0; j &lt; n; j++ &#123; if obstacleGrid[0][j] == 1 &#123; obstacle = true &#125; if !obstacle &#123; paths[0][j] = 1 &#125; &#125; for i := 1; i &lt; m; i++ &#123; for j := 1; j &lt; n; j++ &#123; if obstacleGrid[i][j] == 1 &#123; paths[i][j] = 0 &#125; else &#123; paths[i][j] = paths[i-1][j] + paths[i][j-1] &#125; &#125; &#125; return paths[m-1][n-1]&#125; 總結:建議可以先參考先前Unique Paths的解法，解說較為詳細，基本上概念完全一樣，其做法就是先從簡單的部分開始以每格或點判斷走到該格有幾種可能，如果是從起點走到最左側或最下側時中間出現障礙物的話，障礙物到最左側或最下側之間的所有格子走法皆為0，接著從起點鄰近的格子慢慢推算該格的走法是由到左側格子的走法再加上上側格子的走法時，如果該格本身的位置就是障礙物的位置，就直接將0取代原本要相加的總走法，最後不斷推倒到最右下角的格子就是我們要的結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"https://blog.yunchen.tw/tags/DynamicProgramming/"}]},{"title":"Unique Paths","slug":"unique-paths","date":"2017-04-30T16:00:00.000Z","updated":"2017-04-23T14:48:27.000Z","comments":true,"path":"2017/05/01/unique-paths/","link":"","permalink":"https://blog.yunchen.tw/2017/05/01/unique-paths/","excerpt":"","text":"Unique PathsA robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 3 x 7 grid. How many possible unique paths are there? Note: m and n will be at most 100. 提示 解題應用 Array Array/Slice DynamicProgramming 規律觀查 Default:123func uniquePaths(m int, n int) int &#123;&#125; 解答思路:高中時再解這類路徑題目時都會先從簡單的部分開始以每格或點判斷走到該格有幾種可能，以題目給予的範例來說如下圖: 1231 1 1 1 1 1 11 2 3 4 5 6 71 3 6 10 15 21 28 一開始走到最左側或最下側都只有一種可能，接著從起點鄰近的格子慢慢推會發現到該格的走法都是由到左側格子的走法再加上上側格子的走法，最後不斷推倒到最右下角的格子就是我們要的結果，再理解了如此的規律後便可以很容易的寫出要的程式碼。 程式碼解說:因為需要不斷推倒每格走法的所有可能直到最右下角為止，所以一開始就需要初始化二元陣列來紀錄mxn走到每格的所有組合數 1234var paths [][]intfor k := 1; k &lt;= m; k++ &#123; paths = append(paths, make([]int, n))&#125; 接著就是初始化第一橫排與第一直列為1，因為一開始走到最左側或最下側都只有一種可能 123456for i := 0; i &lt; m; i++ &#123; paths[i][0] = 1&#125;for j := 0; j &lt; n; j++ &#123; paths[0][j] = 1&#125; 最後則是根據先前所發現的規律，每格的走法都是由到左側格子的走法再加上上側格子的走法，將剩下的格子全數依序由左上到右下推倒完後，便直接回傳最右下角格子的走法數就是我們要的結果 123456for i := 1; i &lt; m; i++ &#123; for j := 1; j &lt; n; j++ &#123; paths[i][j] = paths[i-1][j] + paths[i][j-1] &#125;&#125;return paths[m-1][n-1] 完整程式碼:123456789101112131415161718func uniquePaths(m int, n int) int &#123; var paths [][]int for k := 1; k &lt;= m; k++ &#123; paths = append(paths, make([]int, n)) &#125; for i := 0; i &lt; m; i++ &#123; paths[i][0] = 1 &#125; for j := 0; j &lt; n; j++ &#123; paths[0][j] = 1 &#125; for i := 1; i &lt; m; i++ &#123; for j := 1; j &lt; n; j++ &#123; paths[i][j] = paths[i-1][j] + paths[i][j-1] &#125; &#125; return paths[m-1][n-1]&#125; 總結:給一mxn所組成的方格，求出從最左上走到最右下共有幾走不同的走法，其做法就是先從簡單的部分開始以每格或點判斷走到該格有幾種可能，接著從起點鄰近的格子慢慢推會發現到該格的走法都是由到左側格子的走法再加上上側格子的走法，最後不斷推倒到最右下角的格子就是我們要的結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"https://blog.yunchen.tw/tags/DynamicProgramming/"}]},{"title":"Rotate List","slug":"rotate-list","date":"2017-04-29T16:00:00.000Z","updated":"2017-04-23T09:07:22.000Z","comments":true,"path":"2017/04/30/rotate-list/","link":"","permalink":"https://blog.yunchen.tw/2017/04/30/rotate-list/","excerpt":"","text":"Rotate ListGiven a list, rotate the list to the right by k places, where k is non-negative. For example:12Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL. 提示 解題應用 LinkedList Pointer TwoPointers 紀錄index位置 Default:12345678910/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func rotateRight(head *ListNode, k int) *ListNode &#123;&#125; 解答思路:因為向右移1格時從最後一個節點就會先跳躍至開頭，而右移k格時則倒數k個節點移動到開頭，因此只要知道倒數第k+1個節點的位置(與最後一個節點位置差k)，便能直接將後頭整串至底移動到開頭做嫁接，可以一口氣完成右移k格的旋轉，所以一開始就用兩變數指向頭的位置，先移動一指向變數遍歷LinkedList，待兩變數距離超過k時另一個指向變數才跟著向後遍歷，如此一來待後頭的指向變數到底時，前頭指向變數指到的位置就會是倒數第k+1個節點的位置，嫁接完就是我們要的結果了。 程式碼解說:一開始先初始化兩個變數指向頭的位置，而count則表示後頭的變數位置(已經遍歷了多少個節點)，接下來就是開始尋找倒數第k個節點的位置，如果在後頭的變數本身指向的位置不為空且下一個要遍歷的位置也不為空才繼續向下遍歷同時將count+1，當後頭遍歷的節點數大於k時，前頭變數指向的位置才要跟著向後移動 1234567891011var tmp *ListNodecount := 1front := headrear := headfor rear != nil &amp;&amp; rear.Next != nil &#123; if count &gt; k &#123; front = front.Next &#125; rear = rear.Next count++&#125; 但如果後頭的變數位置已經指向了LinkedList的最後一個節點，然而k的值根本就超過整個LinkedList長度的話，此時就直接將k與count取餘數，如果餘數的結果為0表示最後旋轉完所有的節點還停留在相同的位置，便直接將原本的LinkedList原封不動的做回傳，而如果餘數不為0，因為後頭的變數位置已經指向了最後一個節點，前頭的變數位置還停在開頭位置，這時就要直接移動前頭的變數位置到與後頭的位置差k為止，移動次數則為LinkedList長度(count)-k-1 123456789if k &gt;= count &#123; k %= count if k == 0 &#123; return head &#125; for i := 1; i &lt;= count-k-1; i++ &#123; front = front.Next &#125;&#125; 最後的嫁接如果後頭變數位置本身不為空，便將後頭變數位置的下一個嫁接到開頭，接著前頭變數的位置是在原本倒數第k+1個上，而因為後頭的k個都已經移動到開頭了，所以在暫存了倒數第k個的位置後(會變到LinkedList的第一個節點)，就將原本前頭變數位置的下一個改為nil，才回傳先前暫存的位置也就是新的LinkedList第一個節點位置 123456if rear != nil &#123; rear.Next = head tmp = front.Next front.Next = nil&#125;return tmp 完整程式碼:12345678910111213141516171819202122232425262728func rotateRight(head *ListNode, k int) *ListNode &#123; var tmp *ListNode count := 1 front := head rear := head for rear != nil &amp;&amp; rear.Next != nil &#123; if count &gt; k &#123; front = front.Next &#125; rear = rear.Next count++ &#125; if k &gt;= count &#123; k %= count if k == 0 &#123; return head &#125; for i := 1; i &lt;= count-k-1; i++ &#123; front = front.Next &#125; &#125; if rear != nil &#123; rear.Next = head tmp = front.Next front.Next = nil &#125; return tmp&#125; 總結:要將LinkedList的節點分別向右移k格(旋轉)，使得最後一個節點的位置紛紛跳躍至開頭，要回傳旋轉後的LinkedList，仔細觀查會發現右移k格時倒數k個節點會移動到開頭，因此只要知道倒數第k+1個節點的位置(與最後一個節點位置差k)，便能直接將後頭整串至底移動到開頭做嫁接，所以一開始就用兩變數指向頭的位置，先移動一指向變數遍歷LinkedList，待兩變數距離超過k時另一個指向變數才跟著向後遍歷，如此一來待後頭的指向變數到底時，前頭指向變數指到的位置就會是倒數第k+1個節點的位置，嫁接完就是我們要的結果了。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://blog.yunchen.tw/tags/LinkedList/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"}]},{"title":"Permutation Sequence","slug":"permutation-sequence","date":"2017-04-28T16:00:00.000Z","updated":"2017-04-21T20:32:57.000Z","comments":true,"path":"2017/04/29/permutation-sequence/","link":"","permalink":"https://blog.yunchen.tw/2017/04/29/permutation-sequence/","excerpt":"","text":"Permutation SequenceThe set [1,2,3,…,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order,We get the following sequence (ie, for n = 3): “123” “132” “213” “231” “312” “321” Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive. 提示 解題應用 Backtracking 規律觀查 Math 排序組合 Default:123func getPermutation(n int, k int) string &#123;&#125; 解答思路:一開始本來想用遞回來列出所有結果，但只是要其中的第k個而且又有規律存在，所以應該可以直接算出第k個的組合是什麼，以上述的範例來說，仔細觀查的話會發現1開頭的組合有2個，2開頭的組合也有2個以此類推，也就是說長度為3的組合有3*2*1=6種，取了第一個值後剩下的組合就剩2*1=2種，到這邊都只是排序組合的概念，如果k值減去開頭為1的組合(2種)後，k值還大於0表示開頭不為1仍要向後不斷尋找(-2)，一直到k值小於等於0才可以確定k是落在開頭為x的組合之間，並藉由k值的正負數變化開始找開頭為x的第y個，最後就是不斷重覆上述方式一直到找出長度為3(n)的結果為止。 程式碼解說:一開始先將n值初始化為1~n的字串元素陣列，以方便我們在找出開頭為x值時能從陣列移除來避免重覆取值，同時利用一變數暫存n!的值用以後續一邊找出所有長度的組合有多少個，接著才正式開始尋找第k個的組合，利用一迴圈從第1個值的位置開始尋找第k個的組合，先將之前的暫存值除去n以曉得取了一個值後剩下各別的組合有幾種，接下來就是不斷的將k值與暫存值相減到k小於等於0才可以確定k是落在開頭為x的組合之間，不過雖然是說不斷與暫存值相減，但其實直接將k值與暫存值相除就可以曉得落在第x組(例:開頭為1的當作1組)，而如果相除後餘數大於0表是是在下一組，x的位置就要+1，至於k值就是剛才所剩下的餘數代表開頭為x的第y個，如果餘數為0(非大於0)則表示是在開頭為x的最後一個組合，也就是暫存值的長度(取了一個值後剩下各別的組合有幾種)，此時的k要記得存入暫存值，知道落在第x組後就直接將x-1作為index值從陣列取出值放入結果字串中，並將x位置的值能從陣列移除(重組陣列)來避免後續重覆取值，最後直到n的長度歸0(每找出一個值便將n-1)表示已經出結果才做回傳 12345678910111213141516171819202122var pos intvar result stringtmp := 1set := make([]string, n)for i := 1; i &lt;= n; i++ &#123; set[i-1] = string(i + 48) tmp *= i&#125;for n &gt; 0 &#123; tmp /= n pos = k / tmp if k%tmp &gt; 0 &#123; pos++ k = k % tmp &#125; else &#123; k = tmp &#125; result += set[pos-1] set = append(set[:pos-1], set[pos:]...) n--&#125;return result 完整程式碼:123456789101112131415161718192021222324func getPermutation(n int, k int) string &#123; var pos int var result string tmp := 1 set := make([]string, n) for i := 1; i &lt;= n; i++ &#123; set[i-1] = string(i + 48) tmp *= i &#125; for n &gt; 0 &#123; tmp /= n pos = k / tmp if k%tmp &gt; 0 &#123; pos++ k = k % tmp &#125; else &#123; k = tmp &#125; result += set[pos-1] set = append(set[:pos-1], set[pos:]...) n-- &#125; return result&#125; 總結:給一n代表一陣列元素1~n，將元素依序做排列組合，要求出第k個的結果，其做法就是利用排列組合的概念從1開始有(n-1)!種組合，並不斷將k值與(n-1)!相減直到k小於等於0才可以確定k是落在開頭為x的組合之間，並藉由k值的正負數變化開始找開頭為x的第y個，最後就是不斷重覆上述方式一直到找出長度為n的結果為止。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"},{"name":"Backtracking","slug":"Backtracking","permalink":"https://blog.yunchen.tw/tags/Backtracking/"}]},{"title":"Spiral Matrix II","slug":"spiral-matrix-II","date":"2017-04-27T16:00:00.000Z","updated":"2017-04-30T09:19:02.000Z","comments":true,"path":"2017/04/28/spiral-matrix-II/","link":"","permalink":"https://blog.yunchen.tw/2017/04/28/spiral-matrix-II/","excerpt":"","text":"Spiral Matrix IIGiven an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. For example:Given n = 3, You should return the following matrix: 12345[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 提示 解題應用 Array 二元陣列 Default:123func generateMatrix(n int) [][]int &#123;&#125; 解答思路:建議可以先參考先前Spiral Matrix的解法，解說較為詳細，基本上概念完全一樣，只是將先前題的程式碼稍做修改而已，如果能將二元陣列以螺旋的方式輸出所有元素，當然要直接輸出一個nxn二元陣列以螺旋排序的元素1~n^2就不會太困難。 一開始先初始化空的nxn二元陣列，剩下的就是以螺旋的方式一邊遍歷一邊將值依序放入目標位置即可，而一樣也是藉由四個變數來控制要遍歷的位置以避免重覆，並且隨著最外圈遍歷結束後四個變數也跟著向內縮，有概念之後就可以很容易順勢寫程式碼了。 程式碼解說:這邊只解說與先前題目程式碼的相異之處，因為這次是要直接輸出一個nxn二元陣列以螺旋排序的元素1~n^2，所以一開始利用迴圈先初始化空的nxn二元陣列，並用一個變數來慢慢遞增用以儲存至陣列的元素值，接著就是藉由四個變數來控制要遍歷的位置，以遍歷最上面的邊來說，將原本要從二元陣列上邊位置取出值的部分改為將該位置放入我們要的值(變數)，放入之後再將變數+1，待上邊遍歷結束再內縮直到全數遞增的值放入完畢才回傳整個二元陣列結果 12345678910111213141516171819var rowStart introwEnd := n - 1var colStart intcolEnd := n - 1var matrix [][]intcount := 1for i := 1; i &lt;= n; i++ &#123; matrix = append(matrix, make([]int, n))&#125;for colStart &lt;= colEnd &amp;&amp; rowStart &lt;= rowEnd &#123; for i := colStart; i &lt;= colEnd; i++ &#123; matrix[rowStart][i] = count count++ &#125; rowStart++ ...&#125;return matrix 完整程式碼:1234567891011121314151617181920212223242526272829303132333435363738func generateMatrix(n int) [][]int &#123; var rowStart int rowEnd := n - 1 var colStart int colEnd := n - 1 var matrix [][]int count := 1 for i := 1; i &lt;= n; i++ &#123; matrix = append(matrix, make([]int, n)) &#125; for colStart &lt;= colEnd &amp;&amp; rowStart &lt;= rowEnd &#123; for i := colStart; i &lt;= colEnd; i++ &#123; matrix[rowStart][i] = count count++ &#125; rowStart++ for i := rowStart; i &lt;= rowEnd; i++ &#123; matrix[i][colEnd] = count count++ &#125; colEnd-- if rowStart &lt;= rowEnd &#123; for i := colEnd; i &gt;= colStart; i-- &#123; matrix[rowEnd][i] = count count++ &#125; &#125; rowEnd-- if colStart &lt;= colEnd &#123; for i := rowEnd; i &gt;= rowStart; i-- &#123; matrix[i][colStart] = count count++ &#125; &#125; colStart++ &#125; return matrix&#125; 總結:建議可以先參考先前Spiral Matrix的解法，解說較為詳細，基本上概念完全一樣，只是這次是要輸出一個nxn二元陣列以螺旋排序的元素1~n^2，所以一開始先初始化空的nxn二元陣列，剩下的就是以螺旋的方式一邊遍歷一邊將值依序放入目標位置即可，而一樣也是藉由四個變數來控制要遍歷的位置以避免重覆，並且隨著最外圈遍歷結束後四個變數也跟著向內縮，有概念之後就可以很容易順勢寫程式碼了。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"}]},{"title":"Merge Intervals","slug":"merge-intervals","date":"2017-04-26T16:00:00.000Z","updated":"2017-04-16T15:02:11.000Z","comments":true,"path":"2017/04/27/merge-intervals/","link":"","permalink":"https://blog.yunchen.tw/2017/04/27/merge-intervals/","excerpt":"","text":"Merge IntervalsGiven a collection of intervals, merge all overlapping intervals. For example:12Given [1,3],[2,6],[8,10],[15,18],return [1,6],[8,10],[15,18]. 提示 解題應用 Array Array/Slice Sort Interfaces實作 Default:12345678910/** * Definition for an interval. * type Interval struct &#123; * Start int * End int * &#125; */func merge(intervals []Interval) []Interval &#123;&#125; 解答思路:這題最主要的關鍵在於排序，每組間隔的頭尾最好都能彼此做排序，先將每組的起頭做完排序，如果起頭的值相同則排序結尾的值，結果就會如同範例那樣井然有序，在每組間隔都能排序好的情況下，剩下的合併就會變的非常容易，一開始先前第一組間隔放入結果陣列中，接著才從第二組往下做判斷，如果前一組的結尾比下一組的開頭與結尾大，表示前一組完全包含了下一組的範圍便跳過，而如果是前一組的結尾比下一組的開頭大但比結尾小的話，此時就將下一組的結尾取代前一組(存於結果陣列中)的結尾，至於如果是前一組的結尾比下一組的開頭小，此時便直接將下一組插入結果陣列之中，最後合併完陣列間隔後才回傳結果。 程式碼解說:因為在Golang 1.7中並沒有直接能排序struct資料陣列的library(1.8在sort中有)，所以就需要自行去實作一個interface並包含了三個method:Len(),Swap(),Less()，以利我們能直接用內建的sort來排序我們的struct資料陣列，基本上Len()與Swap()與一般型別陣列做法一致，至於Less則是要比較是否前者比較小，這邊就是內建sort在排序資料時所判斷的標準，因為我們的資料型別是struct且最好頭尾都能做排序，所以就改成如果兩個陣列元素struct的Start值相同就比較兩個陣個陣列元素struct的End值，否則便直接比較兩個陣列元素struct的Start值即可 123456789type Sorter []Intervalfunc (a Sorter) Len() int &#123; return len(a) &#125;func (a Sorter) Swap(i, j int) &#123; a[i], a[j] = a[j], a[i] &#125;func (a Sorter) Less(i, j int) bool &#123; if a[i].Start == a[j].Start &#123; return a[i].End &lt; a[j].End &#125; return a[i].Start &lt; a[j].Start&#125; 再來就可以開始來處理參數所帶入的間隔陣列，如果間隔陣列為空便直接回傳該空的陣列，接著就是將間隔陣列用先前實作的interface來包裝以利我們的struct資料能根據Start與End來用內建的sort排序，排序結束後將間隔陣列的第一個間隔組放入結果陣列之中並紀錄該間隔的結尾值，之後利用迴圈從第二組間隔開始往下遍歷，如果先前紀錄的結尾比遍歷的開頭與結尾大，表示先前所紀錄的間隔範圍包含了此組間隔所以跳過，而如果先前紀錄的結尾比遍歷的開頭大但比結尾小的話，此時就將遍歷的結尾取代先前剛存於結果陣列中的間隔結尾，至於如果先前紀錄的結尾比遍歷的開頭小，則直接將遍歷的間隔組放入結果陣列之中，不管何種情況都要記得將紀錄的結尾值改成遍歷的結尾，最後合併完陣列間隔後才回傳結果 1234567891011121314151617181920func merge(intervals []Interval) []Interval &#123; if len(intervals) == 0 &#123; return intervals &#125; sort.Sort(Sorter(intervals)) result := []Interval&#123;intervals[0]&#125; curEnd := intervals[0].End for _, v := range intervals[1:] &#123; if curEnd &gt;= v.Start &#123; if curEnd &gt;= v.End &#123; continue &#125; result[len(result)-1].End = v.End &#125; else &#123; result = append(result, v) &#125; curEnd = v.End &#125; return result&#125; 完整程式碼:1234567891011121314151617181920212223242526272829type Sorter []Intervalfunc (a Sorter) Len() int &#123; return len(a) &#125;func (a Sorter) Swap(i, j int) &#123; a[i], a[j] = a[j], a[i] &#125;func (a Sorter) Less(i, j int) bool &#123; if a[i].Start == a[j].Start &#123; return a[i].End &lt; a[j].End &#125; return a[i].Start &lt; a[j].Start&#125;func merge(intervals []Interval) []Interval &#123; if len(intervals) == 0 &#123; return intervals &#125; sort.Sort(Sorter(intervals)) result := []Interval&#123;intervals[0]&#125; curEnd := intervals[0].End for _, v := range intervals[1:] &#123; if curEnd &gt;= v.Start &#123; if curEnd &gt;= v.End &#123; continue &#125; result[len(result)-1].End = v.End &#125; else &#123; result = append(result, v) &#125; curEnd = v.End &#125; return result&#125; 總結:一結構包含起始值與結尾值代表一個間隔範圍，如果有一結構陣列其每個元素分別代表不同間隔範圍，如果元素間的範圍有交集就要將其做合併，最後要回傳一合併後的結構陣列，最主要的關鍵在於每組間隔的頭尾最好都能彼此做排序，先將每組的起頭做完排序，如果起頭的值相同則排序結尾的值，結束後剩下的合併就會變的非常容易，一開始先前第一組間隔放入結果陣列中，接著才從第二組往下做判斷，如果前一組的結尾比下一組的開頭與結尾大，表示前一組完全包含了下一組的範圍便跳過，而如果是前一組的結尾比下一組的開頭大但比結尾小的話，此時就將下一組的結尾取代前一組(存於結果陣列中)的結尾，至於如果是前一組的結尾比下一組的開頭小，此時便直接將下一組插入結果陣列之中，最後合併完陣列間隔後才回傳結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"Sort","slug":"Sort","permalink":"https://blog.yunchen.tw/tags/Sort/"}]},{"title":"Jump Game","slug":"jump-game","date":"2017-04-25T16:00:00.000Z","updated":"2017-04-16T01:16:00.000Z","comments":true,"path":"2017/04/26/jump-game/","link":"","permalink":"https://blog.yunchen.tw/2017/04/26/jump-game/","excerpt":"","text":"Jump GameGiven an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. For example:123A = [2,3,1,1,4], return true.A = [3,2,1,0,4], return false. 提示 解題應用 Array Array/Slice Greedy 規律觀查 Default:123func canJump(nums []int) bool &#123;&#125; 解答思路:一開始還以為陣列中的每個元素代表是一定要跳到該格的位置，而且在考慮往前或往後的情況下勢必要用遞回來處理，但再仔細看題目之後才發現是代表能跳躍的最大距離，並且觀查範例之後更進一步的發現到能不能跳到最後一格的位置最主要跟元素值為0有關係，只要前面任一個能跳躍的距離超過元素值為0的位置，表示便能繼續往下跳只達終點，所以只要一邊遍歷陣列一邊找出能跳躍到達的最大位置，遇到元素值為0的時候便判斷目前能到的最大位置是否超過0的位置，如果沒辦法超過就回傳false直到全數陣列遍歷結束才回傳true。 程式碼解說:因為要一邊遍歷陣列一邊找出能跳躍到達的最大位置，所以一開始便直接遍歷整個陣列，如果碰上元素值為0的情況，便要檢查目前能到的最大位置是否超過0的位置，唯獨如果元素值為0的位置剛好就已經在陣列的最後一格便不需判斷(因為已經到達我們要的目標位置了!)，如果能到的最大位置沒辦法超過0的位置就直接回傳false，否則便繼續往下遍歷並且判斷每一次能跳躍到達的位置是否比目前能到達的最大位置大，如果是就將該位置取代最大位置，直到全數陣列遍歷結束(表示順利到達陣列最後一格的位置)才回傳true 12345678910var max intfor i, v := range nums &#123; if v == 0 &amp;&amp; i != len(nums)-1 &amp;&amp; i &gt;= max &#123; return false &#125; if i+v &gt; max &#123; max = i + v &#125;&#125;return true 完整程式碼:123456789101112func canJump(nums []int) bool &#123; var max int for i, v := range nums &#123; if v == 0 &amp;&amp; i != len(nums)-1 &amp;&amp; i &gt;= max &#123; return false &#125; if i+v &gt; max &#123; max = i + v &#125; &#125; return true&#125; 總結:一陣列中每個元素代表能跳躍的最大距離，要判斷是否最後能跳到陣列最後一格的位置，仔細觀查會發現到能不能跳到最後一格的位置最主要跟元素值為0有關係，只要前面任一個能跳躍的距離超過元素值為0的位置，表示便能繼續往下跳只達終點，所以只要一邊遍歷陣列一邊找出能跳躍到達的最大位置，遇到元素值為0的時候便判斷目前能到的最大位置是否超過0的位置，如果沒辦法超過就回傳false直到全數陣列遍歷結束才回傳true。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"Greedy","slug":"Greedy","permalink":"https://blog.yunchen.tw/tags/Greedy/"}]},{"title":"Spiral Matrix","slug":"spiral-matrix","date":"2017-04-24T16:00:00.000Z","updated":"2017-04-15T09:57:16.000Z","comments":true,"path":"2017/04/25/spiral-matrix/","link":"","permalink":"https://blog.yunchen.tw/2017/04/25/spiral-matrix/","excerpt":"","text":"Spiral MatrixGiven a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. For example:Given the following matrix: 12345[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]] You should return [1,2,3,6,9,8,7,4,5]. 提示 解題應用 Array 二元陣列 Default:123func spiralOrder(matrix [][]int) []int &#123;&#125; 解答思路:原本以圖形來思考是不是只要用一個變數就可以分別遍歷外圈、內圈，也就是說當遍歷最外圈時，四個邊內縮為0，要遍歷內圈一點四個邊就內縮1…等等，然而沒這麼簡單，因為還有重覆的問題，也就是說如果直接遍歷四個邊最後會造成四個角都出現重覆的值，當然可以每次到四個角的位置就篩選掉一次重覆的結果，但倒不如在遍歷的時候就避免會重覆如下的方式: 123456789101112131415161718192021222324252627282930[初始值]rowStart: 0rowEnd : mcolStart: 0colEnd : n colStart: 0 (colStart++) → (rowStart++) colEnd: m - - - - - - - - - → ↑ ∣ rowStart: 1 | ∣ ↓ | ∣ rowEnd: nrowStart: 1 | ∣ ↑ | ∣ rowEnd: n-1 | ∣ ← - - - - - - - - ↓ colEnd: m-1 (rowEnd--) ← (colEnd--) colStart: 0[遍歷完最外圈後]rowStart: 1rowEnd : m-1colStart: 1colEnd : n-1 藉由四個變數來控制要遍歷的位置以避免重覆之外，最後當最外圈遍歷結束後，四個變數自然也就向內縮，所以只要一開始便想到要以四個變數來控制遍歷的位置，剩下的程式碼就很容易順勢寫出來了。 程式碼解說:一開始先判斷二元陣列是否為空，如果是便直接回傳空陣列，接下來就是初始化四個變數來控制要遍歷的位置，橫排或直列的起始值皆為0，至於橫排的最終值是二元陣列的橫排有多少再扣1，而直列的最終值則是二元陣列中的每列有多少個元素再扣1，最後才開始螺旋遍歷二元陣列直到橫排或直列的起始值超過最終值才回傳結果陣列 123456789101112var result []intif len(matrix) == 0 &#123; return result&#125;var rowStart introwEnd := len(matrix) - 1var colStart intcolEnd := len(matrix[0]) - 1for colStart &lt;= colEnd &amp;&amp; rowStart &lt;= rowEnd &#123;...&#125;return result 一開始先遍歷最上面的邊，而待遍歷結束後就可以先將rowStart的值內縮(+1) 1234for i := colStart; i &lt;= colEnd; i++ &#123; result = append(result, matrix[rowStart][i])&#125;rowStart++ 接著便遍歷最右邊的邊，剛好rowStart的值內縮(+1)，所以可以避免右上角的值重覆，因此可以放心繼續遍歷，而待遍歷結束後就可以將colEnd的值內縮(-1) 1234for i := rowStart; i &lt;= rowEnd; i++ &#123; result = append(result, matrix[i][colEnd])&#125;colEnd-- 再來是遍歷最下面的邊，而也是因為colEnd的值內縮(-1)，可以避免右下角的值重覆以繼續遍歷，不過這次多了一層row範圍的判斷，原因在於這個二元陣列是矩形mxn而非正方形mxm，可能外層遍歷後內圈只剩一橫排的陣列，此時這一橫排的陣列可能被當作最上面的邊而早已被遍歷，所以這邊就要再多一層row範圍的判斷以確保該僅存橫排的陣列不會再次被當作最下面的邊而重覆遍歷，待遍歷結束後就可以將rowEnd的值內縮(-1) 123456if rowStart &lt;= rowEnd &#123; for i := colEnd; i &gt;= colStart; i-- &#123; result = append(result, matrix[rowEnd][i]) &#125;&#125;rowEnd-- 最後則是遍歷最左邊的邊，因為rowEnd的值內縮(-1)，可以避免左下角的值重覆以繼續遍歷，這邊一樣多了一層col範圍的判斷，僅存橫排的陣列可能已被當作最右邊的邊而被遍歷，所以多一層col範圍的判斷以確保不會再次被當作最左邊的邊而重覆遍歷，待遍歷結束後就可以將colStart的值內縮(+1) 123456if colStart &lt;= colEnd &#123; for i := rowEnd; i &gt;= rowStart; i-- &#123; result = append(result, matrix[i][colStart]) &#125;&#125;colStart++ 完整程式碼:123456789101112131415161718192021222324252627282930313233func spiralOrder(matrix [][]int) []int &#123; var result []int if len(matrix) == 0 &#123; return result &#125; var rowStart int rowEnd := len(matrix) - 1 var colStart int colEnd := len(matrix[0]) - 1 for colStart &lt;= colEnd &amp;&amp; rowStart &lt;= rowEnd &#123; for i := colStart; i &lt;= colEnd; i++ &#123; result = append(result, matrix[rowStart][i]) &#125; rowStart++ for i := rowStart; i &lt;= rowEnd; i++ &#123; result = append(result, matrix[i][colEnd]) &#125; colEnd-- if rowStart &lt;= rowEnd &#123; for i := colEnd; i &gt;= colStart; i-- &#123; result = append(result, matrix[rowEnd][i]) &#125; &#125; rowEnd-- if colStart &lt;= colEnd &#123; for i := rowEnd; i &gt;= rowStart; i-- &#123; result = append(result, matrix[i][colStart]) &#125; &#125; colStart++ &#125; return result&#125; 總結:給一mxn的二元陣列，要以螺旋狀的方式來輸出結果，最重要的是要以四個變數來控制要遍歷的位置，分別是rowStart、rowEnd、colStart、colEnd，詳情可以參考解答思路的細節解說，總之只要一開始便想到要以四個變數來控制遍歷的位置，剩下的程式碼就很容易順勢寫出來了。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"}]},{"title":"Maximum Subarray","slug":"maximum-subarray","date":"2017-04-23T16:00:00.000Z","updated":"2017-04-13T17:56:11.000Z","comments":true,"path":"2017/04/24/maximum-subarray/","link":"","permalink":"https://blog.yunchen.tw/2017/04/24/maximum-subarray/","excerpt":"","text":"Maximum SubarrayFind the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. 提示 解題應用 Array Array/Slice DynamicProgramming 規律觀查 Default:123func maxSubArray(nums []int) int &#123;&#125; 解答思路:一開始是用兩個變數去指向要找出結果陣列(最大值的陣列)的開頭與結尾，不過後來發現到只需要求總合即可，所以便不需要去紀錄陣列的位置，直接遍歷陣列找出最大總合即可，每當從陣列取出一個新值，如果先前的總合為負數，就直接將該值取代總合(當作最大值陣列的開頭)，因為如果包含先前總合的話，不論目前取出的該值為正或為負一定會變的更小，所以倒不如就直接取代以尋找新的陣列組合，至於如果先前總合不為負數則可以繼續往下累加以尋找總合最大值，每次確定當下的總合之後便判斷是否比目前找到的最大總合大，如果是就取代直到取完陣列的所有值後才回傳最大值的總合。 程式碼解說:一開始先將總合與最大總合初始化為陣列的第一個元素值，之後才開始以迴圈從陣列的第二個值一個個取值，如思路所寫如果先前總合為負的話就將目前取出的值取代總合，否則就將該值繼續累加至總合之中，待確定當下的總合之後便判斷是否比目前找到的最大總合大，如果是就取代直到取完陣列的所有值後才回傳最大值的總合 12345678910111213sum := nums[0]max := sumfor _, v := range nums[1:] &#123; if sum &lt; 0 &#123; sum = v &#125; else &#123; sum += v &#125; if sum &gt; max &#123; max = sum &#125;&#125;return max 完整程式碼:123456789101112131415func maxSubArray(nums []int) int &#123; sum := nums[0] max := sum for _, v := range nums[1:] &#123; if sum &lt; 0 &#123; sum = v &#125; else &#123; sum += v &#125; if sum &gt; max &#123; max = sum &#125; &#125; return max&#125; 總結:要從一陣列中找出子陣列能組出的最大總合，其做法是每當從陣列取出一個新值，如果先前的總合為負數，就直接將該值取代總合(當作最大值陣列的開頭)，至於如果先前總合不為負數則可以繼續往下累加以尋找總合最大值，每次確定當下的總合之後便判斷是否比目前找到的最大總合大，如果是就取代直到取完陣列的所有值後才回傳最大值的總合。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"https://blog.yunchen.tw/tags/DynamicProgramming/"},{"name":"DivideAndConquer","slug":"DivideAndConquer","permalink":"https://blog.yunchen.tw/tags/DivideAndConquer/"}]},{"title":"Pow(x, n)","slug":"pow","date":"2017-04-22T16:00:00.000Z","updated":"2017-04-12T17:35:30.000Z","comments":true,"path":"2017/04/23/pow/","link":"","permalink":"https://blog.yunchen.tw/2017/04/23/pow/","excerpt":"","text":"Pow(x, n)Implement pow(x, n). 提示 解題應用 BinarySearch 二分法 Math 規律觀查 Default:123func myPow(x float64, n int) float64 &#123;&#125; 解答思路:先考慮次方值n只有正數的情況下，如果n是偶數的話x^n就可以變成(x*x)^(n/2)，也就是說每次的次方數都可以對半，如此一來迴圈就不用做那麼多次，但如果n是奇數的話就要想辦法將其轉變為偶數，把x^n變為x*(x^(n-1))，將一個x值抽出存入暫存值待最後偶數部分的次方算完後才乘回去便能解決，至於如果n為負值的話則是將x轉為1/x再將n改回正值後才開始上述計算(數學次方計算的觀念)。 程式碼解說:這邊一開始先初始化暫存值為1.0(float64)以利如果n值為奇數時暫存抽出的x值，接著便判斷n值是否為負數，如果是就將x轉為1/x再將n改回正值，而如果n一開便為0，此時便直接回傳1(或暫存值)，前置作業都判斷結束後才開始以迴圈計算x值n次方的值，如果n為奇數的話將當下x值乘至暫存值並將次方數-1變為偶數，當次方數為偶數時就可以將x與x相乘並將次方數對半直到n為0或1為止才結束迴圈，最後只要將先前的暫存值與偶數次方情況下運算完的總合相乘就是我們要的結果 12345678910111213141516tmp := 1.0if n &lt; 0 &#123; x = 1 / x n *= -1&#125; else if n == 0 &#123; return tmp&#125;for n &gt; 1 &#123; if n%2 == 1 &#123; tmp *= x n-- &#125; x *= x n /= 2&#125;return tmp * x 完整程式碼:123456789101112131415161718func myPow(x float64, n int) float64 &#123; tmp := 1.0 if n &lt; 0 &#123; x = 1 / x n *= -1 &#125; else if n == 0 &#123; return tmp &#125; for n &gt; 1 &#123; if n%2 == 1 &#123; tmp *= x n-- &#125; x *= x n /= 2 &#125; return tmp * x&#125; 總結:某數與該數的次方值n要計算出結果，先考慮次方值n只有正數的情況下，如果n是偶數的話x^n就可以變成(x*x)^(n/2)，使每次的次方數都可以對半，但如果n是奇數的話就要把x^n變為x*(x^(n-1))，將一個x值抽出存入暫存值待最後偶數部分的次方算完後才乘回去，至於如果n為負值的話則是將x轉為1/x再將n改回正值後才開始上述計算。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://blog.yunchen.tw/tags/BinarySearch/"}]},{"title":"Group Anagrams","slug":"group-anagrams","date":"2017-04-21T16:00:00.000Z","updated":"2017-04-10T12:44:47.000Z","comments":true,"path":"2017/04/22/group-anagrams/","link":"","permalink":"https://blog.yunchen.tw/2017/04/22/group-anagrams/","excerpt":"","text":"Group AnagramsGiven an array of strings, group anagrams together. For example:Given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],Return: 12345[ [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note: All inputs will be in lower-case. 提示 解題應用 HashTable HashMap String 規律觀查 Default:123func groupAnagrams(strs []string) [][]string &#123;&#125; 解答思路:一開始的做法是每取出一個字串就遍歷一次計算該字串是由哪些字母且又有多少個所組成，並將此記錄存成hashmap放入陣列之中，之後的字串再找出由哪些字母、數量組成的記錄時逐一與陣列中所存的紀錄做比較，如果相同就放到與紀錄陣列位置相同的結果陣列之中，如果不同則將此新紀錄放入紀錄陣列之中，並存入結果陣列的新位置，但是這樣的做法雖然最後可以通過測資，但是拿到的新紀錄逐一與陣列中所存的紀錄做比較花費過多的時間，所以參考了其它比較好的做法是每取出一個字串就將其排序，雖然排序比起之前只遍歷一遍算由哪些字母、數量組成的記錄還來的花時間，但是只要將其排序後的字串存入hashmap的key中，而value則是一陣列用來儲存相同的結果，之後的排序字串要在hashmap中查找是否存在就只要O(1)的時間，最後一樣存在就將原字串放入hashmap對應的陣列之中，否則就以該排序的字串在hashmap中新增一個對應的陣列。 程式碼解說:如先前所說，最佳的解法就是將字串排序完再利用一hashmap做分類儲存，在一開始就初始化一個hashamp，其中key值為排序後的字串，而value則是陣列用來儲存對應的原字串，接下來就是利用一迴圈將字串陣列的每個字串一一取出，而要將單一字串做排序就先將其再拆成字串陣(每個元素僅一個字母)，待排序完成後再合併回字串，接下來在hashmap中檢查排序字串是否存在，不過就這邊的程式碼來說，如果存在取出的對應陣列就不為空，而如果不存在則取出的是為空陣列，但是最後都是一律將原字串塞入該陣列之中並取代原陣列的位置，所以這邊就沒有在檢查排序字串是否於hashmap之中了，最後待分類全數結束後，剩下的就是將每個排序字串對應的陣列一一取出，合併成一個二元陣列後便回傳結果 12345678910111213141516var s []stringvar sortStr stringvar result [][]stringgroups := make(map[string][]string)for _, str := range strs &#123; s = strings.Split(str, \"\") sort.Strings(s) sortStr = strings.Join(s, \"\") group, _ := groups[sortStr] group = append(group, str) groups[sortStr] = group&#125;for _, group := range groups &#123; result = append(result, group)&#125;return result 完整程式碼:123456789101112131415161718func groupAnagrams(strs []string) [][]string &#123; var s []string var sortStr string var result [][]string groups := make(map[string][]string) for _, str := range strs &#123; s = strings.Split(str, \"\") sort.Strings(s) sortStr = strings.Join(s, \"\") group, _ := groups[sortStr] group = append(group, str) groups[sortStr] = group &#125; for _, group := range groups &#123; result = append(result, group) &#125; return result&#125; 總結:給一陣列字串要將由相同字母、數量組成的字串放入同一陣列之中，最後回傳一個二元陣列的結果，其較佳的做法是每取出一個字串就將其排序，接著只要將其排序後的字串存入hashmap的key中，而value則是一陣列用來儲存相同的結果，之後的排序字串要在hashmap中查找是否存在，如果存在就將原字串放入hashmap對應的陣列之中，否則就以該排序的字串在hashmap中新增一個對應的陣列。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"}]},{"title":"Rotate Image","slug":"rotate-image","date":"2017-04-20T16:00:00.000Z","updated":"2017-04-08T15:22:14.000Z","comments":true,"path":"2017/04/21/rotate-image/","link":"","permalink":"https://blog.yunchen.tw/2017/04/21/rotate-image/","excerpt":"","text":"Rotate ImageYou are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Follow up:Could you do this in-place? 提示 解題應用 Array Array/Slice Default:123func rotate(matrix [][]int) &#123;&#125; 解答思路:很久以前曾解過一樣的題目，沒想到還會再次碰上，一開始還壓根忘了如何去旋轉二元陣列，實際上是有小技巧的，如果是順時針旋轉就先將前後橫排對換，例如第一橫排與最後一橫排位置互換，第二橫排與倒數第二橫排互換，而如果是逆時針則是將左右直列對換，接下來不論是順時針還是逆時針以對角線(左上到右下)為中心將兩兩對稱到的值互換，如此一來便完成了90度角的旋轉。 12341234 $%^&amp; $~515678 =&gt; ~!@# =&gt; %!62~!@# 5678 ^@73$%^&amp; 1234 &amp;#84 程式碼解說:因為本題要做順時針旋轉，所以一開始就要先將前後橫排對掉，所以我們分別指向第一橫排與最後一橫排的位置，接著再以一回圈取出前排的每個元素來與後排的元素做交換以達成橫排位置的對掉，結束後原本指向前後橫排的位置再分別向內縮直到所有的橫排都對掉完畢為止(前排指向的位置大於等於後排指向的位置) 123456789101112var tmp intfront := 0rear := len(matrix) - 1for front &lt; rear &#123; for i, v := range matrix[front] &#123; tmp = v matrix[front][i] = matrix[rear][i] matrix[rear][i] = tmp &#125; front++ rear--&#125; 再來就是以對角線(左上到右下)為中心將兩兩對稱到的值互換，以下圖為例: 12345X123→1X23→22X3→333X↓↓↓ 我們關注的是橫排的index(123,23,3)與直列的index(123,23,3)，了解到對角線將兩兩對稱值互換的規律後，接下來便能很容易的寫出對角線對稱交換的程式碼，這邊的i-1代表橫排的位置，而j則是表示直列的位置 1234567for i := 1; i &lt;= len(matrix)-1; i++ &#123; for j := i; j &lt;= len(matrix)-1; j++ &#123; tmp = matrix[i-1][j] matrix[i-1][j] = matrix[j][i-1] matrix[j][i-1] = tmp &#125;&#125; 完整程式碼:123456789101112131415161718192021func rotate(matrix [][]int) &#123; var tmp int front := 0 rear := len(matrix) - 1 for front &lt; rear &#123; for i, v := range matrix[front] &#123; tmp = v matrix[front][i] = matrix[rear][i] matrix[rear][i] = tmp &#125; front++ rear-- &#125; for i := 1; i &lt;= len(matrix)-1; i++ &#123; for j := i; j &lt;= len(matrix)-1; j++ &#123; tmp = matrix[i-1][j] matrix[i-1][j] = matrix[j][i-1] matrix[j][i-1] = tmp &#125; &#125;&#125; 總結:要將一二元陣列做90度旋轉，如果是順時針旋轉就先將前後橫排對換，而如果是逆時針則是將左右直列對換，接下來不論是順時針還是逆時針以對角線(左上到右下)為中心將兩兩對稱到的值互換，如此一來便完成了90度角的旋轉。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"}]},{"title":"Permutations II","slug":"permutations-II","date":"2017-04-19T16:00:00.000Z","updated":"2017-04-22T14:12:05.000Z","comments":true,"path":"2017/04/20/permutations-II/","link":"","permalink":"https://blog.yunchen.tw/2017/04/20/permutations-II/","excerpt":"","text":"Permutations IIGiven a collection of numbers that might contain duplicates, return all possible unique permutations. For example:[1,1,2] have the following unique permutations: 12345[ [1,1,2], [1,2,1], [2,1,1]] 提示 解題應用 Backtracking Recursive Default:123func permuteUnique(nums []int) [][]int &#123;&#125; 解答思路:建議可以先參考先前Permutations的解法，解說較為詳細，基本上概念完全一樣，只是將先前題的程式碼稍做修改而已，如果在陣列元素不重覆的情況下可以找出所有組合，當然出現陣列元素會重覆的可能要篩選掉相同的組合就簡單多了。 一開始先做排序以利後續找出重覆的值，接下來就是不斷的將現有組合做遞回直到找出所有可能為止，與前一題不同的是這次會出現重覆值，所以在開始做遞回後的過程中如果被搭配的陣列長度不為0，要繼繼將目前組合與取出的元素再次做組合之前，如果該元素與前一次取出相同就跳過，待搭配的陣列一樣是重新組合原陣列且不包含取出的自身元素，如此一來便不會出現相同的組合結果，就算陣列元素出現重覆值最後也能找出不重覆的所有組合。 程式碼解說:這邊只解說與先前題目程式碼的相異之處，因為陣列會出現重覆值而且要篩選掉相同的組合，所以一開始就先做排序以利後續找出重覆的值 1234func permuteUnique(nums []int) [][]int &#123; sort.Ints(nums) return recursive([]int&#123;&#125;, nums)&#125; 至於要繼繼將目前組合與取出的元素再次做組合之前，如果該元素的index大於0且與前一次取出的元素相同就跳過，最後一樣待迴圈結束找出所有結果組合才向上回傳 123456789101112131415func recursive(cur []int, nums []int) [][]int &#123; var new []int var tmp [][]int var result [][]int if len(nums) == 0 &#123; ... &#125; for i, v := range nums &#123; if i &gt; 0 &amp;&amp; v == nums[i-1] &#123; continue &#125; ... &#125; return result&#125; 完整程式碼:12345678910111213141516171819202122232425func permuteUnique(nums []int) [][]int &#123; sort.Ints(nums) return recursive([]int&#123;&#125;, nums)&#125;func recursive(cur []int, nums []int) [][]int &#123; var new []int var tmp [][]int var result [][]int if len(nums) == 0 &#123; tmpCur := make([]int, len(cur)) copy(tmpCur, cur) return [][]int&#123;tmpCur&#125; &#125; for i, v := range nums &#123; if i &gt; 0 &amp;&amp; v == nums[i-1] &#123; continue &#125; new = append(new, nums[:i]...) new = append(new, nums[i+1:]...) tmp = recursive(append(cur, v), new) result = append(result, tmp...) new = []int&#123;&#125; &#125; return result&#125; 總結:建議可以先參考先前Permutations的解法，解說較為詳細，基本上概念完全一樣，只是這次陣列會出現重覆值，如果取出的元素與前一次相同就跳過，待搭配的陣列一樣是重新組合原陣列且不包含取出的自身元素，如此一來便不會出現相同的組合結果，就算陣列元素出現重覆值最後也能找出不重覆的所有組合。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Backtracking","slug":"Backtracking","permalink":"https://blog.yunchen.tw/tags/Backtracking/"}]},{"title":"Permutations","slug":"permutations","date":"2017-04-18T16:00:00.000Z","updated":"2017-04-08T05:30:47.000Z","comments":true,"path":"2017/04/19/permutations/","link":"","permalink":"https://blog.yunchen.tw/2017/04/19/permutations/","excerpt":"","text":"PermutationsGiven a collection of distinct numbers, return all possible permutations. For example:[1,2,3] have the following permutations: 12345678[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 提示 解題應用 Backtracking Recursive Default:123func permute(nums []int) [][]int &#123;&#125; 解答思路:這題基本上就是要用遞回來處理以獲得所有組合，重點在於用迴圈從陣列取出元素並要在向下再次遞回前，要將還要用來再次組合的陣列移出目前取出的元素，以避免重覆組合到自身元素，這邊我的做法是重新組合要向下遞回的陣列，也就是該元素之前的所有元素與該元素之後的所有元素重新組合成新的陣列，如此一來在遞回結束後就可以獲得所有想要的組合並且不會重覆出現自身的元素。 程式碼解說:一開始便將值帶入遞回之間以找出所有組合，其中第一個參數陣列為目前陣列的組合，而第二個參數陣列則是要與目前陣列組合搭配出新組合的選項 123func permute(nums []int) [][]int &#123; return recursive([]int&#123;&#125;, nums)&#125; 一開始先判斷如果要被搭配的陣列長度為0，此時就回傳目前現有的陣列組合，這部分是先新增一個空陣列再將目前的組合一一複製過去才回傳，至於為什麼這麼做而不是直接回傳目前的組合，理由與slice的特性有關，最初我也是誤解其特性，所幸stackoverflow有人解答幫助我理解，可以參考Combination Sum in Go，而如果被搭配的陣列不為空，則繼繼將目前組合與要被搭配的陣列再次做組合並放入遞回中，至於新的待搭配陣列則是重新組合原陣列且不包含取出的自身元素，待最後迴圈結束找出所有結果組合才向上回傳 123456789101112131415161718func recursive(cur []int, nums []int) [][]int &#123; var new []int var tmp [][]int var result [][]int if len(nums) == 0 &#123; tmpCur := make([]int, len(cur)) copy(tmpCur, cur) return [][]int&#123;tmpCur&#125; &#125; for i, v := range nums &#123; new = append(new, nums[:i]...) new = append(new, nums[i+1:]...) tmp = recursive(append(cur, v), new) result = append(result, tmp...) new = []int&#123;&#125; &#125; return result&#125; 完整程式碼:123456789101112131415161718192021func permute(nums []int) [][]int &#123; return recursive([]int&#123;&#125;, nums)&#125;func recursive(cur []int, nums []int) [][]int &#123; var new []int var tmp [][]int var result [][]int if len(nums) == 0 &#123; tmpCur := make([]int, len(cur)) copy(tmpCur, cur) return [][]int&#123;tmpCur&#125; &#125; for i, v := range nums &#123; new = append(new, nums[:i]...) new = append(new, nums[i+1:]...) tmp = recursive(append(cur, v), new) result = append(result, tmp...) new = []int&#123;&#125; &#125; return result&#125; 總結:給一陣列其元素間不會出現重覆值，找出元素值在不同位置上的所有組合，而基本上就是要用遞回來處理以獲得所有組合，重點在於用迴圈從陣列取出元素並要在向下再次遞回前，要將還要用來再次組合的陣列移出目前取出的元素，以避免重覆組合到自身元素，這邊我的做法是重新組合要向下遞回的陣列，也就是該元素之前的所有元素與該元素之後的所有元素重新組合成新的陣列，如此一來在遞回結束後就可以獲得所有想要的組合並且不會重覆出現自身的元素。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Backtracking","slug":"Backtracking","permalink":"https://blog.yunchen.tw/tags/Backtracking/"}]},{"title":"Multiply Strings","slug":"multiply-strings","date":"2017-04-17T16:00:00.000Z","updated":"2017-04-07T10:49:08.000Z","comments":true,"path":"2017/04/18/multiply-strings/","link":"","permalink":"https://blog.yunchen.tw/2017/04/18/multiply-strings/","excerpt":"","text":"Multiply StringsGiven two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2. Note: The length of both num1 and num2 is &lt; 110. Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero. You must not use any built-in BigInteger library or convert the inputs to integer directly. 提示 解題應用 Math 規律觀查 String ASCII Default:123func multiply(num1 string, num2 string) string &#123;&#125; 解答思路:原本思考是否能與做Add String時一樣，每一位數的結果值可以透過直接計算來獲得，也許可以但畢竟乘法較為複雜需要考慮到太多細節，所以倒不如就紀錄每一位數與另一個值相乘的總合，再將所有總合做相加(其實就是一般在算乘法的做法)，最後才將總合結果的每一位數轉成字串後回傳。 程式碼解說:一開始先判斷給予的兩數字字串如果任一為”0”就直接回傳字串為”0”的結果，接著才開始準備相乘的工作，你可以用二維陣列來儲存每一位數與另一個值相乘的總合，不過這邊我只有一維陣列來做儲存，因為最後都會要將所有總合做相加，所以倒不如一開始每算完一組總合就直接相加，如此一來也省下不少空間，而陣列初始化長度要多少，透過觀查可以發現兩數字相乘的結果長度不會超過兩數字長度相加，所以就將兩數字長度相加做為結果的最大長度，接著便開始將每一位數與另一個值(該值的每一位數)相乘，記得在取出每一位數時要先將該字元轉為數字的ascii才開始相乘，加上原本該位數的值再與10取餘數最後才放回該位數的位置，這邊要注意的是pos表示要存放的位置，而mov則是因應每一位數會差上10倍，所以每組結果在做存儲時都要記得位移，最後在該位數與另一個值相乘結束前，因為剩餘的值可能表示有進位，因此還要再將剩餘的值加到該位數，結束後才把暫存值歸0以開始計算下一位數 1234567891011121314151617181920if num1 == \"0\" || num2 == \"0\" &#123; return \"0\"&#125;var sum intvar pos intvar mov intvar result stringdata := make([]int, len(num1)+len(num2))for i := len(num1) - 1; i &gt;= 0; i-- &#123; pos = len(num1) + len(num2) - 1 for j := len(num2) - 1; j &gt;= 0; j-- &#123; sum += int(num1[i]-48)*int(num2[j]-48) + data[pos-mov] data[pos-mov] = sum % 10 sum /= 10 pos-- &#125; data[pos-mov] += sum sum = 0 mov++&#125; 最後得到陣列的每一元素就是結果值的每一位數，此時便開始一一將每一位數字轉成字串，如果陣列的第一個值為0，表示沒有進位就不需要放入結果之中所以跳過，其餘的位數就是將數字轉成數字的ascii值再強制轉成字串放入結果字串中，最後待每一位數處理完畢後才做回傳 1234567for i, v := range data &#123; if i == 0 &amp;&amp; v == 0 &#123; continue &#125; result += string(v + 48)&#125;return result 完整程式碼:123456789101112131415161718192021222324252627282930func multiply(num1 string, num2 string) string &#123; if num1 == \"0\" || num2 == \"0\" &#123; return \"0\" &#125; var sum int var pos int var mov int var result string data := make([]int, len(num1)+len(num2)) for i := len(num1) - 1; i &gt;= 0; i-- &#123; pos = len(num1) + len(num2) - 1 for j := len(num2) - 1; j &gt;= 0; j-- &#123; sum += int(num1[i]-48)*int(num2[j]-48) + data[pos-mov] data[pos-mov] = sum % 10 sum /= 10 pos-- &#125; data[pos-mov] += sum sum = 0 mov++ &#125; for i, v := range data &#123; if i == 0 &amp;&amp; v == 0 &#123; continue &#125; result += string(v + 48) &#125; return result&#125; 總結:給兩數字字串要回傳兩相乘之後的結果字串，做法如果一般在算乘法的做法，紀錄每一位數與另一個值相乘的總合，再將所有總合做相加，最後才將總合結果的每一位數轉成字串後回傳。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"Combination Sum II","slug":"combination-sum-II","date":"2017-04-16T16:00:00.000Z","updated":"2017-04-17T08:21:45.000Z","comments":true,"path":"2017/04/17/combination-sum-II/","link":"","permalink":"https://blog.yunchen.tw/2017/04/17/combination-sum-II/","excerpt":"","text":"Combination Sum IIGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. Each number in C may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example:12345678Given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 提示 解題應用 Array Array/Slice Backtracking Recursive Default:123func combinationSum2(candidates []int, target int) [][]int &#123;&#125; 解答思路:建議可以先參考先前Combination Sum的解法，解說較為詳細，基本上概念完全一樣，只是將先前題的程式碼稍做修改而已，如果在陣列元素不重覆的情況下可以找出目標值總合的所有組合，當然出現陣列元素會重覆的可能要篩選掉相同的組合就簡單多了。 一開始一樣先做排序以減少不必要的組合，接下來就是不斷的將現有組合做遞回直到找出所有可能為止，與前一題不同的是這次會出現重覆值，而且每個值最多只能取一次不行再取自身的值，所以在開始做遞回後的過程中如果現階段的總合比目標值小，要繼繼將目前組合與取出的元素再次做組合之前，如果該元素與前一次取出相同就跳過，如此一來便不會再出現相同的組合結果，就算陣列元素出現重覆值最後也能找出不重覆為目標值總合的所有組合。 程式碼解說:這邊只解說與先前題目程式碼的相異之處，如果總合比目標值小要繼繼將目前組合與取出的元素再次做組合之前，如果該元素的index大於0且與前一次取出的元素相同就跳過，並再為下一次遞回做準備而帶入參數時，注意這次待被組合的元素陣列candidates要從下一個元素開始，因為這次每個值最多只能取一次不行再取自身的值，最後一樣待找出所有組合才再次向上回傳結果 12345678910111213141516func combine(sum int, target int, curComb []int, candidates []int) [][]int &#123; var tmp [][]int var result [][]int if sum == target &#123; ... &#125; else if sum &lt; target &#123; for i, v := range candidates &#123; if i &gt; 0 &amp;&amp; v == candidates[i-1] &#123; continue &#125; tmp = combine(sum+v, target, append(curComb, v), candidates[i+1:]) result = append(result, tmp...) &#125; &#125; return result&#125; 完整程式碼:12345678910111213141516171819202122func combinationSum2(candidates []int, target int) [][]int &#123; sort.Ints(candidates) return combine(0, target, []int&#123;&#125;, candidates)&#125;func combine(sum int, target int, curComb []int, candidates []int) [][]int &#123; var tmp [][]int var result [][]int if sum == target &#123; tmpCurComb := make([]int, len(curComb)) copy(tmpCurComb, curComb) return [][]int&#123;tmpCurComb&#125; &#125; else if sum &lt; target &#123; for i, v := range candidates &#123; if i &gt; 0 &amp;&amp; v == candidates[i-1] &#123; continue &#125; tmp = combine(sum+v, target, append(curComb, v), candidates[i+1:]) result = append(result, tmp...) &#125; &#125; return result&#125; 總結:建議可以先參考先前Combination Sum的解法，解說較為詳細，基本上概念完全一樣，只是這次會出現重覆值，而且每個值最多只能取一次不行再取自身的值，所以如果取出的元素與前一次相同就跳過，如此一來便不會再出現相同的組合結果，就算陣列元素出現重覆值最後也能找出不重覆為目標值總合的所有組合。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"Backtracking","slug":"Backtracking","permalink":"https://blog.yunchen.tw/tags/Backtracking/"}]},{"title":"Combination Sum","slug":"combination-sum","date":"2017-04-15T16:00:00.000Z","updated":"2017-04-05T15:24:29.000Z","comments":true,"path":"2017/04/16/combination-sum/","link":"","permalink":"https://blog.yunchen.tw/2017/04/16/combination-sum/","excerpt":"","text":"Combination SumGiven a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example:123456Given candidate set [2, 3, 6, 7] and target 7, A solution set is: [ [7], [2, 2, 3]] 提示 解題應用 Array Array/Slice Backtracking Recursive Default:123func combinationSum(candidates []int, target int) [][]int &#123;&#125; 解答思路:從先前解題的經驗來看(2Sum,3Sum…)，通常要找出總合的全部組合是相當複雜的一件事，所以要降低複雜難度的方式就是先將需要被組合的元素陣列做排序，如此一來當加入元素後的總合比目標值大時，就可以不必再去嘗試後頭更大的元素，而因為要被組合的陣列中沒有重覆的值，再加上也沒有規定必須要由多少個值組成總合，因此必須要盡可能將所有長度的組合都試一遍，所以就是不斷的將現有組合做遞回直到找出所有可能為止。 程式碼解說:如先前所提，為了減少不必要的組合，在遞回之前先將需要被組合的元素陣列做排序，完成排序後就將目前的總合(一開始為0)、目標總合、目前的組合(一開始為空)及要被組合的元素陣列帶入function並開始遞回 1234func combinationSum(candidates []int, target int) [][]int &#123; sort.Ints(candidates) return combine(0, target, []int&#123;&#125;, candidates)&#125; 接下來便是遞回內容的重點，如果總合為目標值就將目前的組合回傳，這部分是先新增一個空陣列再將目前的組合一一複製過去才回傳，至於為什麼這麼做而不是直接回傳目前的組合，理由與slice的特性有關，最初我也是誤解其特性，所幸stackoverflow有人解答幫助我理解，可以參考Combination Sum in Go，而如果總合比目標值小則繼繼將目前組合與元素自身及其後頭的元素再次做組合，並將每次得到的回傳放入結果之中，待找出所有組合最後才再次向上回傳，最後如果是總合大於目標值的情況則會回傳一個空的二元陣列 123456789101112131415func combine(sum int, target int, curComb []int, candidates []int) [][]int &#123; var tmp [][]int var result [][]int if sum == target &#123; tmpCurComb := make([]int, len(curComb)) copy(tmpCurComb, curComb) return [][]int&#123;tmpCurComb&#125; &#125; else if sum &lt; target &#123; for i, v := range candidates &#123; tmp = combine(sum+v, target, append(curComb, v), candidates[i:]) result = append(result, tmp...) &#125; &#125; return result&#125; 完整程式碼:12345678910111213141516171819func combinationSum(candidates []int, target int) [][]int &#123; sort.Ints(candidates) return combine(0, target, []int&#123;&#125;, candidates)&#125;func combine(sum int, target int, curComb []int, candidates []int) [][]int &#123; var tmp [][]int var result [][]int if sum == target &#123; tmpCurComb := make([]int, len(curComb)) copy(tmpCurComb, curComb) return [][]int&#123;tmpCurComb&#125; &#125; else if sum &lt; target &#123; for i, v := range candidates &#123; tmp = combine(sum+v, target, append(curComb, v), candidates[i:]) result = append(result, tmp...) &#125; &#125; return result&#125; 總結:一陣列中不包含重覆值，要找出目標總合的所有組合(沒有規定一定要由多少個值組成)，必須要盡可能將所有長度的組合都試一遍，所以就是不斷的將現有組合做遞回直到找出所有可能為止，而為了減少不必要的組合，在遞回之前先將需要被組合的元素陣列做排序，如此一來當加入元素後的總合比目標值大時，就可以不必再去嘗試後頭更大的元素。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"Backtracking","slug":"Backtracking","permalink":"https://blog.yunchen.tw/tags/Backtracking/"}]},{"title":"Search Insert Position","slug":"search-insert-position","date":"2017-04-14T16:00:00.000Z","updated":"2017-04-05T15:24:03.000Z","comments":true,"path":"2017/04/15/search-insert-position/","link":"","permalink":"https://blog.yunchen.tw/2017/04/15/search-insert-position/","excerpt":"","text":"Search Insert PositionGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Here are few examples. 1234[1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0 提示 解題應用 Array Array/Slice BinarySearch BinarySearch Default:123func searchInsert(nums []int, target int) int &#123;&#125; 解答思路:陣列在有序排序的情況下這邊選擇最簡單的二分法來搜尋，如果有找到目標值的話就直接回傳該位置的index，如果該值不在陣列之中，此時先前二分法所找出的最後一個中間值會最接近目標值，當目標值比中間值來得大，就回傳中間值的下一個位置當插入點，反之如果比較小就回傳中間值自身的位置當插入點。 程式碼解說:一開始便是非常標準的二分法搜尋，不斷的取出中間值與目標值做比較直到頭部的位置超過尾巴為止，當中間值小於目標值時，開頭指向的位置就改為中間index+1，而當中間值大於目標值時，尾巴指向的位置則改為中間index-1，中間值與目標值相同就直接回傳其index，最後如果目標值不在陣列之中，先前二分法所找出的最後一個中間值會最接近目標值，當目標值比中間值來得大，就回傳中間值的下一個位置當插入點，反之如果比較小就回傳中間值自身的位置當插入點。 1234567891011121314151617var mid intvar front intrear := len(nums) - 1for front &lt;= rear &#123; mid = (front + rear) / 2 if nums[mid] &lt; target &#123; front = mid + 1 &#125; else if nums[mid] &gt; target &#123; rear = mid - 1 &#125; else &#123; return mid &#125;&#125;if target &gt; nums[mid] &#123; return mid + 1&#125;return mid 完整程式碼:12345678910111213141516171819func searchInsert(nums []int, target int) int &#123; var mid int var front int rear := len(nums) - 1 for front &lt;= rear &#123; mid = (front + rear) / 2 if nums[mid] &lt; target &#123; front = mid + 1 &#125; else if nums[mid] &gt; target &#123; rear = mid - 1 &#125; else &#123; return mid &#125; &#125; if target &gt; nums[mid] &#123; return mid + 1 &#125; return mid&#125; 總結:陣列在有序排序的情況下要找特定值，有的話就回傳該值的index，沒有則回傳該值能插入有序陣列中的位置，這邊選擇最簡單的二分法來搜尋，如果有找到目標值的話就直接回傳該位置的index，如果該值不在陣列之中，此時先前二分法所找出的最後一個中間值會最接近目標值，當目標值比中間值來得大，就回傳中間值的下一個位置當插入點，反之如果比較小就回傳中間值自身的位置當插入點。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://blog.yunchen.tw/tags/BinarySearch/"}]},{"title":"Search for a Range","slug":"search-for-a-range","date":"2017-04-13T16:00:00.000Z","updated":"2017-04-14T15:50:22.000Z","comments":true,"path":"2017/04/14/search-for-a-range/","link":"","permalink":"https://blog.yunchen.tw/2017/04/14/search-for-a-range/","excerpt":"","text":"Search for a RangeGiven an array of integers sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. For example:12Given [5, 7, 7, 8, 8, 10] and target value 8,return [3, 4]. 提示 解題應用 BinarySearch BinarySearch Array Array/Slice Default:123func searchRange(nums []int, target int) []int &#123;&#125; 解答思路:如果給一排序好的陣列要找特定值，最簡單的方式就是用二分法來找出結果，但如果該陣列包含重覆值並且要給的是特定值全部出現的範圍時，此時一樣先利用二分法找出最中間的結果，接下來只要拆成兩塊分成左右兩邊，一邊是開頭到中間-1(當作新的尾巴)，另一邊則是中間+1(當作新的開頭)到尾部，先確定中間-1與中間+1兩個是否也為目標值，才再各別不斷使用二分法來漸漸一邊往左右兩邊推一邊找目標值的位置，直到開頭的位置超過中間-1與中間+1的位置超過尾巴才回傳兩邊最後分別能找出最側邊的目標值位置。 程式碼解說:一開始先判斷傳進來的陣列是否為空，如果是就直接回傳一陣列包含兩個-1的值，而陣列不為空的話再來就是標準的二分法，不斷的找中位數並與目標值做比較，直到開頭超過尾巴的位置才結束，當中位數比目標小時，開頭就指向中間+1，而當中位數比目標大時，尾巴就指向中間-1，如果出現中位數與目標值一樣時，此時就將要回傳陣列的兩個值都改為中間值的index，並分別將中間-1當作左側的尾巴，中間+1當作右側的開頭，以利後續拆成左右兩塊各別找出最側邊的目標值位置 1234567891011121314151617181920212223result := []int&#123;-1, -1&#125;if len(nums) == 0 &#123; return result&#125;var mid intvar midFront intvar midRear intvar front intrear := len(nums) - 1for front &lt;= rear &#123; mid = (front + rear) / 2 if nums[mid] &lt; target &#123; front = mid + 1 &#125; else if nums[mid] &gt; target &#123; rear = mid - 1 &#125; else &#123; result[0] = mid result[1] = mid midFront = mid + 1 midRear = mid - 1 break &#125;&#125; 接下來先處理左側的部分，先注意到如果最右邊的值也就是尾巴(最靠近先前最中間的目標值)，如果不為目標值的話就不需要判斷了，因為其右側的所有值肯定比目標值小，而如果同為目標值才開始不斷做二分法直到開頭的位置大於新的尾巴為止，一樣從開頭與新的尾巴取中間值，如果中間值小於目標則開頭指向中間+1，不過這邊就絕對不會有中間值大於目標值的情況(因為右側最大就是尾巴的目標值)，所以再來只剩中間值是否等於目標值，是的話就將結果的第一個值改為中間值的index，並將中間-1再次作為新的尾巴以往左尋找是否還有最左邊的目標值位置 123456789101112for front &lt;= midRear &amp;&amp; nums[midRear] == target &#123; for front &lt;= midRear &#123; mid = (front + midRear) / 2 if nums[mid] &lt; target &#123; front = mid + 1 &#125; else &#123; result[0] = mid midRear = mid - 1 break &#125; &#125;&#125; 至於右側的部分則與先一段相反，最左邊的值也就是開頭如果不為目標值的話就不需要判斷，而做二分法時也絕對不會有中間值小於目標值的情況(因為左側最小就是開頭的目標值)，其餘的部分與前一段做對照應該就相當好理解了 12345678910111213for midFront &lt;= rear &amp;&amp; nums[midFront] == target &#123; for midFront &lt;= rear &#123; mid = (midFront + rear) / 2 if nums[mid] &gt; target &#123; rear = mid - 1 &#125; else &#123; result[1] = mid midFront = mid + 1 break &#125; &#125;&#125;return result 完整程式碼:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950func searchRange(nums []int, target int) []int &#123; result := []int&#123;-1, -1&#125; if len(nums) == 0 &#123; return result &#125; var mid int var midFront int var midRear int var front int rear := len(nums) - 1 for front &lt;= rear &#123; mid = (front + rear) / 2 if nums[mid] &lt; target &#123; front = mid + 1 &#125; else if nums[mid] &gt; target &#123; rear = mid - 1 &#125; else &#123; result[0] = mid result[1] = mid midFront = mid + 1 midRear = mid - 1 break &#125; &#125; for front &lt;= midRear &amp;&amp; nums[midRear] == target &#123; for front &lt;= midRear &#123; mid = (front + midRear) / 2 if nums[mid] &lt; target &#123; front = mid + 1 &#125; else &#123; result[0] = mid midRear = mid - 1 break &#125; &#125; &#125; for midFront &lt;= rear &amp;&amp; nums[midFront] == target &#123; for midFront &lt;= rear &#123; mid = (midFront + rear) / 2 if nums[mid] &gt; target &#123; rear = mid - 1 &#125; else &#123; result[1] = mid midFront = mid + 1 break &#125; &#125; &#125; return result&#125; 總結:一排序好的陣列包含重覆值並且要找出特定值全部出現的範圍時，此時一樣先利用二分法找出最中間的結果，接下來只要拆成兩塊分成左右兩邊，一邊是開頭到中間-1(當作新的尾巴)，另一邊則是中間+1(當作新的開頭)到尾部，先確定中間-1與中間+1兩個是否也為目標值，才再各別不斷使用二分法來漸漸一邊往左右兩邊推一邊找目標值的位置，直到開頭的位置超過中間-1與中間+1的位置超過尾巴才回傳兩邊最後分別能找出最側邊的目標值位置。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://blog.yunchen.tw/tags/BinarySearch/"}]},{"title":"Search in Rotated Sorted Array","slug":"search-in-rotated-sorted-array","date":"2017-04-12T16:00:00.000Z","updated":"2017-04-05T15:23:49.000Z","comments":true,"path":"2017/04/13/search-in-rotated-sorted-array/","link":"","permalink":"https://blog.yunchen.tw/2017/04/13/search-in-rotated-sorted-array/","excerpt":"","text":"Search in Rotated Sorted ArraySuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. 提示 解題應用 BinarySearch BinarySearch Array Array/Slice Default:123func search(nums []int, target int) int &#123;&#125; 解答思路:如果一陣列是在無序的狀況下要找出特定值的話，當然就直接從頭遍歷到底即可，而如果是有序不論是從小排至大或是大排至小，都可以使用二分法甚至更細的分割演算法(插值、斐波那契等等)來找出目標，不過這題雖然看似有序但是位置卻不太正確，雖然直接以無序的方式來處理也能達到目地，不過這麼一來資料有序的部分就對我們在搜尋上一點幫助也沒有，所以倒不如找出這些有序的資料和正確位置有序相比位移了多少，接著在利用這個位移來邊做二分法等演算法就可以順利找出結果。 程式碼解說:因要資料已經有序但位置不正確的關係，所以一開始就要先找出然正確有序相比位移了多少，而可以選擇找最小值在的位置再與index為0做相減，或是選擇找最大值再與原本最大值的index(長度-1)相減，這邊我們就以找出最小值為主，至於尋找最小值的方式也與二元搜尋脫不了關係，不過中位數比較的值是與最後一個值相比，如果中位數比最後一個值大表示最小值被移動到後頭，此時將開頭指向的index移到中位數的下一個，而如果比最後一個值小(題目有說彼此值不會重覆，故無相等情況)，就將尾巴指向的index移到中位數，記得不是移到中位數的前一個，因為我們要找的最小值也有可能是該中位數，所以也要包含在其中，最後當開頭位置超過尾巴的位置而跳開迴圈時，尾巴位置的值便是我們要的最小值 12345678910111213var low intvar mid intfront := 0rear := len(nums) - 1for front &lt; rear &#123; mid = (front + rear) / 2 if nums[mid] &gt; nums[rear] &#123; front = mid + 1 &#125; else &#123; rear = mid &#125;&#125;low = rear 有了最小值的位置之後與0相減該值其實就等同於位移了多少，這時終於可以開始做二元搜尋，因為二元搜尋只關心中位數與目標值的大小比較，所以要位移的部分就只有中位數，並不需要整個陣列做位移，當找出中位數的位置而要與目標值做比較之前，要先記得暫時位移中位數到正確的位置做比較(直接將index與長度再取餘數就不需擔心index會超出範圍了)，若真正的中位數比目標值小則開頭指向中位數的下一個，而如果真正的中位數比目標值大則將尾巴指向中位數的前一個，最後如果相等便回傳真正中位數的index值，否則不存在於陣列之中回傳-1 123456789101112131415var realMid intfront = 0rear = len(nums) - 1for front &lt;= rear &#123; mid = (front + rear) / 2 realMid = (low + mid) % len(nums) if nums[realMid] &lt; target &#123; front = mid + 1 &#125; else if nums[realMid] &gt; target &#123; rear = mid - 1 &#125; else &#123; return realMid &#125;&#125;return -1 完整程式碼:123456789101112131415161718192021222324252627282930func search(nums []int, target int) int &#123; var low int var mid int var realMid int front := 0 rear := len(nums) - 1 for front &lt; rear &#123; mid = (front + rear) / 2 if nums[mid] &gt; nums[rear] &#123; front = mid + 1 &#125; else &#123; rear = mid &#125; &#125; low = rear front = 0 rear = len(nums) - 1 for front &lt;= rear &#123; mid = (front + rear) / 2 realMid = (low + mid) % len(nums) if nums[realMid] &lt; target &#123; front = mid + 1 &#125; else if nums[realMid] &gt; target &#123; rear = mid - 1 &#125; else &#123; return realMid &#125; &#125; return -1&#125; 總結:陣列中資料有序但是位置卻不正確，因此要從此陣列中找出特定值的話，直接以無序的方式來處理雖然能達到目地，不過這麼一來資料有序的部分就對我們在搜尋上一點幫助也沒有，所以倒不如找出這些有序的資料和正確位置有序相比位移了多少，接著在利用這個位移來邊做二分法等演算法就可以順利找出結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://blog.yunchen.tw/tags/BinarySearch/"}]},{"title":"Next Permutation","slug":"next-permutation","date":"2017-04-11T16:00:00.000Z","updated":"2017-04-05T15:23:40.000Z","comments":true,"path":"2017/04/12/next-permutation/","link":"","permalink":"https://blog.yunchen.tw/2017/04/12/next-permutation/","excerpt":"","text":"Next PermutationImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1231,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 提示 解題應用 Array 規律觀查 Default:123func nextPermutation(nums []int) &#123;&#125; 解答思路:一開始的想法是分成兩種情況來分別處理，一種可以透過位數互換找得到較大值，另一種則是結果本身就已經是最大值了，所以要將其做反轉，結果就是仍得不出其規律(較大值要離原值最近)，如果要找出一種方法來處理所有的情況，就處理極端的最大值來說一定需要反轉，那麼是不是其它情況在找較大值的時候，一邊確認後頭的位數是否已組成最大值，一邊找出最小能組出較大值的位數在哪一位(也就是當下一位數的值比現在位數的值小非為能組成的最大值)，找到該位數時後頭的位數確定已經是最大值，此時再將該位數的值與後頭最大值(個位數的值一定是最小)的每一位數做比較，從個位數開始找出比其大一點的值便與該位數交換位置，最後得到較大的該位數與後頭新組出的最大值，再將後頭的最大值反轉成為最小值，結果與原數相比就會是我們要的較大值。 程式碼解說:因為是從個位數(陣列的最後頭)開始確認後頭是為為最大值，所以就從陣列的最後一個值與前一個值不斷做比較，直到index等於0為止，如果陣列前一個(下一位數字)比目前的值大，表示到下一位數為止是目前能組出的最大值，便將index減1往下一位檢查，而如果出現下一位數的值比現在位數的值小非為能組成的最大值，除了下一位數之外，到現在的位數都已經確定是最大值(個位數的值一定是最小)，再將該位數的值與確定最大值的每一位數做比較(從個位數開始)，如果發現較大的值便與該位數交換位置，接著跳開所有的迴圈，此時便得到較大的該位數與後頭新組出的最大值 12345678910111213141516171819func nextPermutation(nums []int) &#123; var tmp int index := len(nums) - 1 for index &gt; 0 &#123; if nums[index] &gt; nums[index-1] &#123; for i := len(nums) - 1; i &gt; index-1; i-- &#123; if nums[i] &gt; nums[index-1] &#123; tmp = nums[i] nums[i] = nums[index-1] nums[index-1] = tmp break &#125; &#125; break &#125; index-- &#125; ...&#125; 最後則是將所有後頭組出的最大值做反轉成為最小值，只要從頭尾同時開始互換位置並逐漸向內移動，最後當頭的位置比尾的位置大時結束迴圈，便能得到後頭反轉後的最小值，整體的陣列結果就是我們要的較大值了 123456789front := indexrear := len(nums) - 1for front &lt; rear &#123; tmp = nums[front] nums[front] = nums[rear] nums[rear] = tmp front++ rear--&#125; 完整程式碼:123456789101112131415161718192021222324252627func nextPermutation(nums []int) &#123; var tmp int index := len(nums) - 1 for index &gt; 0 &#123; if nums[index] &gt; nums[index-1] &#123; for i := len(nums) - 1; i &gt; index-1; i-- &#123; if nums[i] &gt; nums[index-1] &#123; tmp = nums[i] nums[i] = nums[index-1] nums[index-1] = tmp break &#125; &#125; break &#125; index-- &#125; front := index rear := len(nums) - 1 for front &lt; rear &#123; tmp = nums[front] nums[front] = nums[rear] nums[rear] = tmp front++ rear-- &#125;&#125; 總結:一陣列每個元素皆由0~9所組成，陣列上的位置分別表示一數字的每個位數，利用陣列上的元素組出只比原值稍大一點的結果，其做法是一邊確認後頭的位數是否已組成最大值，一邊找出最小能組出較大值的位數在哪一位(也就是當下一位數的值比現在位數的值小非為能組成的最大值)，找到該位數時後頭的位數確定已經是最大值，此時再將該位數的值與後頭最大值(個位數的值一定是最小)的每一位數做比較，從個位數開始找出比其大一點的值便與該位數交換位置，最後得到較大的該位數與後頭新組出的最大值，再將後頭的最大值反轉成為最小值，結果與原數相比就會是我們要的較大值。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"}]},{"title":"Implement strStr()","slug":"implement-strStr()","date":"2017-04-10T16:00:00.000Z","updated":"2017-04-05T15:23:35.000Z","comments":true,"path":"2017/04/11/implement-strStr()/","link":"","permalink":"https://blog.yunchen.tw/2017/04/11/implement-strStr()/","excerpt":"","text":"Implement strStr()Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. 提示 解題應用 TwoPointers KMP演算法 String 規律觀查 Default:123func strStr(haystack string, needle string) int &#123;&#125; 解答思路:這題是實作c語言中常用到的字串搜尋strStr()，很明顯的就是要我們實作KMP演算法，也就是先將要搜尋的字串轉為前綴的相似表，接著主字串才依這個表來加速比對，由於需要一步步推倒，建議可以看看GO社群中有人整理好關於KMP演算法的文章[TIL] 有關字串搜尋的演算法: KMP，至於KMP的實作你可以參考文章上的範例或者像這邊則是用我自已覺得比較易懂的方式來實作出來。 程式碼解說:一開始要先取得搜尋字串的相似表，接著主字串才依這個表來加速比對，主字串與要搜尋的字串同時遍歷的關係，任一字串到底便結束便利，當主字串的字母與搜尋字串的字母相同則共同往下移，如果要比對的字串在第一個字母就不相同，此時便只位移主字串即可，而如果比對到一半不相同但前綴有相似的部分，就對照相似表將搜尋字串比對到的位置往前移到前綴相似的地方以繼續與主字串那次判斷(主字串便不需回流以加速比對速度)，最後在比對結束後如果搜尋字串的index位置超過範圍(index與長度相同)，表示在主字串中包含了要搜尋字串，主字串在比對完時index的位置與搜尋字串的長度相減，此值就是搜尋字串在主字串的開頭位置並做回傳，否則不包含就回傳-1 12345678910111213141516171819func strStr(haystack string, needle string) int &#123; var i int var j int table := prefix(needle) for i &lt; len(haystack) &amp;&amp; j &lt; len(needle) &#123; if haystack[i] == needle[j] &#123; i++ j++ &#125; else if j == 0 &#123; i++ &#125; else &#123; j = table[j] &#125; &#125; if j == len(needle) &#123; return i - len(needle) &#125; return -1&#125; 這邊則是將需要搜尋的字串轉成前綴相似表，這也是整個KMP演算法最為核心的部分，不過因為需要一步步做推倒才能了解原理，雖然大致上與前段做搜尋比對的部分非常像，但如果想更加理解細節還是建議自行參考程式碼推完一次整個過程 12345678910111213141516171819func prefix(s string) []int &#123; i := 1 j := 0 length := len(s) table := make([]int, length+1) for i &lt; length &#123; if s[i] == s[j] &#123; i++ j++ table[i] = j &#125; else if j == 0 &#123; i++ &#125; else &#123; j = table[j] &#125; &#125; return table&#125; 完整程式碼:1234567891011121314151617181920212223242526272829303132333435363738func strStr(haystack string, needle string) int &#123; var i int var j int table := prefix(needle) for i &lt; len(haystack) &amp;&amp; j &lt; len(needle) &#123; if haystack[i] == needle[j] &#123; i++ j++ &#125; else if j == 0 &#123; i++ &#125; else &#123; j = table[j] &#125; &#125; if j == len(needle) &#123; return i - len(needle) &#125; return -1&#125;func prefix(s string) []int &#123; i := 1 j := 0 length := len(s) table := make([]int, length+1) for i &lt; length &#123; if s[i] == s[j] &#123; i++ j++ table[i] = j &#125; else if j == 0 &#123; i++ &#125; else &#123; j = table[j] &#125; &#125; return table&#125; 總結:要在一字串中找到目標字串的位置，最快的方式就是以KMP演算法來實作。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"}]},{"title":"Generate Parentheses","slug":"generate-parentheses","date":"2017-04-09T16:00:00.000Z","updated":"2017-04-05T15:23:23.000Z","comments":true,"path":"2017/04/10/generate-parentheses/","link":"","permalink":"https://blog.yunchen.tw/2017/04/10/generate-parentheses/","excerpt":"","text":"Generate ParenthesesGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example:Given n = 3, a solution set is: 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 提示 解題應用 Backtracking Recursive String 規律觀查 Default:123func generateParenthesis(n int) []string &#123;&#125; 解答思路:原本直覺是想到要用stack做，不過如果是檢查或是產生另一半對應的話才需要使用，這邊是重頭到尾都是自己產生，所以就可以由判斷來產生合理的結果，藉由遞回的方式來找出所有可能，並且透過計算開口”(“剩餘尚未對應的次數來除去不合理的結果，就可以找到所有正確的組合。 程式碼解說:因為是用遞回來做，所以一開始便代入初始值來開始遞回，透過觀查可以發現不管哪個結果開頭一定都是”(“，至於參數第一個為尚可新增的字串長度，再來則是開口”(“剩餘尚未對應的次數及目前的字串結果 123func generateParenthesis(n int) []string &#123; return parenthesis(n*2-1, 1, \"(\")&#125; 如果可新增的字串長度為0的話，此時就直接將字串包入陣列中做回傳，如果能新增的長度洽好等於開口”(“剩餘尚未對應的次數，表示接下來就一定只能放”)”在後頭，所以就直接用一迴圈將剩餘的”)”補上並直接回傳字串陣列，或者當開口”(“剩餘尚未對應的次數為0時，此時便暫時無法將”)”接在後頭，便只遞回”(“接在結果後頭的情況，而如果不是上述任一情況便各別將”(“與”)”放入結果後頭並做遞回，最後再將兩個得到的字列陣列做合併再往上做回傳 123456789101112131415func parenthesis(n int, open int, str string) []string &#123; if n == 0 &#123; return []string&#123;str&#125; &#125; else if n == open &#123; for i := 1; i &lt;= n; i++ &#123; str += \")\" &#125; return []string&#123;str&#125; &#125; else if open == 0 &#123; return parenthesis(n-1, open+1, str+\"(\") &#125; addOpen := parenthesis(n-1, open+1, str+\"(\") addClose := parenthesis(n-1, open-1, str+\")\") return append(addOpen, addClose...)&#125; 完整程式碼:123456789101112131415161718func generateParenthesis(n int) []string &#123; return parenthesis(n*2-1, 1, \"(\")&#125;func parenthesis(n int, open int, str string) []string &#123; if n == 0 &#123; return []string&#123;str&#125; &#125; else if n == open &#123; for i := 1; i &lt;= n; i++ &#123; str += \")\" &#125; return []string&#123;str&#125; &#125; else if open == 0 &#123; return parenthesis(n-1, open+1, str+\"(\") &#125; addOpen := parenthesis(n-1, open+1, str+\"(\") addClose := parenthesis(n-1, open-1, str+\")\") return append(addOpen, addClose...)&#125; 總結:括弧”(“與”)”代表1組，給予一數字n，列出n組所有可能的括弧組合，只要藉由遞回的方式來找出所有可能，並且透過計算開口”(“剩餘尚未對應的次數來除去不合理的結果，就可以找到所有正確的組合。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"},{"name":"Backtracking","slug":"Backtracking","permalink":"https://blog.yunchen.tw/tags/Backtracking/"}]},{"title":"4Sum","slug":"4Sum","date":"2017-04-08T16:00:00.000Z","updated":"2017-04-06T17:38:53.000Z","comments":true,"path":"2017/04/09/4Sum/","link":"","permalink":"https://blog.yunchen.tw/2017/04/09/4Sum/","excerpt":"","text":"4SumGiven an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. For example:12345678Given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 提示 解題應用 Array 二維陣列 HashTable HashMap TwoPointers 記錄index位置 Default:123func fourSum(nums []int, target int) [][]int &#123;&#125; 解答思路:建議可以先參考先前3Sum的解法，解說較為詳細，基本上概念完全一樣，只是將先前題的程式碼稍做增加而已，如果可以找出三個總合為0的所有組合，當然要再找4Sum或更多就不會差太多。 要從一陣列中找出4個值總合與目標值相同總合的所有組合，一樣先將整個陣列做排序，不過這次是取兩個值才從該元素後頭的陣列找另外兩個對應的所有組合，因為對後面兩個值來說只是藉由排序好的數列以左右兩邊找匹配的剩餘總合，所以只要前面總合沒有重覆的情況，最後兩個自然會找出對應且不重覆的所有組合，至於前面取兩個值的方式，其實和只有一個的取值方式相同，就是取值的同時判斷是否與先前取的值相同，只是這次變成了巢狀迴圈罷了，或者可以用hashmap來儲存前面兩個的總合來看是否出現重覆的情況，畢竟對後面兩個做匹配的來說只要不重覆即可，不過都已經排序了還用hashtable來處理會有點奇怪。 程式碼解說:對照先前3Sum的程式碼，主要只有修改取值的同時判斷是否與先前取的值相同的部分，這次只是外頭再多了一層迴圈做一樣的事，唯一要注意的是因為是取兩個值，所以裡面那層迴圈j初始值為上一層迴圈i值+1，當然j也要比i+1大才能判斷是否與先前取的值相同，最後才是從後頭的陣列找另外兩個對應的所有組合 1234567891011121314var result [][]intsort.Ints(nums)for i, v := range nums &#123; if i &gt; 0 &amp;&amp; v == nums[i-1] &#123; continue &#125; for j := i + 1; j &lt; len(nums); j++ &#123; if j &gt; i+1 &amp;&amp; nums[j] == nums[j-1] &#123; continue &#125; ... &#125;&#125;return result 完整程式碼:1234567891011121314151617181920212223242526272829303132333435363738func fourSum(nums []int, target int) [][]int &#123; var sum int var front int var rear int var result [][]int sort.Ints(nums) for i, v := range nums &#123; if i &gt; 0 &amp;&amp; v == nums[i-1] &#123; continue &#125; for j := i + 1; j &lt; len(nums); j++ &#123; if j &gt; i+1 &amp;&amp; nums[j] == nums[j-1] &#123; continue &#125; front = j + 1 rear = len(nums) - 1 for front &lt; rear &#123; sum = v + nums[j] + nums[front] + nums[rear] if sum == target &#123; result = append(result, []int&#123;v, nums[j], nums[front], nums[rear]&#125;) for front &lt; rear &amp;&amp; nums[front] == nums[front+1] &#123; front++ &#125; for front &lt; rear &amp;&amp; nums[rear] == nums[rear-1] &#123; rear-- &#125; front++ rear-- &#125; else if sum &gt; target &#123; rear-- &#125; else &#123; front++ &#125; &#125; &#125; &#125; return result&#125; 總結:建議可以先參考先前3Sum的解法，解說較為詳細，基本上概念完全一樣。 要從一陣列中找出4個值總合與目標值相同總合的所有組合，一樣先將整個陣列做排序，不過這次是取兩個值才從該元素後頭的陣列找另外兩個對應的所有組合，因為對後面兩個值來說只是藉由排序好的數列以左右兩邊找匹配的剩餘總合，所以只要前面總合沒有重覆的情況，最後兩個自然會找出對應且不重覆的所有組合，至於前面取兩個值的方式，其實和只有一個的取值方式相同，就是取值的同時判斷是否與先前取的值相同，只是這次變成了巢狀迴圈罷了，或者可以用hashmap來儲存前面兩個的總合來看是否出現重覆的情況，畢竟對後面兩個做匹配的來說只要不重覆即可，不過都已經排序了還用hashtable來處理會有點奇怪。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"}]},{"title":"Letter Combinations of a Phone Number","slug":"letter-combinations-of-a-phone-number","date":"2017-04-07T16:00:00.000Z","updated":"2017-04-05T15:23:10.000Z","comments":true,"path":"2017/04/08/letter-combinations-of-a-phone-number/","link":"","permalink":"https://blog.yunchen.tw/2017/04/08/letter-combinations-of-a-phone-number/","excerpt":"","text":"Letter Combinations of a Phone NumberGiven a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. 12Input:Digit string &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. 提示 解題應用 Backtracking Recursive String 規律觀查 Default:123func letterCombinations(digits string) []string &#123;&#125; 解答思路:這題沒有什麼技巧，因為所有的狀況都需要一一列出，唯一要注意的是給予的數字長度都不一定，因此沒辦法單靠超多層的巢狀迴圈來搞定，所以需要一個方式來遍歷並組合所有可能，如果題目是用二元樹也表示，也許可以從葉子節點一個個合併回根部來取得所有情況，不過這邊不是以節點來處理資料，所以就用遞回的方式來將每次組合出的結果往下傳並再次做排列組合，直到所有的號碼都遍歷為止才回傳所有組合出的結果。 程式碼解說:一開始因為需要知道電話上數字與英文字母的對照，因此要將其關係分別存儲至hashmap之中，不過由於數字的參數給的也是字串的型別，所以key值同為字串型別的數字號碼，而value則是對應的英文字母字串，接著便傳入遞回之中，第一個參數是尚未遍歷的數字，第二個則是數字與英文字母的對照表，最後是目前已組合出的所有結果(最初當然為空的字串陣列) 123456789101112func letterCombinations(digits string) []string &#123; phoneNum := make(map[string]string) phoneNum[\"2\"] = \"abc\" phoneNum[\"3\"] = \"def\" phoneNum[\"4\"] = \"ghi\" phoneNum[\"5\"] = \"jkl\" phoneNum[\"6\"] = \"mno\" phoneNum[\"7\"] = \"pqrs\" phoneNum[\"8\"] = \"tuv\" phoneNum[\"9\"] = \"wxyz\" return combine(digits, phoneNum, []string&#123;&#125;)&#125; 接下來便是遞回內容的重頭戲，如果尚未遍歷的數字字串為空，此時表示已經完全遍歷所有數字並找出所有的結果，直接回傳已組合出的所有結果至上層，如果還有數字存在，就再取第一個數字並放入hashmap之中做對照找出對應的字母組，以利接下來從回圈一一取出每個字母來再次做組合，將每字母從rune值轉回字串後，如果已組合出的所有結果為空，表示此為第一個數字才剛始，此時就只要直接將字母一一放入結果之中即可，而如果已組合出的結果存在，就需要將已組合的結果與字母組再次排列組合，這邊是一一取出每個已組合的結果，並將先前字母組中的字母放入已組合的字串後頭，最後再放回結果之中，直到已組合的結果與字母組全部組合完畢，就將已遍歷的第一個數字去除，連同其餘結果帶入參數並再次遞回 123456789101112131415161718192021func combine(digits string, phoneNum map[string]string, ready []string) []string &#123; var str string var result []string if len(digits) == 0 &#123; return ready &#125; digit := string(digits[0]) for _, v := range phoneNum[digit] &#123; str = string(v) if len(ready) == 0 &#123; result = append(result, str) &#125; else &#123; for _, r := range ready &#123; str = r + str result = append(result, str) str = string(v) &#125; &#125; &#125; return combine(digits[1:], phoneNum, result)&#125; 完整程式碼:123456789101112131415161718192021222324252627282930313233func letterCombinations(digits string) []string &#123; phoneNum := make(map[string]string) phoneNum[\"2\"] = \"abc\" phoneNum[\"3\"] = \"def\" phoneNum[\"4\"] = \"ghi\" phoneNum[\"5\"] = \"jkl\" phoneNum[\"6\"] = \"mno\" phoneNum[\"7\"] = \"pqrs\" phoneNum[\"8\"] = \"tuv\" phoneNum[\"9\"] = \"wxyz\" return combine(digits, phoneNum, []string&#123;&#125;)&#125;func combine(digits string, phoneNum map[string]string, ready []string) []string &#123; var str string var result []string if len(digits) == 0 &#123; return ready &#125; digit := string(digits[0]) for _, v := range phoneNum[digit] &#123; str = string(v) if len(ready) == 0 &#123; result = append(result, str) &#125; else &#123; for _, r := range ready &#123; str = r + str result = append(result, str) str = string(v) &#125; &#125; &#125; return combine(digits[1:], phoneNum, result)&#125; 總結:在傳統手機上每個數字也代表數個英文字母與特殊符號，給一串數字找出該數能表示的所有可能，最簡單的方式就是用遞回將每次組合出的結果往下傳並再次做組合，直到所有的號碼都遍歷為止才回傳所有組合出的結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"},{"name":"Backtracking","slug":"Backtracking","permalink":"https://blog.yunchen.tw/tags/Backtracking/"}]},{"title":"3Sum Closest","slug":"3Sum-closest","date":"2017-04-06T16:00:00.000Z","updated":"2017-04-06T17:38:38.000Z","comments":true,"path":"2017/04/07/3Sum-closest/","link":"","permalink":"https://blog.yunchen.tw/2017/04/07/3Sum-closest/","excerpt":"","text":"3Sum ClosestGiven an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. 123For example, given array S = &#123;-1 2 1 -4&#125;, and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 提示 解題應用 Array Array/Slice TwoPointers 記錄index位置 Default:123func threeSumClosest(nums []int, target int) int &#123;&#125; 解答思路:建議可以先參考前一篇3Sum的解法，解說較為詳細，基本上概念完全一樣，只是將先前題的程式碼做刪減及稍作修改而已，如果可以找出三個總合為0的所有組合，當然只是要找與目標值最接近的總合就更加容易。 要從一陣列中找出3個值總合與目標值最接近的總合，一樣先將整個陣列做排序，每取一個就從該元素後頭的陣列找另外兩個對應的所有組合，以左右兩邊開始找起，當最左與最右值再與前面取出的值相加大於目標時，表示總合太大將右側的index向前推一點找比較小的值並重新判斷，此時如果總合與目標值距離小於最小值就取代並紀錄此次總合，又當總合小於目標時表示太小，將左側的index向後推一點找比較大的值並再次判斷，同樣的如果距離小於最小值就取代並紀錄總合，最後如果找到剛好等於目標值的情況就直接回傳總合，否則如果到遍歷結束都沒有相等的結果則回傳最小值。 程式碼解說:對照前一題的程式碼，主要只有修改從後頭的陣列找另外兩個對應所有組合的部分，首先是原本總合要與0相等及與0比較大小的部分都改為目標值target，接著是如果總合與目標值相等，此時就不必再找其它可能，因為肯定與目標值最近，直接回傳總合即可，而如果是總合大於目標值或小於目標值的情況，此時要再判斷總合與目標值的距離是否小於最小值，如果是就將距離取代最小值同時記錄此次的總合，最後如果一直都沒有與目標值相等的情況則回傳所記錄下距離最小的總合 1234567891011121314151617181920front = i + 1rear = len(nums) - 1for front &lt; rear &#123; sum = v + nums[front] + nums[rear] if sum == target &#123; return sum &#125; else if sum &gt; target &#123; if sum-target &lt; min &#123; min = sum - target result = sum &#125; rear-- &#125; else &#123; if target-sum &lt; min &#123; min = target - sum result = sum &#125; front++ &#125;&#125; 完整程式碼:12345678910111213141516171819202122232425262728293031323334func threeSumClosest(nums []int, target int) int &#123; var sum int var front int var rear int var result int min := math.MaxInt32 sort.Ints(nums) for i, v := range nums &#123; if i &gt; 0 &amp;&amp; v == nums[i-1] &#123; continue &#125; front = i + 1 rear = len(nums) - 1 for front &lt; rear &#123; sum = v + nums[front] + nums[rear] if sum == target &#123; return sum &#125; else if sum &gt; target &#123; if sum-target &lt; min &#123; min = sum - target result = sum &#125; rear-- &#125; else &#123; if target-sum &lt; min &#123; min = target - sum result = sum &#125; front++ &#125; &#125; &#125; return result&#125; 總結:可以先參考前一篇3Sum的解法，解說較為詳細，基本上概念完全一樣。 要從一陣列中找出3個值總合與目標值最接近的總合，一樣先將整個陣列做排序，每取一個就從該元素後頭的陣列找另外兩個對應的所有組合，以左右兩邊開始找起，當最左與最右值再與前面取出的值相加大於目標時，表示總合太大將右側的index向前推一點找比較小的值並重新判斷，此時如果總合與目標值距離小於最小值就取代並紀錄此次總合，又當總合小於目標時表示太小，將左側的index向後推一點找比較大的值並再次判斷，同樣的如果距離小於最小值就取代並紀錄總合，最後如果找到剛好等於目標值的情況就直接回傳總合，否則如果到遍歷結束都沒有相等的結果則回傳最小值。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"}]},{"title":"3Sum","slug":"3Sum","date":"2017-04-05T16:00:00.000Z","updated":"2017-04-05T15:22:54.000Z","comments":true,"path":"2017/04/06/3Sum/","link":"","permalink":"https://blog.yunchen.tw/2017/04/06/3Sum/","excerpt":"","text":"3SumGiven an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. For example:1234567Given array S = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 提示 解題應用 Array 二維陣列 TwoPointers 記錄index位置 Default:123func threeSum(nums []int) [][]int &#123;&#125; 解答思路:正如預期暴力法是沒有辦法順利過關，然而要從一陣列中挑出3個總合正好為0的所有結果比起只挑兩個複雜太多，所以為了要讓事情變的簡單些我們就先將整個陣列做排序，接著就是依序來找3個總合，正如先前所說如果只有兩個的總合就簡單多了，因此每取一個就從該元素後頭的陣列找另外兩個對應的所有組合，好比我們拿了第一個元素，接著就從第2個~第n個找另外兩個的所有組合，而拿了第二個元素就從第3個~第n個找另外兩個的所有組合，好處在於事先排序能篩掉重覆的情況，如果拿的第一個元素為-1，第2~n個就會找出與-1對應的所有組合，而如果下一個元素還是-1，此時從第3~n個找出的所有組合，再與先前找的相比不但組合可能較少還有可能完全重覆，因此如果能事先做好排序便能大幅降低解題的難度，至於要從後頭的陣列找另外兩個對應的所有組合，如果是在無序的狀況下可能要用hashmap來找，也因為事先排序完就能同時從後頭陣列左右兩邊開始找起，當後頭陣列的最左與最右值再與前面取出的值相加大於0時，表示總合太大將右側的index向前推一點找比較小的值並重新判斷，又當總合小於0時表示太小，將左側的index向後推一點找比較大的值並再次判斷，最後如果找到剛好等於0的情況就放入結果之中，因為要找出所有可能的組合，此時就將左右兩側的index一起向內推尋找其它可能，直到左側的index比右側大才能確定已經找出所有可能。 程式碼解說:既然知道了先排序可以減少題目不少難度，這邊一開始就用library內建來排序整個陣列，接著便開始取出陣列中的元素，正如先前所說如果下一項的元素與前一項相同不但組合可能較少還有可能完全重覆，因此就要篩出這類的情況，在確保不會有相同的情況後就可以開始找出另外兩個的所有組合(下一段)，待每個不重覆的值都找出所有組合後才回傳結果 123456789101112var sum intvar front intvar rear intvar result [][]intsort.Ints(nums)for i, v := range nums &#123; if i &gt; 0 &amp;&amp; v == nums[i-1] &#123; continue &#125; ...&#125;return result 因為是從該元素後頭的陣列找另外兩個對應的所有組合，且事先排序完就能同時從後頭陣列左右兩邊開始找起，最左邊我們就從取出值的index下一個開始，而最右邊當然就是陣列的最後一個值，一直找到當左邊的位置超過右邊才確定找完該數的所有可能，一開始當然就是先算出取出值與左右兩邊值的總合，如果總合剛好為0就將三數放入結果之中，而因為左右兩邊的值也有可能有連續相同的值，因此如果任一邊與下一項的值相同則向內推直到超出範圍或值不相等為止，最後如果總合大於0表示值太大，此時就將右邊的index向前推並再次判斷，反之如果總合小於0表示值太小則將左邊的index向後推 1234567891011121314151617181920front = i + 1rear = len(nums) - 1for front &lt; rear &#123; sum = v + nums[front] + nums[rear] if sum == 0 &#123; result = append(result, []int&#123;v, nums[front], nums[rear]&#125;) for front &lt; rear &amp;&amp; nums[front] == nums[front+1] &#123; front++ &#125; for front &lt; rear &amp;&amp; nums[rear] == nums[rear-1] &#123; rear-- &#125; front++ rear-- &#125; else if sum &gt; 0 &#123; rear-- &#125; else &#123; front++ &#125;&#125; 完整程式碼:123456789101112131415161718192021222324252627282930313233func threeSum(nums []int) [][]int &#123; var sum int var front int var rear int var result [][]int sort.Ints(nums) for i, v := range nums &#123; if i &gt; 0 &amp;&amp; v == nums[i-1] &#123; continue &#125; front = i + 1 rear = len(nums) - 1 for front &lt; rear &#123; sum = v + nums[front] + nums[rear] if sum == 0 &#123; result = append(result, []int&#123;v, nums[front], nums[rear]&#125;) for front &lt; rear &amp;&amp; nums[front] == nums[front+1] &#123; front++ &#125; for front &lt; rear &amp;&amp; nums[rear] == nums[rear-1] &#123; rear-- &#125; front++ rear-- &#125; else if sum &gt; 0 &#123; rear-- &#125; else &#123; front++ &#125; &#125; &#125; return result&#125; 總結:要從一陣列中找出3個值總合為0的所有結果，要讓事情變的簡單就先將整個陣列做排序，接著每取一個就從該元素後頭的陣列找另外兩個對應的所有組合，好處在於事先排序能篩掉重覆的情況，如果拿的第一個元素為-1，第2~n個就會找出與-1對應的所有組合，而如果下一個元素還是-1，此時從第3~n個找出的所有組合，再與先前找的相比不但組合可能較少還有可能完全重覆，至於要從後頭的陣列找另外兩個對應的所有組合，也因為事先排序完就能同時從後頭陣列左右兩邊開始找起，當後頭陣列的最左與最右值再與前面取出的值相加大於0時，表示總合太大將右側的index向前推一點找比較小的值並重新判斷，又當總合小於0時表示太小，將左側的index向後推一點找比較大的值並再次判斷，最後如果找到剛好等於0的情況就放入結果之中，因為要找出所有可能的組合，此時就將左右兩側的index一起向內推尋找其它可能，直到左側的index比右側大才能確定已經找出所有可能。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"}]},{"title":"Integer to Roman","slug":"integer-to-roman","date":"2017-04-04T16:00:00.000Z","updated":"2017-04-05T15:22:47.000Z","comments":true,"path":"2017/04/05/integer-to-roman/","link":"","permalink":"https://blog.yunchen.tw/2017/04/05/integer-to-roman/","excerpt":"","text":"Integer to RomanGiven an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 提示 解題應用 Math 規律觀查 String 規律觀查 Default:123func intToRoman(num int) string &#123;&#125; 解答思路:建議可以先從之前寫過的Roman to Integer開始看並了解其中的規律，在了解規律的前提下再來解此題會快非常多，總之就是針對每一位數各別處理，再仔細觀查會發現每一位數轉成羅馬符號主要分成四塊，以1~9為例分別是IX(9),V(III)[8~5],IV(4),III(3~1)，只要能掌握這個規則，剩下就只是倍數與對應的符號關係。 程式碼解說:因為要針對每一位數各別處理，將原數與10相除取餘數取得個位數字，接著與100相除取餘數取得十位數字等等，因此最一開始先初始化除數為10，當要向下取得下一位數字時才再將除數乘上10，接著是初始化羅馬符號中會出現的字母與其對應的數字，因為這次我們是要將數字轉為羅馬符號，因此在放入hashmap之中時，key值為數字，而value才是對應的羅馬符號 1234567891011var result stringvar tmp intdiv := 10roman := make(map[int]string)roman[1] = \"I\"roman[5] = \"V\"roman[10] = \"X\"roman[50] = \"L\"roman[100] = \"C\"roman[500] = \"D\"roman[1000] = \"M\" 再來就是正式開始處理我們的數字，當數字歸0時表示處理完畢才回傳結果，否則就將該數與除數相除(初始化為10)分別取得個、十、百等位數的數字，並在取出之後將原數與取出的位數相減，接著才將各位數賦予對應的羅馬數字，稍後會分作四個部分來解說，拿到對應的羅馬數字才將除數乘上10以取得下一位數字 1234567for num &gt; 0 &#123; tmp = num % div num -= tmp ... div *= 10&#125;return result 如果該位數開頭為9(9,90,900)，因為對應的羅馬符號表示是IX(10-1),XC(100-10),CM(1000-100)，正好是我們的(除數)與(除數再除10)，所以就將這兩個值放入hashmap之中找出對應的羅馬符號，注意符號是一個個放入結果值的開頭，所以要從後頭的符號開始放 1234if tmp == 9*(div/10) &#123; result = roman[div] + result result = roman[div/10] + result&#125; 除去\b前述的情況，如果開頭為8~5(8~5,80~50,800~500)，以8為例對應的羅馬符號是VIII(5+1+1+1)，正好是我們的(除數再除2)與(除數再除10)x3，一樣從hashmap之中找出對應的羅馬符號，並且因為從後頭開始放起，所以先以迴圈算出後頭(除數再除10)要放多少個，最後才放(除數再除2) 123456else if tmp &gt;= 5*(div/10) &#123; for i := 1; i &lt;= (tmp-5*(div/10))/(div/10); i++ &#123; result = roman[div/10] + result &#125; result = roman[div/2] + result&#125; 除去\b前述的情況，如果該位數開頭為4(4,40,400)，因為對應的羅馬符號表示是IV(5-1),XL(50-10),CD(500-100)，正好是我們的(除數再除2)與(除數再除10)，所以就將這兩個值放入hashmap之中找出對應的羅馬符號，注意符號是一個個放入結果值的開頭，所以要從後頭的符號開始放 1234else if tmp == 4*(div/10) &#123; result = roman[div/2] + result result = roman[div/10] + result&#125; 除去\b前述的情況，如果開頭為3~1(3~1,30~10,300~100)，以3為例對應的羅馬符號是III(1+1+1)，正好是我們的(除數再除10)x3，一樣從hashmap之中找出對應的羅馬符號，以迴圈算出後頭(除數再除10)要放多少個再一一放入結果開頭 12345else &#123; for i := 1; i &lt;= tmp/(div/10); i++ &#123; result = roman[div/10] + result &#125;&#125; 完整程式碼:1234567891011121314151617181920212223242526272829303132333435func intToRoman(num int) string &#123; var result string var tmp int div := 10 roman := make(map[int]string) roman[1] = \"I\" roman[5] = \"V\" roman[10] = \"X\" roman[50] = \"L\" roman[100] = \"C\" roman[500] = \"D\" roman[1000] = \"M\" for num &gt; 0 &#123; tmp = num % div num -= tmp if tmp == 9*(div/10) &#123; result = roman[div] + result result = roman[div/10] + result &#125; else if tmp &gt;= 5*(div/10) &#123; for i := 1; i &lt;= (tmp-5*(div/10))/(div/10); i++ &#123; result = roman[div/10] + result &#125; result = roman[div/2] + result &#125; else if tmp == 4*(div/10) &#123; result = roman[div/2] + result result = roman[div/10] + result &#125; else &#123; for i := 1; i &lt;= tmp/(div/10); i++ &#123; result = roman[div/10] + result &#125; &#125; div *= 10 &#125; return result&#125; 總結:要將一數字轉為羅馬符號，主要就是針對每一位數各別處理，仔細觀查會發現每一位數轉成羅馬符號主要分成四塊，以1~9為例分別是IX(9),V(III)[8~5],IV(4),III(3~1)，只要能掌握這個規則，剩下就只是倍數與對應的符號關係。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"Container With Most Water","slug":"container-with-most-water","date":"2017-04-03T16:00:00.000Z","updated":"2017-04-05T15:22:40.000Z","comments":true,"path":"2017/04/04/container-with-most-water/","link":"","permalink":"https://blog.yunchen.tw/2017/04/04/container-with-most-water/","excerpt":"","text":"Container With Most WaterGiven n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. 提示 解題應用 Array Array/Slice TwoPointers 紀錄index位置 Default:123func maxArea(height []int) int &#123;&#125; 解答思路:從一陣列中挑兩個隔板，其中index值為隔板放置的位置，其值則為隔板的高度，找出兩個隔板能圍出的最大面積，最初先嘗試使用暴力法而超時，其實只要從分邊從兩邊同時判斷並分別向中間前進尋找即可，在一開始時從最左邊與最右邊拿到隔板，因為此時相距最遠所以圍出來的面積長度當然就最長，剩下的就只有高度的問題，兩個隔板如果不一樣高的話，水當然只能裝到比較矮的地方，在算出長方形面積(隔板間距*較矮的高度)後，之後就要考慮如何向內找隔板才能找出最大值，因為向內會使隔板間距離縮短，所以如果找的不是比較高的隔板就沒意義，此時在最左與最右的兩隔板中，選擇比較矮的那邊往內一格換較內側的隔板，算出面積並比較是否為最大之後就再次重覆上述比較動作，直到找出所有能圍出最大面積的可能。 程式碼解說:一開始先初始化要拿最左右兩側的隔板，接著才開始不斷尋找最大面積直到拿到左側隔板的位置超過右側為止，如果右側隔板的高度比較高，此時先計算面積並從較矮的左側一方，向內找更高的隔板，反之如果是右側較高則右側從右側一方往內找更高的隔板，最後才比較先前找出的面積是否大於最大值，如果是就將其取代，直到找出所有能圍出最大面積的可能才回傳其中的最大值。 123456789101112131415161718192021var max intvar area intleft := 0right := len(height) - 1hl := height[left]hr := height[right]for left &lt; right &#123; if hl &lt; hr &#123; area = hl * (right - left) left++ hl = height[left] &#125; else &#123; area = hr * (right - left) right-- hr = height[right] &#125; if area &gt; max &#123; max = area &#125;&#125;return max 完整程式碼:1234567891011121314151617181920212223func maxArea(height []int) int &#123; var max int var area int left := 0 right := len(height) - 1 hl := height[left] hr := height[right] for left &lt; right &#123; if hl &lt; hr &#123; area = hl * (right - left) left++ hl = height[left] &#125; else &#123; area = hr * (right - left) right-- hr = height[right] &#125; if area &gt; max &#123; max = area &#125; &#125; return max&#125; 總結:從一陣列中挑兩個隔板，其中index值為隔板放置的位置，其值則為隔板的高度，找出兩個隔板能圍出的最大面積，在一開始時從最左邊與最右邊拿到隔板並計算面積，之後在最左與最右的兩隔板中，選擇比較矮的那邊往內一格換較內側的隔板，算出面積並比較是否為最大之後就再次重覆上述比較動作，直到找出所有能圍出最大面積的可能。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"}]},{"title":"Repeated Substring Pattern","slug":"repeated-substring-pattern","date":"2017-04-02T16:00:00.000Z","updated":"2017-04-05T15:22:32.000Z","comments":true,"path":"2017/04/03/repeated-substring-pattern/","link":"","permalink":"https://blog.yunchen.tw/2017/04/03/repeated-substring-pattern/","excerpt":"","text":"Repeated Substring PatternGiven a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000. Example 1:12345Input: &quot;abab&quot;Output: TrueExplanation: It&apos;s the substring &quot;ab&quot; twice. Example 2:123Input: &quot;aba&quot;Output: False Example 3:12345Input: &quot;abcabcabcabc&quot;Output: TrueExplanation: It&apos;s the substring &quot;abc&quot; four times. (And the substring &quot;abcabc&quot; twice.) 提示 解題應用 String KMP演算法 Default:123func repeatedSubstringPattern(s string) bool &#123;&#125; 解答思路:這題一開始想到的便是KMP演算法，雖然有用上KMP演算法最核心的部分，不過其實並不完全是在用該演算法，因為並不是拿來查找字串，而是用來計算後頭的字串與前綴字串的相似程度而已，所以基本上只要這個表出來就差不多完成了，至於實作方式雖然網路上有很多種，但基本上大同小異找自己容易理解的即可。 程式碼解說:最主要是將該字串轉為前綴相似表，而有了該表之後如果此字串是由同一前綴組成，該表最後一個數字就是組成該字串最後一個前綴最大的相似程度(也就是該前綴的長度)，最後只要判斷該數是否大於0(等於0就等於豆是完全不相似)，且【長度】與【長度減上前綴長度】兩數相除等於0就表示由相同前綴組成， 例如: String: abcabcabc(長度9) 最大前綴: abcabc(長度6) 9%(9-6) = 0 (為同一前綴所組成) 123456func repeatedSubstringPattern(s string) bool &#123; length := len(s) table := prefix(s) maxSubStrLen := table[len(table)-1] return maxSubStrLen &gt; 0 &amp;&amp; length%(length-maxSubStrLen) == 0&#125; 至於KMP演算法中的核心部分，也就是將字串轉為前綴的相似表，由於需要一步步推倒，建議可以看看GO社群中有人整理好關於KMP演算法的文章 [TIL] 有關字串搜尋的演算法: KMP 12345678910111213141516171819func prefix(s string) []int &#123; i := 1 j := 0 length := len(s) table := make([]int, length+1) for i &lt; length &#123; if s[i] == s[j] &#123; i++ j++ table[i] = j &#125; else if j == 0 &#123; i++ &#125; else &#123; j = table[j] &#125; &#125; return table&#125; 完整程式碼:12345678910111213141516171819202122232425func repeatedSubstringPattern(s string) bool &#123; length := len(s) table := prefix(s) maxSubStrLen := table[len(table)-1] return maxSubStrLen &gt; 0 &amp;&amp; length%(length-maxSubStrLen) == 0&#125;func prefix(s string) []int &#123; i := 1 j := 0 length := len(s) table := make([]int, length+1) for i &lt; length &#123; if s[i] == s[j] &#123; i++ j++ table[i] = j &#125; else if j == 0 &#123; i++ &#125; else &#123; j = table[j] &#125; &#125; return table&#125; 總結:要判斷一字串中是否由相同的前綴字所組成，最快的方式就是利用KMP演算法中計算前綴字的相似程度，有了該相似表如果都是由同一前綴字所組成就可以找出該同綴字，進而判斷字串是否由相同的前綴字所組成。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"}]},{"title":"Longest Palindromic Substring","slug":"longest-palindromic-substring","date":"2017-04-01T16:00:00.000Z","updated":"2017-04-05T15:22:13.000Z","comments":true,"path":"2017/04/02/longest-palindromic-substring/","link":"","permalink":"https://blog.yunchen.tw/2017/04/02/longest-palindromic-substring/","excerpt":"","text":"Longest Palindromic SubstringGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1:12345Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2:123Input: &quot;cbbd&quot;Output: &quot;bb&quot; 提示 解題應用 String 規律觀查 Default:123func longestPalindrome(s string) string &#123;&#125; 解答思路:這題總共分為兩種作法，一種是從最長的字串並慢慢縮減開始找，如下: 此方法主要是以長度為主開始找，若該長度沒有回文字串存在則將長度-1，miss就是拿來控制長度的參數，接著就是不斷的在字串上一邊位移，一邊確認此長度的字串是否為回文，如果為回文就直接回傳結果 1234567891011121314151617181920212223242526func longestPalindrome(s string) string &#123; for miss := 0; miss &lt; len(s); miss++ &#123; for i := 0; i &lt;= miss; i++ &#123; if isPalidrome(s[i : i+len(s)-miss]) &#123; return s[i : i+len(s)-miss] &#125; &#125; &#125; return s&#125;func isPalidrome(s string) bool &#123; var strFront string var strRear string front := 0 rear := len(s) - 1 for front &lt; rear &#123; strFront = string(s[front]) strRear = string(s[rear]) if strFront != strRear &#123; return false &#125; front++ rear-- &#125; return true&#125; 不過此方式在最後一個測資被刁專而導致超時，不過我認為這也是一種方式，原因在於若回文的字串都比較長的情況下這種方式反而比較適合，所以就端看碰上何種資料而採取何種辦法了 而另一種是從最短的字串並慢慢增加開始找，這也是這題最主要的解法，當然如果是從最短慢慢開始加那麼又會有兩種情況，因為回文有可能是完全對稱，或者是只有最中間一個任意值其餘才是兩兩對稱，所以說如果要一邊移動重置再一邊慢慢增加就還需要考慮到上述兩種情況，剩下的就只是檢查值是否對稱及index位置是否超出範圍等問題而已 程式碼解說:一開始如果給予的字串為空或者只有一個字元就直接回傳整個字串，如果不是上述情況才開始遍歷整個字串，因為有完全對稱與最中間一個任意值其餘才是兩兩對稱的兩種情況，所以我們將前者稱為偶數的情況而後者則為奇數(已長度來區分)，因為慢慢增加字元是從左右兩邊同時增加，奇數的情況就從同一個位置往左右兩邊向外移動，偶數的情況則是從相鄰的兩個位置同時向外移動，如果奇數或偶數回傳的字串比結果大就取代，接著一邊移動重置再從頭慢慢增加，直到字串遍歷結束才回傳結果值 12345678910111213141516171819func longestPalindrome(s string) string &#123; var odd string var even string var result string if len(s) &lt;= 1 &#123; return s &#125; for i, _ := range s &#123; odd = extendPalindrome(s, i, i) even = extendPalindrome(s, i, i+1) if len(odd) &gt; len(result) &#123; result = odd &#125; if len(even) &gt; len(result) &#123; result = even &#125; &#125; return result&#125; 這部分則是左右向外增加字元並同時檢查是否回文，而如果是奇數的情況因為是從同一個位置出發，所以一開始左右位置的字元必定相同，接下來才與偶數的情況一樣，檢查左邊index是否大於0，右邊index是否超出字串長度，最後才是檢查左右兩邊的值是否相同，如果相同則左右兩邊繼續向外擴充以找到更長的回文，當左或右任一邊已經超出index的範圍而跳出回圈時，最後記得要將左右兩邊的index值同時縮一點回去才回傳結果 123456789func extendPalindrome(s string, left int, right int) string &#123; for left &gt;= 0 &amp;&amp; right &lt; len(s) &amp;&amp; s[left] == s[right] &#123; left-- right++ &#125; left++ right-- return s[left : right+1]&#125; 完整程式碼:12345678910111213141516171819202122232425262728func longestPalindrome(s string) string &#123; var odd string var even string var result string if len(s) &lt;= 1 &#123; return s &#125; for i, _ := range s &#123; odd = extendPalindrome(s, i, i) even = extendPalindrome(s, i, i+1) if len(odd) &gt; len(result) &#123; result = odd &#125; if len(even) &gt; len(result) &#123; result = even &#125; &#125; return result&#125;func extendPalindrome(s string, left int, right int) string &#123; for left &gt;= 0 &amp;&amp; right &lt; len(s) &amp;&amp; s[left] == s[right] &#123; left-- right++ &#125; left++ right-- return s[left : right+1]&#125; 總結:要找出一字串中的子回文字串共有兩種方法，一種是從最長的字串並慢慢縮減開始找，一邊位移一邊確認此長度的字串是否為回文，而另一種則是從最短的字串並慢慢增加開始找，一邊移動重置再一邊慢慢增加且要注意有完全對稱與最中間一個任意值其餘才是兩兩對稱的兩種情況。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"}]},{"title":"Longest Substring Without Repeating Characters","slug":"longest-substring-without-repeating-characters","date":"2017-03-31T16:00:00.000Z","updated":"2017-04-05T15:22:04.000Z","comments":true,"path":"2017/04/01/longest-substring-without-repeating-characters/","link":"","permalink":"https://blog.yunchen.tw/2017/04/01/longest-substring-without-repeating-characters/","excerpt":"","text":"Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters. For Examples:12345Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3.Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1.Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 提示 解題應用 HashTable HashMap TwoPointers Index位置記錄 String 規律觀查 Default:123func lengthOfLongestSubstring(s string) int &#123;&#125; 解答思路:因為需要知道已經出現了哪些字母，所以在一邊遍歷的同時，一邊要將字母儲存至hashmap之中，其中key值為該字母而value則隨意，同時要標註目前所找的長度字串頭與尾的字串位置，在往後遍歷時(標註的尾向往移)如果該字母已經在hashmap之中，此時就不斷將標註的頭往後移，並將原本在頭位置放入hashmap中的值給移除，直到先前尾巴遍歷的值放入hashmap之中不再出現重覆的狀況，此時才能放心的將尾部向後移動，而當尾部順利向後移動時，比較hashmap的大小或尾減去頭的長度與最大值做比較，如果比較大就取代，直到最後遍歷結束後才回傳最大值。 程式碼解說:一開始先初始化一hashmap，其中key值為該字母而value則隨意(這邊也是放該字母)，接著便開始遍歷字串，如果目前遍歷的值(以rear尾部為主)已存在於hashmap之中，此時就將front頭部位置原本存放在hashmap中的值給移除，移除後才將front向後移動，直到rear遍歷到的值不再出現重覆的狀況，此時才將該值再次放入hashmap之中，並計算hashmap的長度是否大於目前找到最大字串的長度，如果是就取代最大值，直到最後遍歷結束後才回傳最大值 12345678910111213141516171819202122var max intvar front intvar rear intvar strFront stringvar strRear stringhashMap := make(map[string]string)for rear &lt; len(s) &#123; strFront = string(s[front]) strRear = string(s[rear]) _, exist := hashMap[strRear] if exist &#123; delete(hashMap, strFront) front++ &#125; else &#123; hashMap[strRear] = strRear rear++ if len(hashMap) &gt; max &#123; max = len(hashMap) &#125; &#125;&#125;return max 完整程式碼:123456789101112131415161718192021222324func lengthOfLongestSubstring(s string) int &#123; var max int var front int var rear int var strFront string var strRear string hashMap := make(map[string]string) for rear &lt; len(s) &#123; strFront = string(s[front]) strRear = string(s[rear]) _, exist := hashMap[strRear] if exist &#123; delete(hashMap, strFront) front++ &#125; else &#123; hashMap[strRear] = strRear rear++ if len(hashMap) &gt; max &#123; max = len(hashMap) &#125; &#125; &#125; return max&#125; 總結:要從一字串中找出完全不重覆子字串的最大長度，一邊遍歷的同時，一邊要將字母儲存至hashmap之中，其中key值為該字母而value則隨意，同時要標註目前所找的長度字串頭與尾的字串位置，在往後遍歷時(標註的尾向往移)如果該字母已經在hashmap之中，此時就不斷將標註的頭往後移，並將原本在頭位置放入hashmap中的值給移除，直到先前尾巴遍歷的值放入hashmap之中不再出現重覆的狀況，此時才能放心的將尾部向後移動，而當尾部順利向後移動時，比較hashmap的大小或尾減去頭的長度與最大值做比較，如果比較大就取代，直到最後遍歷結束後才回傳最大值。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"}]},{"title":"Add Two Numbers","slug":"add-two-numbers","date":"2017-03-30T16:00:00.000Z","updated":"2017-04-05T15:21:53.000Z","comments":true,"path":"2017/03/31/add-two-numbers/","link":"","permalink":"https://blog.yunchen.tw/2017/03/31/add-two-numbers/","excerpt":"","text":"Add Two NumbersYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. For Example:12Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 提示 解題應用 LinkedList Pointer Math 規律觀查 Default:12345678910/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123;&#125; 解答思路:一開始本來是分別遍歷兩個LinkedList，在各別算出兩個數字做總合，最後才生成新的LinkedList做回傳，不過因為LinkedList會極長就沒辦法這樣搞，而且這樣也太浪費時間，所以就是同時一起對兩個LinkedList做遍歷，並將結果取代其一LinkedList的值，如果兩節點做總合時有進位的情況，就將進位的數字加到下一組做節點總合，又如果有其中一方的LinkedList較短先結束，這時就將另一方尚未遍歷完成的LinkedList接在其後頭，此時只要繼續判斷是否要進位到下一個節點即可，沒有的話就可以直接回傳整個合併的LinkedList，有的話才進到下一個節點並+1再次做判斷，最後若已經遍歷結果了，然而仍需進位的情況發生，這時就要在最後自行新增一個新的節點在LinkedList的最後頭，而其值當然必為1。 程式碼解說:因為我們是將總合的結果值取代原本的節點值，而且也是回傳原本的LinkedList回去，所以一開始我們就以第一個LinkedList為主，並記錄其第一個節點的位置用以結果回傳，接下來就開始同時遍歷兩個LinkedList的節點，其中任一LinkedList先為nil才停止遍歷，一邊遍歷兩LinkedList的同時，一邊將分別將兩個節點值做總合，並將總合的結果除以10取於餘數並取代第一個LinkedList節點的值，至先前除完的商如果大於0(有進位)自然就會繼續往下一組節點的總合做累加，完成之後才又同時將兩LinkedList遍歷的節點下移，不過在此之前要先暫存第一個LinkedList遍歷完的位置，因為如果是該LinkedList先結束而稍後就需要將另一尚未遍歷過LinkedList的後半部給嫁接在後頭，此時就需要知道先前遍歷完的最後一個節點位置才有辦法進行嫁接 1234567891011var sum intvar tmp *ListNoderesult := l1for l1 != nil &amp;&amp; l2 != nil &#123; sum += l1.Val + l2.Val l1.Val = sum % 10 sum /= 10 tmp = l1 l1 = l1.Next l2 = l2.Next&#125; 如果是第一個LinkedList不為nil，那麼就沒有問題可以直接繼續遍歷，因為我們就是以第一個LinkedList為主，但如果是第二個LinkedList不為nil，表示第一個LinkedList已經遍歷完了，這時就要將前一步暫存l1的最後一個節點位置與l2尚位遍歷的節點先做嫁接，在嫁接結束後剩下的部分不管前述哪種情況都是處理進位與尚未遍歷過部分的關係，如果合併後的LinkedList不為nil且進位值大於0則繼續往下一個節點的值累加，與先前類似將總合與節點值相加，接著將總合與10取餘數取代節點值，最後如果商大於0才往下累加，這次也一樣需要先暫存最後一個節點的位置才往下移動 123456789101112131415161718if l1 != nil &#123; for l1 != nil &amp;&amp; sum &gt; 0 &#123; sum += l1.Val l1.Val = sum % 10 sum /= 10 tmp = l1 l1 = l1.Next &#125;&#125; else if l2 != nil &#123; tmp.Next = l2 for l2 != nil &amp;&amp; sum &gt; 0 &#123; sum += l2.Val l2.Val = sum % 10 sum /= 10 tmp = l2 l2 = l2.Next &#125;&#125; 如果所有節點都遍歷結束，然而總合的值仍大於0表示還有進位，這時就需要自行新增一個新的節點其值為1到整個LinkedList的最後頭，最後才將整串節點也就是在最一開始所存第一個LinkedList的第一個節點位置給回傳 1234if sum &gt; 0 &#123; tmp.Next = &amp;ListNode&#123;1, nil&#125;&#125;return result 完整程式碼:1234567891011121314151617181920212223242526272829303132333435func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode &#123; var sum int var tmp *ListNode result := l1 for l1 != nil &amp;&amp; l2 != nil &#123; sum += l1.Val + l2.Val l1.Val = sum % 10 sum /= 10 tmp = l1 l1 = l1.Next l2 = l2.Next &#125; if l1 != nil &#123; for l1 != nil &amp;&amp; sum &gt; 0 &#123; sum += l1.Val l1.Val = sum % 10 sum /= 10 tmp = l1 l1 = l1.Next &#125; &#125; else if l2 != nil &#123; tmp.Next = l2 for l2 != nil &amp;&amp; sum &gt; 0 &#123; sum += l2.Val l2.Val = sum % 10 sum /= 10 tmp = l2 l2 = l2.Next &#125; &#125; if sum &gt; 0 &#123; tmp.Next = &amp;ListNode&#123;1, nil&#125; &#125; return result&#125; 總結:給予兩個LinkedList，其中同個LinkedList每個節點值表示數字的每一進位，並需要將此兩LinkedList表示的數字做總合，且也要回傳一個LinkedList，最佳的做法就是同時一起對兩個LinkedList做遍歷，並將結果取代其一LinkedList的值，如果兩節點做總合時有進位的情況，就將進位的數字加到下一組做節點總合，又如果有其中一方的LinkedList較短先結束，這時就將另一方尚未遍歷完成的LinkedList接在其後頭，此時只要繼續判斷是否要進位到下一個節點即可，沒有的話就可以直接回傳整個合併的LinkedList，有的話才進到下一個節點並+1再次做判斷，最後若已經遍歷結果了，然而仍需進位的情況發生，這時就要在最後自行新增一個新的節點在LinkedList的最後頭，而其值當然必為1。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://blog.yunchen.tw/tags/LinkedList/"}]},{"title":"Reverse String II","slug":"reverse-string II","date":"2017-03-29T16:00:00.000Z","updated":"2017-04-05T15:21:47.000Z","comments":true,"path":"2017/03/30/reverse-string II/","link":"","permalink":"https://blog.yunchen.tw/2017/03/30/reverse-string II/","excerpt":"","text":"Reverse String IIGiven a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original. For Example:12Input: s = &quot;abcdefg&quot;, k = 2Output: &quot;bacdfeg&quot; Restrictions: The string consists of lower English letters only. Length of the given string and k will in the range [1, 10000] 提示 解題應用 String 規律觀查 Default:123func reverseStr(s string, k int) string &#123;&#125; 解答思路:這題主要是做字串上規律的觀查，字串中前k個字做倒轉，下一組k個字就不需要，而再下一組k就再做倒轉，換句話說就是如果以一組一組來看的話index值除以k如果商數為0就在第一組，商數為1就在第二組，商數為2就在第三組，這麼說只要商數為偶數該字母就必然是歸類於做倒轉的字串，在得知這樣規則的前提下就可以沒有壓力的解決問題。 程式碼解說:一開始從字串一一取出字母，正如先前有的結論，將index值除以k先知道落在哪一組，再將商數與2相除取餘數，如果餘數為0表示商數為偶數要做倒轉，這時就將倒轉註記為true，否則餘數為1的情況則註記為false，再將先前已經暫存倒轉的字串加入結果之中並清空暫存，而再決定好是否倒轉後就要開始處理每個字母，因為golang取出字母為rune值所以要先轉成字串再開始動作，接著如果該字母需要倒轉，就存在暫存字串的開頭，待所有該組字母皆倒轉完畢(在先前的判斷倒轉註記為false)才整組放入結果，而如果該字母不需要倒轉，則直則依序放入結果後頭即可，最後待遍歷字串結束後，因為有可能暫存字串還留有尚未放入結果的字元，所以最後要再一次將暫存字串放入結果後頭之中才做回傳 123456789101112131415161718192021var str stringvar tmp stringvar result stringvar reverse boolfor i, v := range s &#123; if (i/k)%2 == 0 &#123; reverse = true &#125; else &#123; reverse = false result += tmp tmp = \"\" &#125; str = string(v) if reverse &#123; tmp = str + tmp &#125; else &#123; result += str &#125;&#125;result += tmpreturn result 完整程式碼:1234567891011121314151617181920212223func reverseStr(s string, k int) string &#123; var str string var tmp string var result string var reverse bool for i, v := range s &#123; if (i/k)%2 == 0 &#123; reverse = true &#125; else &#123; reverse = false result += tmp tmp = \"\" &#125; str = string(v) if reverse &#123; tmp = str + tmp &#125; else &#123; result += str &#125; &#125; result += tmp return result&#125; 總結:要將一字串中前k個字做倒轉，下一組k個字就不需要，而再下一組k就再做倒轉…等等以此類推，如果以一組一組來看的話index值除以k如果商數為0就在第一組，商數為1就在第二組，商數為2就在第三組，這麼說只要商數為偶數該字母就必然是歸類於做倒轉的字串，在得知這樣規則的前提下就可以沒有壓力的解決問題。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"}]},{"title":"K-diff Pairs in an Array","slug":"K-diff-pairs-in-an-array","date":"2017-03-28T16:00:00.000Z","updated":"2017-04-05T15:21:25.000Z","comments":true,"path":"2017/03/29/K-diff-pairs-in-an-array/","link":"","permalink":"https://blog.yunchen.tw/2017/03/29/K-diff-pairs-in-an-array/","excerpt":"","text":"K-diff Pairs in an ArrayGiven an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k. Example 1:1234Input: [3, 1, 4, 1, 5], k = 2Output: 2Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs. Example 2:123Input:[1, 2, 3, 4, 5], k = 1Output: 4Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5). Example 3:123Input: [1, 3, 1, 5, 4], k = 0Output: 1Explanation: There is one 0-diff pair in the array, (1, 1). Note: The pairs (i, j) and (j, i) count as the same pair. The length of the array won’t exceed 10,000. All the integers in the given input belong to the range: [-1e7, 1e7]. 提示 解題應用 TwoPointers 巢狀回圈 Array Array/Slice Default:123func findPairs(nums []int, k int) int &#123;&#125; 解答思路:這邊要從一陣列中找任兩值距離為k的共有幾組，最簡單的方式就是用巢狀迴圈都從同一陣列來取資料並兩兩比較，因為(x, y)與(y, x)這種組合只算一種，換句話說只存兩值相減距離為正數(也就是k)的結果就行了，所以當兩個值並非陣列中的相同index且相減為正數就儲至hashmap之中，最後直接回傳hashmap長度即可，至於為什麼是存在hashmap中而非直接計數，原因在於兩相同的值就會只被算到一次(key值一樣)。 程式碼解說:一開始先判斷k是否為負數，如果是就直接回傳0，接下來就初始化一hashmap，其中key值為陣列中某一個元素儲存的值而value則是另一個陣列中對應的值，接著便是用巢狀迴圈都從同一陣列來取資料，如果分別取出的值並非陣列中的同一個位置(index)，且兩值相減為k就存儲至hashmap之中，key與value則分別對應兩個取出的值，最後回傳hashmap的長度就會是結果 123456789101112if k &lt; 0 &#123; return 0&#125;hashMap := make(map[int]int)for i, vi := range nums &#123; for j, vj := range nums &#123; if i != j &amp;&amp; vi-vj == k &#123; hashMap[vi] = vj &#125; &#125;&#125;return len(hashMap) 完整程式碼:1234567891011121314func findPairs(nums []int, k int) int &#123; if k &lt; 0 &#123; return 0 &#125; hashMap := make(map[int]int) for i, vi := range nums &#123; for j, vj := range nums &#123; if i != j &amp;&amp; vi-vj == k &#123; hashMap[vi] = vj &#125; &#125; &#125; return len(hashMap)&#125; 總結:要從一陣列中找任兩值距離為k的共有幾組((x, y)與(y, x)只算一種)，最簡單的方式就是用巢狀迴圈都從同一陣列來取資料並兩兩比較，當兩個值並非陣列中的相同index且相減距離為正數k就儲至hashmap(兩相同的值只會被算到一次)之中，最後直接回傳hashmap長度即可。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"}]},{"title":"Minimum Absolute Difference in BST","slug":"minimum-absolute-difference-in-BST","date":"2017-03-27T16:00:00.000Z","updated":"2017-04-05T15:21:14.000Z","comments":true,"path":"2017/03/28/minimum-absolute-difference-in-BST/","link":"","permalink":"https://blog.yunchen.tw/2017/03/28/minimum-absolute-difference-in-BST/","excerpt":"","text":"Minimum Absolute Difference in BSTGiven a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes. For Example:12345678910111213Input: 1 \\ 3 / 2Output:1Explanation:The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3). Note: There are at least two nodes in this BST. 提示 解題應用 BinarySearchTree PreOrderTravel Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func getMinimumDifference(root *TreeNode) int &#123;&#125; 解答思路:一開始思索著是否可以透過二元樹的關係找出值之間的最小距離，但是如果對於那些極端的狀況或參數是不適用的，所以就直接一邊前序遍歷所有的樹節點，一邊將該節點的值與先前遍歷的所有節點值找最小距離，如此一來在結束遍歷後也就能找出我們要的結果。 程式碼解說:一開始先判斷根節點是否為nil，如果是就直接回傳0，接著便開始前序遍歷帶入根節點與用來儲存目前遍歷過所有節點的值及目前找到的最小值(這邊一開始放int的32位元極大值) 1234567func getMinimumDifference(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; var valList []int return preOrderTravel(root, valList, math.MaxInt32)&#125; 接下來的前序遍歷如果進來的節點為nil值就直接回傳最小值，如果該節點存在就利用一迴圈取出先前先遍歷過所有節點的值並與目前節點值相減取距離(絕對值取正數)，當該距離比目前找到的最小距離還小就將其取代，比對完目前能發現的最小距離後，接著才把目前節點值放入已遍歷的清單中，最後繼續做左右子節點的前序遍歷，這邊要注意的是當左子節點(樹)回傳最小結果後，將其帶入右子節點(樹)繼續判斷在另一側是否也為最小值，最後兩邊節點都比對過才向上回傳最小結果 1234567891011121314151617func preOrderTravel(node *TreeNode, valList []int, min int) int &#123; if node == nil &#123; return min &#125; var diff int for _, v := range valList &#123; diff = abs(node.Val - v) if diff &lt; min &#123; min = diff &#125; &#125; valList = append(valList, node.Val) min = preOrderTravel(node.Left, valList, min) min = preOrderTravel(node.Right, valList, min) return min&#125; 簡單的一個絕對值判斷，如果傳入的數小於0就乘上-1後回傳，其餘則直接回傳 123456func abs(num int) int &#123; if num &lt; 0 &#123; return -num &#125; return num&#125; 完整程式碼:123456789101112131415161718192021222324252627282930func getMinimumDifference(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; var valList []int return preOrderTravel(root, valList, math.MaxInt32)&#125;func preOrderTravel(node *TreeNode, valList []int, min int) int &#123; if node == nil &#123; return min &#125; var diff int for _, v := range valList &#123; diff = abs(node.Val - v) if diff &lt; min &#123; min = diff &#125; &#125; valList = append(valList, node.Val) min = preOrderTravel(node.Left, valList, min) min = preOrderTravel(node.Right, valList, min) return min&#125;func abs(num int) int &#123; if num &lt; 0 &#123; return -num &#125; return num&#125; 總結:要找出一二元樹中任二節點值相減的距離為最小值，最簡單的做法就是直接一邊前序遍歷所有的樹節點，一邊將該節點的值與先前遍歷的所有節點值找最小距離，如此一來在結束遍歷後也就能找出我們要的結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"BinarySearchTree","slug":"BinarySearchTree","permalink":"https://blog.yunchen.tw/tags/BinarySearchTree/"}]},{"title":"Detect Capital","slug":"detect-capital","date":"2017-03-26T16:00:00.000Z","updated":"2017-04-05T15:21:08.000Z","comments":true,"path":"2017/03/27/detect-capital/","link":"","permalink":"https://blog.yunchen.tw/2017/03/27/detect-capital/","excerpt":"","text":"Detect CapitalGiven a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like “USA”. All letters in this word are not capitals, like “leetcode”. Only the first letter in this word is capital if it has more than one letter, like “Google”. Otherwise, we define that this word doesn’t use capitals in a right way. Example 1:12Input: &quot;USA&quot;Output: True Example 2:12Input: &quot;FlaG&quot;Output: False Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters. 提示 解題應用 String 規律觀查 Default:123func detectCapitalUse(word string) bool &#123;&#125; 解答思路:判斷是否為Capital只存在三種情況，全部大寫、全部小寫或第一個字母大寫其餘小寫，而結論就是如果開頭為大寫，後面可以全部大寫及全部小寫，如果開頭為小寫後頭就一定要全部小寫，得出上述關係後剩下只要藉由ASCII的值就可以輕易找出大小寫及篩掉其它有特殊字元的情況。 程式碼解說:一開始便以迴圈取出該字串中的每個字母，如果rune值介於97~122(a~z)之間就註記有小寫字母存在，如果rune值介於65~90(A~Z)之間則註記有大寫字母存在，如果有其它的rune值就直接回傳false，接著又如果該字母為第一個字母且為大寫，就要將大寫的註記給取消，因為我們最終的判斷方式是如果大寫與小寫的註記都存在，表示不為capital，而第一個字母大寫其後頭不是全部大小就是全部小寫，此時如果符合上述其中一種情況，在第一個字母之後就會只有其中一種註記存在，至於如果第一個字母是小寫則一樣保留註記，因為後頭只會有小寫的情況，最後檢查完是否有大小寫註記同時存在，如果是就回傳false否則回傳true 123456789101112131415161718var lower boolvar upper boolfor i, v := range word &#123; if v &gt;= 97 &amp;&amp; v &lt;= 122 &#123; lower = true &#125; else if v &gt;= 65 &amp;&amp; v &lt;= 90 &#123; upper = true &#125; else &#123; return false &#125; if i == 0 &amp;&amp; upper &#123; upper = false &#125;&#125;if lower == true &amp;&amp; upper == true &#123; return false&#125;return true 完整程式碼:1234567891011121314151617181920func detectCapitalUse(word string) bool &#123; var lower bool var upper bool for i, v := range word &#123; if v &gt;= 97 &amp;&amp; v &lt;= 122 &#123; lower = true &#125; else if v &gt;= 65 &amp;&amp; v &lt;= 90 &#123; upper = true &#125; else &#123; return false &#125; if i == 0 &amp;&amp; upper &#123; upper = false &#125; &#125; if lower == true &amp;&amp; upper == true &#123; return false &#125; return true&#125; 總結:判斷是否為Capital只存在三種情況，全部大寫、全部小寫或第一個字母大寫其餘小寫，而結論就是如果開頭為大寫，後面可以全部大寫及全部小寫，如果開頭為小寫後頭就一定要全部小寫，得出上述關係後剩下只要藉由ASCII的值就可以輕易找出大小寫及篩掉其它有特殊字元的情況。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"}]},{"title":"Relative Ranks","slug":"relative-ranks","date":"2017-03-25T16:00:00.000Z","updated":"2017-04-05T15:20:48.000Z","comments":true,"path":"2017/03/26/relative-ranks/","link":"","permalink":"https://blog.yunchen.tw/2017/03/26/relative-ranks/","excerpt":"","text":"Relative RanksGiven scores of N athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: “Gold Medal”, “Silver Medal” and “Bronze Medal”. For Example:1234Input: [5, 4, 3, 2, 1]Output: [&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;, &quot;4&quot;, &quot;5&quot;]Explanation: The first three athletes got the top three highest scores, so they got &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;. For the left two athletes, you just need to output their relative ranks according to their scores. Note: N is a positive integer and won’t exceed 10,000. All the scores of athletes are guaranteed to be unique. Default:123func findRelativeRanks(nums []int) []string &#123;&#125; 解答思路:原本的作法是一個個紀錄所有名次的分數，如果比該名次大就將所有該名次(包含)向後退一名，之後再將新分數放至該名次之中，但這種作法只有找前三名或較少名次適用，因為每次要將所有後頭名次向後退太耗時間，因此倒不如一開始就做排序之後在照順序來發獎牌，不過在那之前要先將每個分數的位置給儲存下來才開始做排序，最後再給前三名獎牌而其餘的人則是只有名次。 程式碼解說:一開始就先以一迴圈將每個分數所對應的位置儲存至hashmap之中，其中key值為分數而value則是index值的位置，之後就將所有的分數做排序，這邊我們就直接用內建的library來做排序，因為排序完分數是從小至大，所以我們就從分數最大的開始發獎牌，因此由陣列後頭向前遍歷，隨著名次一一增加從第一名發到第三名都為獎牌(字串)，其餘的則是將名次轉為字串做儲存(不能直接強制轉，會變ASCII)，待獎牌與名次分配完之後就回傳結果 123456789101112131415161718192021rank := 1result := make([]string, len(nums))scoreIndex := make(map[int]int)for index, score := range nums &#123; scoreIndex[score] = index&#125;sort.Ints(nums)for i := len(nums) - 1; i &gt;= 0; i-- &#123; switch rank &#123; case 1: result[scoreIndex[nums[i]]] = \"Gold Medal\" case 2: result[scoreIndex[nums[i]]] = \"Silver Medal\" case 3: result[scoreIndex[nums[i]]] = \"Bronze Medal\" default: result[scoreIndex[nums[i]]] = strconv.Itoa(rank) &#125; rank++&#125;return result 完整程式碼:1234567891011121314151617181920212223func findRelativeRanks(nums []int) []string &#123; rank := 1 result := make([]string, len(nums)) scoreIndex := make(map[int]int) for index, score := range nums &#123; scoreIndex[score] = index &#125; sort.Ints(nums) for i := len(nums) - 1; i &gt;= 0; i-- &#123; switch rank &#123; case 1: result[scoreIndex[nums[i]]] = \"Gold Medal\" case 2: result[scoreIndex[nums[i]]] = \"Silver Medal\" case 3: result[scoreIndex[nums[i]]] = \"Bronze Medal\" default: result[scoreIndex[nums[i]]] = strconv.Itoa(rank) &#125; rank++ &#125; return result&#125; 總結:一陣列包含每位選手的分數(不重覆)，若只是要找前三名則可以一一比較並將較小的分數名次向後退，但若需列出整個陣列的名次，則先將所有分數做排序再照順序來發獎牌，而如果後者是要全部做排序，在開始之前需先記錄下每個分數儲存的位置，最後才以此位置來分配分數所對應的獎牌。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"}]},{"title":"Base 7","slug":"base-7","date":"2017-03-24T16:00:00.000Z","updated":"2017-04-05T15:20:40.000Z","comments":true,"path":"2017/03/25/base-7/","link":"","permalink":"https://blog.yunchen.tw/2017/03/25/base-7/","excerpt":"","text":"Base 7Given an integer, return its base 7 string representation. Example 1:12Input: 100Output: &quot;202&quot; Example 2:12Input: -7Output: &quot;-10&quot; Note: The input will be in range of [-1e7, 1e7]. Default:123func convertToBase7(num int) string &#123;&#125; 解答思路:這題需要你將10進制轉成7進制，其中負數的10進制轉為7進制時一樣保留負的符號，所以如果值為負數先將其轉為正數後，待值轉為7進制再將符號加回字串之中，至於正數的10進制要轉7進制就是不斷的除以7取餘數，並將餘數轉成字串放入結果開頭之中，最後不斷的將商數重覆上述動作直到商數歸0為止。 程式碼解說:一開始先判斷該數是否為負數，如果是就先標注其為負數並先將其轉為正數，如果該數為0就回傳”0” 12345678var neg boolvar result stringif num &lt; 0 &#123; neg = true num *= -1&#125; else if num == 0 &#123; return \"0\"&#125; 再來就是不斷的將該數與7相除，並先將餘數加上48(ascii字串”0”為48)再強制轉為字串放入結果開頭，直到商數歸0才停止，最後如果先前有標註該數為負數的話，在字串開頭加上負的符號，否則就直接回傳結果 12345678for num &gt; 0 &#123; result = string((num%7)+48) + result num = num / 7&#125;if neg &#123; result = \"-\" + result&#125;return result 完整程式碼:123456789101112131415161718func convertToBase7(num int) string &#123; var neg bool var result string if num &lt; 0 &#123; neg = true num *= -1 &#125; else if num == 0 &#123; return \"0\" &#125; for num &gt; 0 &#123; result = string((num%7)+48) + result num = num / 7 &#125; if neg &#123; result = \"-\" + result &#125; return result&#125; 總結:要將10進制轉成7進制，且負數的10進制轉為7進制時需一樣保留負的符號，可以先直接將數字部分轉為7進制後，再把符號加回字串之中，至於10進制要轉7進制就是不斷的除以7取餘數，並將餘數轉成字串放入結果開頭之中，最後不斷的將商數重覆上述動作直到商數歸0為止。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"}]},{"title":"Find Mode in Binary Search Tree","slug":"find-mode-in-binary-search-tree","date":"2017-03-23T16:00:00.000Z","updated":"2017-04-05T15:20:20.000Z","comments":true,"path":"2017/03/24/find-mode-in-binary-search-tree/","link":"","permalink":"https://blog.yunchen.tw/2017/03/24/find-mode-in-binary-search-tree/","excerpt":"","text":"Find Mode in Binary Search TreeGiven a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees. For example:Given BST [1,null,2,2], 123451 \\ 2 /2 return [2]. Note: If a tree has more than one mode, you can return them in any order. Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count). 提示 解題應用 Tree 中序遍歷 Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func findMode(root *TreeNode) []int &#123;&#125; 解答思路:最簡單的方式就是使用hashmap來儲存，接著再檢查hashmap便能得知出現最多次是哪些元素了，不過Follow up希望我們能不使用額外的空間複雜度，一開始是用前序遍歷來看並做檢查，結果走了不少冤望路，因為除非相同的元素是連在一起，否則很難找出結果，例如下列的二元樹: 因為相同的元素可能分散的情況下就非常難做統計，所以看得出來使用前序遍歷是錯的選擇，而中序遍歷就會是最佳做法，因為中序遍歷二元樹出來的結果會是從小至大排序好的結果，如此一來便能很輕易的去做統計，附帶一提雖然採用遞回的方式不被認為算是使用額外的空間，但如果需要只用O(1)的空間來進行樹的遍歷可以使用: Morris Traversal演算法。 程式碼解說:最主要是做中序遍歷，不過因為遍歷的上一個值也好，或者到目前為止統計出現次數，及最大的出現數等等都需要在遞回之間傳遞，因此需要用傳”址”而非傳”值”，如果節點為nil值就直接回傳結果，接下來便開始我們的中序遍歷，這邊我們一開始先中序遍歷左子節點，接著才處理我們的目標節點，最後才中序遍歷右子節點並回傳結果 12345678func inOrderTravel(node *TreeNode, tmp *int, count *int, max *int, result []int) []int &#123; if node == nil &#123; return result &#125; result = inOrderTravel(node.Left, tmp, count, max, result) ... return inOrderTravel(node.Right, tmp, count, max, result)&#125; 這邊則處理我們的目標節點，一開始先看上一個遍歷節點的值是否與目標節點相同，若不同就將前一個暫存節點的值改為現在目標節點的值，以方便到下一個節點時能知道前一個節點的值變成多少，因為節點值變了所以此時將計數歸0，再將新節點的計數+1，當出現的次數超過最大次數就將其取代，並清空原本結果陣列所儲存出現次數較少的值再放入新的值，而最後如果出現的次數等同最大次數則直接將新的值放入結果陣列的後頭 1234567891011if node.Val != *tmp &#123; *tmp = node.Val *count = 0&#125;*count++if *count &gt; *max &#123; *max = *count result = []int&#123;*tmp&#125;&#125; else if *count == *max &#123; result = append(result, *tmp)&#125; 完整程式碼:12345678910111213141516171819202122232425func findMode(root *TreeNode) []int &#123; var tmp int var max int var count int var result []int return inOrderTravel(root, &amp;tmp, &amp;count, &amp;max, result)&#125;func inOrderTravel(node *TreeNode, tmp *int, count *int, max *int, result []int) []int &#123; if node == nil &#123; return result &#125; result = inOrderTravel(node.Left, tmp, count, max, result) if node.Val != *tmp &#123; *tmp = node.Val *count = 0 &#125; *count++ if *count &gt; *max &#123; *max = *count result = []int&#123;*tmp&#125; &#125; else if *count == *max &#123; result = append(result, *tmp) &#125; return inOrderTravel(node.Right, tmp, count, max, result)&#125; 總結:若要遍歷二元樹找出出現最多次的值有哪些，並且在不使用額外空間的情況下可以使用中序遍歷，因為中序遍歷二元樹的結果會是從小至大排序的結果，尤其是在統計相同值出現的次數會非常簡易，此外若有不採用遞回方式的需求來遍歷樹可以用Morris Traversal演算法。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"}]},{"title":"Keyboard Row","slug":"keyboard-row","date":"2017-03-22T16:00:00.000Z","updated":"2017-04-05T15:20:12.000Z","comments":true,"path":"2017/03/23/keyboard-row/","link":"","permalink":"https://blog.yunchen.tw/2017/03/23/keyboard-row/","excerpt":"","text":"Keyboard RowGiven a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below. For Example:12Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]Output: [&quot;Alaska&quot;, &quot;Dad&quot;] Note: You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet. 提示 解題應用 HashTable HashMap Default:123func findWords(words []string) []string &#123;&#125; 解答思路:一開始在準備上稍為麻煩，要將鍵盤上的每一列存到hashmap之中，其中key為該字母而value則是鍵盤上該列數，而準備完成後就已經完全大多數的工作了，剩下的就是一一核對每個單字中的每個字母是否為同一列，如果發現不為同一列的字母就直接換檢查下一個單字，最後檢查完畢即可回傳。 程式碼解說:一開始先存好鍵盤上的每一列到字串之中，接著再各別以一回圈將其儲至hashmap之中，其中key為該字母而value則是鍵盤上該列數，開始一以迴圈遍歷陣列中的每個單字，再進下一層的巢狀迴圈準備再遍歷每個單字中的每個字母前，先將該單字中的所有字母轉為小寫，接著取出第一個字母到hashmap之中查看該字母為鍵盤上的哪一列，最後才開始檢查單中中的字母，當該字母不等於先查所查的列數時，將先前暫存查詢的列數存為-1並跳開迴圈繼續檢查下一個單字，而如果在離開迴圈後暫存值不等於-1表示該單字全由同列字母儲存，此時就將單字放入結果之中，檢查完所有的單字後回傳結果 123456789101112131415161718192021222324252627282930var tmp intvar wordLow stringvar result []stringrow1 := \"qwertyuiop\"row2 := \"asdfghjkl\"row3 := \"zxcvbnm\"hashMap := make(map[rune]int)for _, v := range row1 &#123; hashMap[v] = 1&#125;for _, v := range row2 &#123; hashMap[v] = 2&#125;for _, v := range row3 &#123; hashMap[v] = 3&#125;for _, word := range words &#123; wordLow = strings.ToLower(word) tmp = hashMap[rune(wordLow[0])] for _, char := range wordLow[1:] &#123; if hashMap[char] != tmp &#123; tmp = -1 break &#125; &#125; if tmp != -1 &#123; result = append(result, word) &#125;&#125;return result 完整程式碼:1234567891011121314151617181920212223242526272829303132func findWords(words []string) []string &#123; var tmp int var wordLow string var result []string row1 := \"qwertyuiop\" row2 := \"asdfghjkl\" row3 := \"zxcvbnm\" hashMap := make(map[rune]int) for _, v := range row1 &#123; hashMap[v] = 1 &#125; for _, v := range row2 &#123; hashMap[v] = 2 &#125; for _, v := range row3 &#123; hashMap[v] = 3 &#125; for _, word := range words &#123; wordLow = strings.ToLower(word) tmp = hashMap[rune(wordLow[0])] for _, char := range wordLow[1:] &#123; if hashMap[char] != tmp &#123; tmp = -1 break &#125; &#125; if tmp != -1 &#123; result = append(result, word) &#125; &#125; return result&#125; 總結:要檢查一陣列中的數個單字有哪些由鍵盤上的同的列字母所組成，將鍵盤上的每一列存到hashmap之中，其中key為該字母而value則是鍵盤上該列數，最後一一核對每個單字中的每個字母是否為同一列，如果發現不為同一列的字母就直接換檢查下一個單字，最後檢查完畢即可回傳。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"}]},{"title":"Next Greater Element I","slug":"next-greater-element-I","date":"2017-03-21T16:00:00.000Z","updated":"2017-04-05T15:20:02.000Z","comments":true,"path":"2017/03/22/next-greater-element-I/","link":"","permalink":"https://blog.yunchen.tw/2017/03/22/next-greater-element-I/","excerpt":"","text":"Next Greater Element IYou are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2. The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number. Example 1:123456Input: nums1 = [4,1,2], nums2 = [1,3,4,2].Output: [-1,3,-1]Explanation: For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1. For number 1 in the first array, the next greater number for it in the second array is 3. For number 2 in the first array, there is no next greater number for it in the second array, so output -1. Example 2:12345Input: nums1 = [2,4], nums2 = [1,2,3,4].Output: [3,-1]Explanation: For number 2 in the first array, the next greater number for it in the second array is 3. For number 4 in the first array, there is no next greater number for it in the second array, so output -1. Note: All elements in nums1 and nums2 are unique. The length of both nums1 and nums2 would not exceed 1000. 提示 解題應用 Stack 未使用Stack直接做判斷 Default:123func nextGreaterElement(findNums []int, nums []int) []int &#123;&#125; 解答思路:這邊我直接判斷，也就是說第一個陣列拿到的值到第二個陣列開始判斷，並在第二個陣列找到與第一個陣列所取出的值相同才開始找比其大的值，若遍歷到底都沒有才回傳-1，並且不斷重覆上述動作直到第一個陣列所有元素後頭的最大值都找到為止，雖然這麼做相當簡單但費時，不過目前尚未想到更好的辦法。 程式碼解說:一開始先利用回圈從第一個陣列取出目標，接著與巢狀迴圈取出的第二個陣列值進行比較，如果在第二個陣列中發現的目標值，註記之後此時才開始需要比目標值還大的值，如果發現了比其大的值就放入結果之中同時將註記改回false，而當巢狀迴圈遍歷結束後但註記仍為true的話，表示沒發現後頭有比其更大的值，因此才再結果之中放入-1，最後直到第一個陣列所有元素後頭的最大值都找到才回傳結果 12345678910111213141516171819var find boolvar result []intfor _, target := range findNums &#123; for _, num := range nums &#123; if num == target &#123; find = true &#125; if find &amp;&amp; num &gt; target &#123; result = append(result, num) find = false break &#125; &#125; if find &#123; result = append(result, -1) find = false &#125;&#125;return result 完整程式碼:123456789101112131415161718192021func nextGreaterElement(findNums []int, nums []int) []int &#123; var find bool var result []int for _, target := range findNums &#123; for _, num := range nums &#123; if num == target &#123; find = true &#125; if find &amp;&amp; num &gt; target &#123; result = append(result, num) find = false break &#125; &#125; if find &#123; result = append(result, -1) find = false &#125; &#125; return result&#125; 總結:因為目前尚未想到更好的辦法，所以直接用了最簡單但費時的方法，第一個陣列拿到的值到第二個陣列開始判斷，並在第二個陣列找到與第一個陣列所取出的值相同才開始找比其大的值，若遍歷到底都沒有才回傳-1，並且不斷重覆上述動作直到第一個陣列所有元素後頭的最大值都找到為止。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Stack","slug":"Stack","permalink":"https://blog.yunchen.tw/tags/Stack/"}]},{"title":"Heaters","slug":"heaters","date":"2017-03-20T16:00:00.000Z","updated":"2017-04-05T15:19:53.000Z","comments":true,"path":"2017/03/21/heaters/","link":"","permalink":"https://blog.yunchen.tw/2017/03/21/heaters/","excerpt":"","text":"HeatersWinter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses. Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters. So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters. Note: Numbers of houses and heaters you are given are non-negative and will not exceed 25000. Positions of houses and heaters you are given are non-negative and will not exceed 10^9. As long as a house is in the heaters’ warm radius range, it can be warmed.All the heaters follow your radius standard and the warm radius will the same. Example 1:123Input: [1,2,3],[2]Output: 1Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed. Example 2:123Input: [1,2,3,4],[1,4]Output: 1Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed. 提示 解題應用 BinarySearch 改用Sort Default:123func findRadius(houses []int, heaters []int) int &#123;&#125; 解答思路:如果兩個參數值是在由小至大排序的情況下，應該不會有什麼大問題，在此條件的前提下，盡可能先找出在房子後頭的火爐，如果火爐在該房前頭就找下一個火爐，如果到最後一個火爐的位置該房子還是在火爐後頭，這時才開始計算房子與火爐的距離，因為火爐已經到底所以就直接計算尚未遍歷房子的最後一棟(因為要找離火爐最遠的位置當半徑)，如果該距離比目前所存的半徑大就是結果，而另外一方面如果發現有房子在火爐前頭的情況，這時就計算房子與火爐的距離，如果該火爐非第一個，就同時再計算前一個火爐(會在該房子前面)的距離，同時比較房子與前面火爐的距離哪個比較近，以距離比較小的為主，如果又比目前找出的半徑大才做儲存，直到所有的房子遍歷完才回傳半徑。 程式碼解說:一開始用內建的library先將房子與火爐從小到大做排序，接著就是開始計算最小半徑，盡可能先找出在房子後頭的火爐，現在先只看如果只有火爐在房子前頭的情況，如果火爐還沒到最後一個就繼續往後找，而最後到最後一個火爐的位置時，如果該房子還是在火爐後頭，就直接將還沒遍歷房子中的最後一棟與火爐相減找出距離，如果該長度比半徑大就將其取代，並回傳結果 1234567891011121314151617181920212223sort.Ints(houses)sort.Ints(heaters)var pre intvar post intvar radius intvar houseIndex intvar heaterIndex intfor true &#123; if houses[houseIndex] &lt; heaters[heaterIndex] &#123; ... &#125; else &#123; if heaterIndex != len(heaters)-1 &#123; heaterIndex++ &#125; else &#123; pre = houses[len(houses)-1] - heaters[heaterIndex] if pre &gt; radius &#123; radius = pre &#125; break &#125; &#125;&#125;return radius 發現有火爐在房子後頭的情況，找出房子與前後頭火爐位置的距離，此時火爐的位置在第一個，此時並不存在前一個火爐在房子前頭，將前頭距離以題目所給予的最大值在儲存，最後比較前後頭距離誰比較小，如果又剛好比目前找到的半徑大就將其取代，直到遍歷完所有的房子才跳開回圈 1234567891011121314151617if houses[houseIndex] &lt; heaters[heaterIndex] &#123; post = heaters[heaterIndex] - houses[houseIndex] if heaterIndex != 0 &#123; pre = houses[houseIndex] - heaters[heaterIndex-1] &#125; else &#123; pre = 1000000000 &#125; if pre &lt; post &amp;&amp; pre &gt; radius &#123; radius = pre &#125; else if post &lt; pre &amp;&amp; post &gt; radius &#123; radius = post &#125; houseIndex++ if houseIndex == len(houses) &#123; break &#125;&#125; 完整程式碼:123456789101112131415161718192021222324252627282930313233343536373839func findRadius(houses []int, heaters []int) int &#123; sort.Ints(houses) sort.Ints(heaters) var pre int var post int var radius int var houseIndex int var heaterIndex int for true &#123; if houses[houseIndex] &lt; heaters[heaterIndex] &#123; post = heaters[heaterIndex] - houses[houseIndex] if heaterIndex != 0 &#123; pre = houses[houseIndex] - heaters[heaterIndex-1] &#125; else &#123; pre = 1000000000 &#125; if pre &lt; post &amp;&amp; pre &gt; radius &#123; radius = pre &#125; else if post &lt; pre &amp;&amp; post &gt; radius &#123; radius = post &#125; houseIndex++ if houseIndex == len(houses) &#123; break &#125; &#125; else &#123; if heaterIndex != len(heaters)-1 &#123; heaterIndex++ &#125; else &#123; pre = houses[len(houses)-1] - heaters[heaterIndex] if pre &gt; radius &#123; radius = pre &#125; break &#125; &#125; &#125; return radius&#125; 總結:給二陣列其一為房子的位置，另一為火爐的位置，找出每個相同火爐能提供的最小半徑來涵蓋所有房子，首先先將兩陣列進行排序，一開始盡可能先找出在房子後頭的火爐，如果火爐在該房前頭就找下一個火爐，如果到最後一個火爐的位置該房子還是在火爐後頭，這時才開始計算房子與火爐的距離，因為火爐已經到底所以就直接計算尚未遍歷房子的最後一棟(因為要找離火爐最遠的位置當半徑)，如果該距離比目前所存的半徑大就是結果，而另外一方面如果發現有房子在火爐前頭的情況，這時就計算房子與火爐的距離，如果該火爐非第一個，就同時再計算前一個火爐(會在該房子前面)的距離，同時比較房子與前面火爐的距離哪個比較近，以距離比較小的為主，如果又比目前找出的半徑大才做儲存，直到所有的房子遍歷完才回傳半徑。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://blog.yunchen.tw/tags/BinarySearch/"}]},{"title":"Construct the Rectangle","slug":"construct-the-rectangle","date":"2017-03-19T16:00:00.000Z","updated":"2017-04-05T15:19:43.000Z","comments":true,"path":"2017/03/20/construct-the-rectangle/","link":"","permalink":"https://blog.yunchen.tw/2017/03/20/construct-the-rectangle/","excerpt":"","text":"Construct the RectangleFor a web developer, it is very important to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements: 123451. The area of the rectangular web page you designed must equal to the given target area.2. The width W should not be larger than the length L, which means L &gt;= W.3. The difference between length L and width W should be as small as possible. You need to output the length L and the width W of the web page you designed in sequence. For Example:1234Input: 4Output: [2, 2]Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. But according to requirement 2, [1,4] is illegal; according to requirement 3, [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2. Note: The given area won’t exceed 10,000,000 and is a positive integer The web page’s width and length you designed must be positive integers. Default:123func constructRectangle(area int) []int &#123;&#125; 解答思路:大致就是做因式分解，找出兩因數差距為最小值，所以如果我們將給予的值從1開始整除，原則上因數間的差距會慢慢變小，而當差距到最小時，下一個差距反而變大的話(或是相減的差距變為負數)，此時前一組就是我們要找的目標，在最後要放的時候記得要將因數較大的放第一個(長度L)，小的擺在第二個(寬度W)，因為結果要的是L, W。 程式碼解說:一開始先初始化一陣列但長度僅只有2用於存放結果，之後利用回圈將面積從1開始與常數做整除，如果面積與常數相除能完全整除，且商數(比較大)與常數相減大於0，就將商數放入結果陣列的第一個(長度)，至於常數則是放第二個(寬度)，一直到發現商數減去常數時為負，表示常數(寬度)已經比商數(長度)大，此時便跳離回圈將前一組因數結果做回傳 1234567891011121314var tmp intresult := make([]int, 2)for i := 1; i &lt;= area; i++ &#123; if area%i == 0 &#123; tmp = area / i if tmp-i &gt;= 0 &#123; result[0] = tmp result[1] = i &#125; else &#123; break &#125; &#125;&#125;return result 完整程式碼:12345678910111213141516func constructRectangle(area int) []int &#123; var tmp int result := make([]int, 2) for i := 1; i &lt;= area; i++ &#123; if area%i == 0 &#123; tmp = area / i if tmp-i &gt;= 0 &#123; result[0] = tmp result[1] = i &#125; else &#123; break &#125; &#125; &#125; return result&#125; 總結:給予一長方形的面積，找出長與寬且兩者差距需為最小值，將給予的面積從1開始整除，因數間的差距會慢慢變小，當差距到最小時，下一個差距反而變大的話(或是相減的差距變為負數)，此時前一組因數就是我們要找的目標。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"}]},{"title":"Max Consecutive Ones","slug":"max-consecutive-ones","date":"2017-03-18T16:00:00.000Z","updated":"2017-04-05T15:19:18.000Z","comments":true,"path":"2017/03/19/max-consecutive-ones/","link":"","permalink":"https://blog.yunchen.tw/2017/03/19/max-consecutive-ones/","excerpt":"","text":"Max Consecutive OnesGiven a binary array, find the maximum number of consecutive 1s in this array. For Example:1234Input: [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note: The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000 提示 解題應用 Array 規律觀查 Default:123func findMaxConsecutiveOnes(nums []int) int &#123;&#125; 解答思路:要從一陣列中找出最多連續出現1的次數，只要一邊遍歷一邊計算數量，當碰上0時就判斷是否大於先前出現的最大次數，如果是就取代原本的值然後將計數歸0重新開始計算，直到遍歷結束後做最後一次判斷計數器的值是否比較大，再來決定回傳的內容。 程式碼解說:一開始就以一迴圈遍歷陣列，如果元素值為1就將計數+1，當發現該元素的值為0時，此時就要停止計算出現1的數量，然後判斷是否大於先前出現的最大次數，是的話就取代原本的值，將計數歸0後再繼續遍歷其它元素，最後當遍歷結束時要再做最後一次判斷計數器的值是否比較大，因為陣列的最後一個值有可能不為0，此時計數器中的值尚未與目前的最大值做比較，因此若計數器的值若比較大則將最大值做取代回傳，否則就直接回傳原本的值 12345678910111213141516var max intvar count intfor _, v := range nums &#123; if v == 0 &#123; if count &gt; max &#123; max = count &#125; count = 0 continue &#125; count++&#125;if count &gt; max &#123; max = count&#125;return max 完整程式碼:123456789101112131415161718func findMaxConsecutiveOnes(nums []int) int &#123; var max int var count int for _, v := range nums &#123; if v == 0 &#123; if count &gt; max &#123; max = count &#125; count = 0 continue &#125; count++ &#125; if count &gt; max &#123; max = count &#125; return max&#125; 總結:要從一陣列中找出最多連續出現1的次數，只要一邊遍歷一邊計算數量，當碰上0時就判斷是否大於先前出現的最大次數，如果是就取代原本的值然後將計數歸0重新開始計算，直到遍歷結束後做最後一次判斷計數器的值是否比較大，再來決定回傳的內容。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"}]},{"title":"Number Complement","slug":"number-complement","date":"2017-03-17T16:00:00.000Z","updated":"2017-04-05T15:19:05.000Z","comments":true,"path":"2017/03/18/number-complement/","link":"","permalink":"https://blog.yunchen.tw/2017/03/18/number-complement/","excerpt":"","text":"Number ComplementGiven a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. Note: The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation. Example 1:123Input: 5Output: 2Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. Example 2:123Input: 1Output: 0Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0. Default:123func findComplement(num int) int &#123;&#125; 解答思路:看到題目應該第一個想到的會是直接做NOT，不過別忘了前頭的至多個位元0也會跟著改變，不曉得為什麼Go在設計上並沒有~這個Not的運算子，倒是有AND NOT: &amp;^，不過就算如此我們還是可以想出其它方案來處理，好比說就用XOR這個運算子^，如果5為101，我們要的結果是2(010)，那麼只要把5與7(111)做XOR即可，所以只要找出給予數字在二進制的長度，並且算出該長度位元皆為1時值為多少，最後兩者做XOR就會是我們要的結果。 程式碼解說:一開始先找出給予值在二進位的長度，接著便以此長度開始迴圈累加計算(1,2,4,8…)相同長度的情況下，位元皆為1時值為多少，最後將累加的結果值與題目給予值做XOR就會是答案 1234567var sum intbinary := 1for i := 1; i &lt;= len(strconv.FormatInt(int64(num), 2)); i++ &#123; sum += binary binary *= 2&#125;return sum ^ num 完整程式碼:123456789func findComplement(num int) int &#123; var sum int binary := 1 for i := 1; i &lt;= len(strconv.FormatInt(int64(num), 2)); i++ &#123; sum += binary binary *= 2 &#125; return sum ^ num&#125; 總結:若有一數5(101)，題目要將其0變為1，所以結果為2(010)，在用not之前別忘了二進制32位元int先前存在著至多個位元0也會變化，除了可以用找出mask的方式再來處理之外，只用XOR來想辦法也是一種方案，找出給予數字在二進制的長度，並且算出該長度位元皆為1時值為多少，最後兩者做XOR就是結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"}]},{"title":"Island Perimeter","slug":"island-perimeter","date":"2017-03-16T16:00:00.000Z","updated":"2017-04-05T15:18:56.000Z","comments":true,"path":"2017/03/17/island-perimeter/","link":"","permalink":"https://blog.yunchen.tw/2017/03/17/island-perimeter/","excerpt":"","text":"Island PerimeterYou are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. 提示 解題應用 規律觀查 規律觀查 For Example:123456[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]Answer: 16 Explanation: The perimeter is the 16 yellow stripes in the image below: Default:123func islandPerimeter(grid [][]int) int &#123;&#125; 解答思路:這題只需要觀查每一列中的規律及每一個的關係並以此判斷就可以很容易找出有多少個邊，首先以一列中的一格來說，我們先只需要在乎每格上、左、右側的邊就好，剛開始第一個格一定是三個邊，之後判斷如果前一格不存在(空格)，其空格後續新增的格子(圖形)一定也是三個邊，如果前一格存在是相連，則後續每多一格就只增加一個邊，而如果前一列的相同位置也就是該格的正上方也有存在格子(圖形)，這時就要將格子上側的邊給扣掉(第一列因為沒有前一列就不需要)，再來因為先前都只觀注三個邊，但如果到了最後一列就需要將每格的下側給補上，所以如果該格在最後一列就要再多補1，至於空格的情況只有一點需要注意，如果空格的正上方存在著格子(圖形)，要將其原本上方的格子(圖形)補上下側的邊，最後遵循上述規則的話就能在O(1)的空間複雜度達到目標。 程式碼解說:一開始便利用巢狀迴圈取出每一列中的每一格值，每列在剛開始預設前一格不存在(空格)，之後如果取出的該格值為1時，此時就要註記為存在，否則如果取出為0時，註記為不存在，以利後續判斷是否相連結時能有所依據 123456789101112131415var count intvar exist boolfor i, row := range grid &#123; exist = false for j, cell := range row &#123; if cell == 1 &#123; ... exist = true &#125; else &#123; ... exist = false &#125; &#125;&#125;return count 這邊是值為1的情況，如果前一格存在，此時因為新增的格子邊是相連結著，所以邊只增加1(上側而已，原本前一格右側的邊再移來新增格子的右邊，此時兩格中間就沒有邊)，如果前一格不存在，格子為獨立的情況，因為先前有說是以上、左、右側邊為主，因此就邊增加3。再來如果該列不為第1列，而且前一列的該位置(也就是目前格子的正上方)值為1，表示與上頭的格子相連結著，此時就要把先前所加入上側的邊給扣掉。最後如果該列為最後一列，因為先前只觀注三個邊，最後一列就需要將下側給補上，因此下側的每一格存在的格子都要再補1 1234567891011if exist &#123; count += 1&#125; else &#123; count += 3&#125;if i != 0 &amp;&amp; grid[i-1][j] == 1 &#123; count--&#125;if i == len(grid)-1 &#123; count++&#125; 這邊是值為0的情況，只有一點需要注意，如果該列不為第1列，而且(也就是目前格子的正上方)值為1，此時要將其原本上方存在的格子補上下側的邊 123if i != 0 &amp;&amp; grid[i-1][j] == 1 &#123; count++&#125; 完整程式碼:1234567891011121314151617181920212223242526272829func islandPerimeter(grid [][]int) int &#123; var count int var exist bool for i, row := range grid &#123; exist = false for j, cell := range row &#123; if cell == 1 &#123; if exist &#123; count += 1 &#125; else &#123; count += 3 &#125; if i != 0 &amp;&amp; grid[i-1][j] == 1 &#123; count-- &#125; if i == len(grid)-1 &#123; count++ &#125; exist = true &#125; else &#123; if i != 0 &amp;&amp; grid[i-1][j] == 1 &#123; count++ &#125; exist = false &#125; &#125; &#125; return count&#125; 總結:給一nxn的網狀圖，其中部分格子上色形成圖形，要算出該圖形的邊框數量有多少，最重要的就是做規律觀查，首先以一列中的一格來說以每格上、左、右側為主，通常第一個格一定是三個邊，之後判斷如果前一格不存在(空格)，其空格後續新增的格子(圖形)一定也是三個邊，如果前一格存在是相連，則後續每多一格就只增加一個邊，而如果前一列的相同位置也就是該格的正上方也有存在格子(圖形)，這時就要將格子上側的邊給扣掉(第一列因為沒有前一列就不需要)，再來到了最後一列就需要將每格的下側給補上，所以如果該格在最後一列就要再多補1，最後空格的情況只有一點需要注意，如果空格的正上方存在著格子(圖形)，要將其原本上方的格子(圖形)補上下側的邊。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"}]},{"title":"Hamming Distance","slug":"hamming-distance","date":"2017-03-15T16:00:00.000Z","updated":"2017-04-05T15:18:30.000Z","comments":true,"path":"2017/03/16/hamming-distance/","link":"","permalink":"https://blog.yunchen.tw/2017/03/16/hamming-distance/","excerpt":"","text":"Hamming DistanceThe Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note:0 ≤ x, y &lt; 231. For Example:12345678910Input: x = 1, y = 4Output: 2Explanation:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑The above arrows point to positions where the corresponding bits are different. 提示 解題應用 BitManipulation XOR,AND Default:123func hammingDistance(x int, y int) int &#123;&#125; 解答思路:如果要找出兩數在二進制中相異的部分有多少個，其實就只要直接將兩數做XOR就會是相差的部分了，剩下的只要算出做完XOR後共有多少個1在裡頭就大功告成了，而如果要計算二進制有多少個1出現，有一個小技巧是不斷的將”該數”與”該數-1”做AND直到0為止共做了多少次就會是有多少個1了，所以最後結合上述兩個流程就會是兩數在二進制中相異1的數量。 程式碼解說:一開始將兩數XOR，這邊我們將x與y做XOR後再放回x中，接著就要計算剛才做完計算得到差異的部分共有多少個1，利用一迴圈不斷的將x與(x-1)做AND，直到x歸0為止，期間所做的次數就是最後1的數量，也就是兩數在二進制中相異部分的數量 1234567var count intx ^= yfor x != 0 &#123; x = x &amp; (x - 1) count++&#125;return count 完整程式碼:123456789func hammingDistance(x int, y int) int &#123; var count int x ^= y for x != 0 &#123; x = x &amp; (x - 1) count++ &#125; return count&#125; 總結:要找出兩數在二進制中相異的部分有多少個，先直接將兩數做XOR就會是相差的部分，再來計算得到的差異部分在二進制中有多少個1，就是不斷的將”該數”與”該數-1”做AND直到0為止共做了多少次就會是兩數在二進制中相異1的數量。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"BitManipulation","slug":"BitManipulation","permalink":"https://blog.yunchen.tw/tags/BitManipulation/"}]},{"title":"Assign Cookies","slug":"assign-cookies","date":"2017-03-14T16:00:00.000Z","updated":"2017-04-05T15:18:11.000Z","comments":true,"path":"2017/03/15/assign-cookies/","link":"","permalink":"https://blog.yunchen.tw/2017/03/15/assign-cookies/","excerpt":"","text":"Assign CookiesAssume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number. Note: You may assume the greed factor is always positive.You cannot assign more than one cookie to one child. Example 1:1234567Input: [1,2,3], [1,1]Output: 1Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.You need to output 1. Example 2:1234567Input: [1,2], [1,2,3]Output: 2Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. You have 3 cookies and their sizes are big enough to gratify all of the children, You need to output 2. 提示 解題應用 Greedy Sort Default:123func findContentChildren(g []int, s []int) int &#123;&#125; 解答思路:原本想說將其中一項儲至hashMap之中來讓另一配對尋找，不過餅乾比慾望多的情形也能滿足條件，所以終究還是會回到餅乾與慾望在大小上的比較，既然如此倒不如一開始就將欲望大小與餅乾大小都做排序，接著開始分配餅乾，如果從最小塊的餅乾能滿足小於等於其欲望就分配該塊給他，繼續往下分配給其它的小朋友，如果該塊餅乾無法滿足他，那麼肯定後頭的小朋友也無法滿足，直接換大塊點來繼續做判斷，最後直到能發出的餅乾都分完了或每個小朋友都已經拿到了才結束。 程式碼解說:因為需要比較餅乾與慾望，所以一開始就用內建的library將兩項資料陣列做由小至大的排序，如此一來稍後就可以很容易處理大小比較的問題，接著利用一迴圈開始從最小塊的餅乾開始分配，如果餅乾無法滿足其慾望，就直接換下一塊餅乾，若足以滿足其欲望就換下一個小朋友(計數+1)，當所有的小朋友都已經分配到餅乾(餅乾還有剩)就跳出回圈或餅乾已經沒了，最後才回傳計數的結果 12345678910111213141516var content intvar count intsort.Ints(g)sort.Ints(s)for _, cookie := range s &#123; content = g[count] if cookie &lt; content &#123; continue &#125; else &#123; count++ if count == len(g) &#123; break &#125; &#125;&#125;return count 完整程式碼:123456789101112131415161718func findContentChildren(g []int, s []int) int &#123; var content int var count int sort.Ints(g) sort.Ints(s) for _, cookie := range s &#123; content = g[count] if cookie &lt; content &#123; continue &#125; else &#123; count++ if count == len(g) &#123; break &#125; &#125; &#125; return count&#125; 總結:對於分配餅乾與能滿足慾望上的分配，要找出最多能滿足的小朋友就是標準的貪心問題，因為餅乾比慾望多的情形也能滿足條件，終究還是會回到餅乾與慾望在大小上的比較，所以將給予的資料(餅乾與慾望)都做排序，如此一來就可以很輕易的找出答案了。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Greedy","slug":"Greedy","permalink":"https://blog.yunchen.tw/tags/Greedy/"}]},{"title":"Minimum Moves to Equal Array Elements","slug":"minimum-moves-to-equal-array-elements","date":"2017-03-13T16:00:00.000Z","updated":"2017-04-05T15:17:56.000Z","comments":true,"path":"2017/03/14/minimum-moves-to-equal-array-elements/","link":"","permalink":"https://blog.yunchen.tw/2017/03/14/minimum-moves-to-equal-array-elements/","excerpt":"","text":"Minimum Moves to Equal Array ElementsGiven a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1. For Example:12345678910Input:[1,2,3]Output:3Explanation:Only three moves are needed (remember each move increments two elements):[1,2,3] =&gt; [2,3,3] =&gt; [3,4,3] =&gt; [4,4,4] 提示 解題應用 Math 規律觀查 Default:123func minMoves(nums []int) int &#123;&#125; 解答思路:如果照題目的規則去想很容易就會卡很久，若給一長度n的數量，每次都要給n-1個數+1直到n個數的值都相同為止，找出最少需要多幾次，直接照這種方式來迴圈不斷判斷，每次都要先找出最大值之後再對其它數+1，很容易因為陣列長度極長，或元素值之間差異極大而花費過多的時間，再加上因為不曉得加到最後一樣數時會是多少，難以\b預測就很難不一步步慢慢增加，因此如果能反過來推想就會變的相當簡單，既然要給n-1個數+1，反過來推其實就是對1個數-1直到n個數都一樣小，而要變的一樣小其實就是陣列中的最小值，所以再找出最小值之後剩下的就只是將每個元素與最小值的差做相加就是結果了。 程式碼解說:首先將陣列的第一個值取出，接下來再與陣列其它值一一比較，如果發現有更小的值就放入變數中，再找出最小值之後接著再進行最後一次遍歷，將每個元素與最小值的差做相加，最後再遍歷結束後回傳結果 1234567891011var count intmin := nums[0]for _, v := range nums[1:] &#123; if v &lt; min &#123; min = v &#125;&#125;for _, v := range nums &#123; count += v - min&#125;return count 完整程式碼:12345678910111213func minMoves(nums []int) int &#123; var count int min := nums[0] for _, v := range nums[1:] &#123; if v &lt; min &#123; min = v &#125; &#125; for _, v := range nums &#123; count += v - min &#125; return count&#125; 總結:若給一長度n的數量，每次都要給n-1個數+1直到n個數的值都相同為止，找出最少需要多幾次，反過來推想其實就是對1個數-1直到n個數都一樣小，而要變的一樣小其實就是陣列中的最小值，所以再找出最小值之後再來只要將每個元素與最小值的差做相加就是結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"Find All Numbers Disappeared in an Array","slug":"find-all-numbers-disappeared-in-an-array","date":"2017-03-12T16:00:00.000Z","updated":"2017-04-05T15:17:36.000Z","comments":true,"path":"2017/03/13/find-all-numbers-disappeared-in-an-array/","link":"","permalink":"https://blog.yunchen.tw/2017/03/13/find-all-numbers-disappeared-in-an-array/","excerpt":"","text":"Find All Numbers Disappeared in an ArrayGiven an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. For Example:12345Input:[4,3,2,7,8,2,3,1]Output:[5,6] 提示 解題應用 Array Slice Default:123func findDisappearedNumbers(nums []int) []int &#123;&#125; 解答思路:因為想不透解法，看了別人討論的解法，雖然這種小技巧確實可以達到目標，不過一般也不會對資料做修改，寧可在空間上做些花費來記錄，而這招時間上會花費n+n的複雜度，首先先用一回圈遍歷將拿到的值-1當作index，並將原本在陣列上該index的值改為負數，如此一來在全數遍歷完成之後，陣列上沒有變為負數的值，其index在+1就會是陣列缺少的值，所以再次進行遍歷將那些值放入結果即可回傳。 程式碼解說:一開始先以迴圈進行遍歷，並將拿到的值-1當作index，再把原本在陣列上該index的值改為負數，不過改回負數時再回到一開始要當作index的狀況時就會有問題，所以迴圈遍歷時，取出元素後要先確保其為正數，如果是負數就要先轉為正數，這邊我們用自己刻的abs來簡單判斷，如果index的其值尚為正數就改為負數，最後再次利用迴圈將所有不為負數的其index+1放入結果之中回傳 1234567891011121314151617func findDisappearedNumbers(nums []int) []int &#123; var result []int var target int for _,v := range nums &#123; v = abs(v) target = nums[v-1] if target &gt; 0 &#123; nums[v-1] = - target &#125; &#125; for i,v := range nums &#123; if v &gt; 0 &#123; result = append(result,i+1) &#125; &#125; return result&#125; 非常單純判斷並將負數轉為正值的function，如此一來就不需要載入整個math的library 123456func abs(num int) int &#123; if num &lt; 0 &#123; return -num &#125; return num&#125; 完整程式碼:1234567891011121314151617181920212223func findDisappearedNumbers(nums []int) []int &#123; var result []int var target int for _,v := range nums &#123; v = abs(v) target = nums[v-1] if target &gt; 0 &#123; nums[v-1] = - target &#125; &#125; for i,v := range nums &#123; if v &gt; 0 &#123; result = append(result,i+1) &#125; &#125; return result&#125;func abs(num int) int &#123; if num &lt; 0 &#123; return -num &#125; return num&#125; 總結:一陣列若其長度為n，則該儲存元素需為1~n，若要找出缺少的元素且不能使用額外空間，首先先用一回圈遍歷將拿到的值-1當作index，並將原本在陣列上該index的值改為負數，在全數遍歷完成之後，陣列上沒有變為負數的值，其index在+1就會是陣列缺少的值。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"}]},{"title":"Number of Boomerangs","slug":"number-of-boomerangs","date":"2017-03-11T16:00:00.000Z","updated":"2017-04-05T15:17:30.000Z","comments":true,"path":"2017/03/12/number-of-boomerangs/","link":"","permalink":"https://blog.yunchen.tw/2017/03/12/number-of-boomerangs/","excerpt":"","text":"Number of BoomerangsGiven n points in the plane that are all pairwise distinct, a “boomerang” is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters). Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive). For Example:12345678Input:[[0,0],[1,0],[2,0]]Output:2Explanation:The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]] 提示 解題應用 HashTable HashMap Default:123func numberOfBoomerangs(points [][]int) int &#123;&#125; 解答思路:一平台上有數個坐標，找出以一點為中心到另外兩點的距離相等的數組共有幾組，其中另外兩點的距離是多少無所謂，只需關心與中心點的距離即可，盲點在於從座標上來看若有一中心點到另外兩點的距離相等，這是為一組情形，但在資料的結果上為[center,pointA,pointB],[center,pointerB,pointerA]將其當作兩種結果，而本題要求的就是為後者的情況，所以對中心點之外的座標要做排列組合，不過因為我們關心的為”距離”而非哪一點，此外儲存距離也比儲存兩點之間的關係容易多，所以就用hashmap儲存中心點到其餘所有點的距離及該距離有多少個，再來只要針對距離的個數有多少個做排序組合後(道理與座標是相同)，全部總合起來就是我們要的答案。 程式碼解說:一開始先初始化一hashmap，其中key儲存距離長度，而value則是中心到點有多少條同樣距離長度的線，再來就分別用一巢狀迴圈從同一陣列取出中心點與另一點座標，如果中心點與另一座標相同就再拿下一個座標，接著就開始計算中心點到該點之間的距離，x間距的平方加上y間\b距的平方，不過我們不需要開根號，畢竟主要只是要找出相同距離及其數量，而在找出一中心點與其餘座標的所有距離後，對所有距離做排列組合，不同座標間的組合公式為n*(n-1)，並將數量加至結果，最後在中心座標換下一個之前，將hashmap給重置以重新再次儲存中心點與座標點間的距離 123456789101112131415161718192021var x intvar y intvar distance intvar result inthashMap := make(map[int]int)for i, center := range points &#123; for j, point := range points &#123; if i == j &#123; continue &#125; x = center[0] - point[0] y = center[1] - point[1] distance = x*x + y*y hashMap[distance]++ &#125; for _, value := range hashMap &#123; result += value * (value - 1) &#125; hashMap = make(map[int]int)&#125;return result 完整程式碼:1234567891011121314151617181920212223func numberOfBoomerangs(points [][]int) int &#123; var x int var y int var distance int var result int hashMap := make(map[int]int) for i, center := range points &#123; for j, point := range points &#123; if i == j &#123; continue &#125; x = center[0] - point[0] y = center[1] - point[1] distance = x*x + y*y hashMap[distance]++ &#125; for _, value := range hashMap &#123; result += value * (value - 1) &#125; hashMap = make(map[int]int) &#125; return result&#125; 總結:一平台上有數個坐標，找出以一點為中心到另外兩點的距離相等的數組共有幾組，對中心點之外的座標做排列組合，以hashmap儲存中心點到其餘所有點的距離及該距離有多少個，再來只要針對距離的個數有多少個做排序組合後(道理與座標是相同)，全部總合起來就是我們要的答案。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"}]},{"title":"Arranging Coins","slug":"arranging-coins","date":"2017-03-10T16:00:00.000Z","updated":"2017-04-05T15:17:23.000Z","comments":true,"path":"2017/03/11/arranging-coins/","link":"","permalink":"https://blog.yunchen.tw/2017/03/11/arranging-coins/","excerpt":"","text":"Arranging CoinsYou have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins. Given n, find the total number of full staircase rows that can be formed. n is a non-negative integer and fits within the range of a 32-bit signed integer. Example 1:12345678n = 5The coins can form the following rows:¤¤ ¤¤ ¤Because the 3rd row is incomplete, we return 2. Example 2:123456789n = 8The coins can form the following rows:¤¤ ¤¤ ¤ ¤¤ ¤Because the 4th row is incomplete, we return 3. 提示 解題應用 Math 規律觀查 Default:123func arrangeCoins(n int) int &#123;&#125; 解答思路:很單純的題目，只要不斷將n減去一連續數列(1,2,3…)，當n小於0時其減去該數的前一個值就是最大能完成的列數。 程式碼解說:因為要減去的數列是從1開始，所以先初始化數列起始值為1，接著開始不斷利用迴圈將n與連續數列做相減，而數列的值也依續不斷變大，直到n減去該值時小於0才停止，而因為要找的是有排滿的列數，所以結果就是該數再去-1就是我們要的答案 1234567count := 1for n-count &gt;= 0 &#123; n -= count count++&#125;count--return count 完整程式碼:123456789func arrangeCoins(n int) int &#123; count := 1 for n-count &gt;= 0 &#123; n -= count count++ &#125; count-- return count&#125; 總結:若有一數量的硬幣照每列各有(1,2,3…)的數量排序，找出最大且該列能排滿的位置，只要不斷將n減去一連續數列(1,2,3…)，當n小於0時其減去該數的前一個值就是最大能完成的列數。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://blog.yunchen.tw/tags/BinarySearch/"}]},{"title":"Find All Anagrams in a String","slug":"find-all-anagrams-in-a-string","date":"2017-03-09T16:00:00.000Z","updated":"2017-04-05T15:17:16.000Z","comments":true,"path":"2017/03/10/find-all-anagrams-in-a-string/","link":"","permalink":"https://blog.yunchen.tw/2017/03/10/find-all-anagrams-in-a-string/","excerpt":"","text":"Find All Anagrams in a StringGiven a string s and a non-empty string p, find all the start indices of p’s anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1:123456789Input:s: &quot;cbaebabacd&quot; p: &quot;abc&quot;Output:[0, 6]Explanation:The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;. Example 2:12345678910Input:s: &quot;abab&quot; p: &quot;ab&quot;Output:[0, 1, 2]Explanation:The substring with start index = 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.The substring with start index = 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.The substring with start index = 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;. 提示 解題應用 HashTable HashMap Default:123func findAnagrams(s string, p string) []int &#123;&#125; 解答思路:這題卡了非常久在於一開始的思路有點問題，在於重設次數上的判斷，通常要這類找一字串是否包含另一字串，且被包含的字串不需要在意其順序的話，會用hashmap來儲存，其中key為被包含的字母，而value則是出現的次數，該字串包含其字母則次數-1，一直到所有字母出現的次數皆為0，甚至被包含字串的每個字母不需要連結著，只要字母有完全出現的話，只要次數一歸0直接從hashmap拿掉最後在判斷hashmap是否為空即可，但此題雖然不需在意順序，但字串是完整連結，這意味著如果在核對是否包含時，如果到一半發現主字串前半部並不完全包含著次字串，但有可能是主次串的後半部才會出現，此時是不是該重設原本字母出現的次數並重新判斷，偏偏如果差一個字母，只要往下移一格再重新檢查就符合條件，如果照剛剛完全重設大部分已經判斷過的字母，是非常浪費時間的，所以不是把所有次數重設，而是邊移動邊判斷，如果出現不符合條件，把最前面最早判斷的字母次數(hashmap之中，不在其中就不用)給加一個回來，之後再向後推一格再把最新的字母做比對並判斷是否hashmap此時所有的字母次數都已經歸0，藉由這樣的方式慢慢向後推，每次一發現所有字母次數歸0就紀錄index值，如此一來就算所有符合條件的次字串彼此互相重疊也可以很容易全部找出來。 程式碼解說:一開始當然是先初始化一hashmap，其中key值為rune型別，value則是字母出現的次數，接著利用迴圈遍歷將被包含字串的每個字母放入hashmap之中，同時計算出現的次數 1234567var result []intvar flag intvar front inthashMap := make(map[rune]int)for _, v := range p &#123; hashMap[v]++&#125; 再來開始遍歷我們的主字串，先看該字母是否存在於hashMap之中，如果存在就將該字母的次數-1，當字母的次數為0時，就記錄下已經有多少個字母歸0，如果所有hashmap字母皆歸0，表示次字串存在於主字串之中，並且將次字串的第一個index值front放入結果之中 123456789101112131415for i, v := range s &#123; ... amount, ok := hashMap[v] if ok &#123; hashMap[v]-- amount-- if amount == 0 &#123; flag++ &#125; if flag == len(hashMap) &#123; result = append(result, front) &#125; &#125;&#125;return result 當遍歷的index減去開頭的index等於次字串的長度時(比次字串長度多1)，這時就需要將次字串向後位移一格，因為向後移時原本包含的第一個字母會移出計算的次數，所以如果是在hashmap之中的話要將該字母的字數加回1，如果原本的數量已經歸0，要記得將原本記錄下已經有多少個字母歸0再加回1，最後才接回上一段解說的程式碼檢查後移一格加入新包含的字母後，是否又符合包含次字串的條件 123456789101112for i, v := range s &#123; if i-front == len(p) &#123; amount, ok := hashMap[rune(s[front])] if ok &#123; hashMap[rune(s[front])]++ if amount == 0 &#123; flag-- &#125; &#125; front++ ...&#125; 完整程式碼:123456789101112131415161718192021222324252627282930313233func findAnagrams(s string, p string) []int &#123; var result []int var flag int var front int hashMap := make(map[rune]int) for _, v := range p &#123; hashMap[v]++ &#125; for i, v := range s &#123; if i-front == len(p) &#123; amount, ok := hashMap[rune(s[front])] if ok &#123; hashMap[rune(s[front])]++ if amount == 0 &#123; flag-- &#125; &#125; front++ &#125; amount, ok := hashMap[v] if ok &#123; hashMap[v]-- amount-- if amount == 0 &#123; flag++ &#125; if flag == len(hashMap) &#123; result = append(result, front) &#125; &#125; &#125; return result&#125; 總結:要判斷一字串(主字串)是否包含另一字串(次字串)，且被包含的字串不需順序排列但字母間需連結，首先先將被包含字串的字母用hashmap作儲存，其中key為字母而value則是出現的次數，在主字串上邊移動邊判斷，符合條件就將該字母次數-1，如果主字串上的次字串出現不符合條件的情況，把最前面最早判斷的字母次數(hashmap之中，不在其中就不用)給加一個回來，之後再向後推一格再把最新的字母做比對並判斷是否hashmap此時所有的字母次數都已經歸0，藉由這樣的方式慢慢向後推，每次一發現所有字母次數歸0就紀錄index值，如此一來就算所有符合條件的次字串彼此互相重疊也可以很容易全部找出來。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"}]},{"title":"Path Sum III","slug":"path-sum-III","date":"2017-03-08T16:00:00.000Z","updated":"2017-04-05T15:17:09.000Z","comments":true,"path":"2017/03/09/path-sum-III/","link":"","permalink":"https://blog.yunchen.tw/2017/03/09/path-sum-III/","excerpt":"","text":"Path Sum IIIYou are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000. For Example:123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\3 -2 1Return 3. The paths that sum to 8 are:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 提示 解題應用 Tree 前序遍歷 Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func pathSum(root *TreeNode, sum int) int &#123;&#125; 解答思路:這題最大的麻煩在於任一個點都可以成為起始點，此外若有某條路徑已經達到目標總合，仍需繼續往下做判斷，因為還是有可能再次達到目標總合，這時又算是另外符合條件的路徑，既然不曉得哪些點為起始時能達到目標總合，只好將所有的點都當作起始點來尋找，也就是每個節點與其以下的子節點都再當作一顆獨立的樹來遍歷，再找出以該節點為根節點開始路徑的所有可能，因此總共需要兩次遍歷，一次遍歷所有的節點，另一次則是遍歷以該節點為根節點的樹並從其開始的所有路徑，最後再將每個獨立樹找出的所有路徑再全部做總合就是我們的結果。 程式碼解說:一開始先檢查樹的根節點是否存在，若不存在則回傳0，接著才開始遍歷所有節點 123456func pathSum(root *TreeNode, sum int) int &#123; if root == nil &#123; return 0 &#125; return preOrderTravel(root, sum, 0)&#125; 第一次的前序遍歷是要將樹所有的節點當作根節點作為獨立的小樹，treeSum的function是我們為小樹做第二次前序遍歷，並將該小樹的所有可能回傳，若左右子節點為空表示沒有其它能再次遍歷的小樹，因此直接回傳目前符合條件的路徑數，如果有左右任一子節點為空，則遍歷另一側的子節點生成小樹，最後若左右子節點皆不為空，遍歷兩側節點並生成兩邊小樹，這裡要注意的是因為符合條件的路徑數是由上往下累加，如果將累加數同時帶入左右兩邊會造成重覆計算，所以只要挑其中一邊繼續累加，另一邊則從頭開始算 1234567891011func preOrderTravel(node *TreeNode, sum int, count int) int &#123; count += treeSum(node, sum, 0) if node.Left == nil &amp;&amp; node.Right == nil &#123; return count &#125; else if node.Left == nil &#123; return preOrderTravel(node.Right, sum, count) &#125; else if node.Right == nil &#123; return preOrderTravel(node.Left, sum, count) &#125; return preOrderTravel(node.Left, sum, count) + preOrderTravel(node.Right, sum, 0)&#125; 再來第二次的前序遍歷則是遍歷每個節點為根節點所生成小樹，並計算所有可能，總合與路徑節點值相減歸0，表示該路徑符合條件，此時將路徑數+1但不要回傳，仍要繼續往下確定同一路徑到葉節點是否還存在其它符合條件的可能，如果左右子節點為空，此時才可以放心回傳路徑數，而如果左右任一為空則往另一則繼續判斷其它路徑的可能性，最後如果左右子節點都不為空，則都要繼續遍歷並判斷所有可能，而與前一次遍歷一樣的狀況，如果將累加數同時帶入左右兩邊會造成重覆計算，所以也是挑其中一邊繼續累加，另一邊則從頭開始算 1234567891011121314func treeSum(node *TreeNode, sum int, count int) int &#123; tmp := sum - node.Val if tmp == 0 &#123; count++ &#125; if node.Left == nil &amp;&amp; node.Right == nil &#123; return count &#125; else if node.Left == nil &#123; return treeSum(node.Right, tmp, count) &#125; else if node.Right == nil &#123; return treeSum(node.Left, tmp, count) &#125; return treeSum(node.Left, tmp, count) + treeSum(node.Right, tmp, 0)&#125; 完整程式碼:12345678910111213141516171819202122232425262728293031func pathSum(root *TreeNode, sum int) int &#123; if root == nil &#123; return 0 &#125; return preOrderTravel(root, sum, 0)&#125;func preOrderTravel(node *TreeNode, sum int, count int) int &#123; count += treeSum(node, sum, 0) if node.Left == nil &amp;&amp; node.Right == nil &#123; return count &#125; else if node.Left == nil &#123; return preOrderTravel(node.Right, sum, count) &#125; else if node.Right == nil &#123; return preOrderTravel(node.Left, sum, count) &#125; return preOrderTravel(node.Left, sum, count) + preOrderTravel(node.Right, sum, 0)&#125;func treeSum(node *TreeNode, sum int, count int) int &#123; tmp := sum - node.Val if tmp == 0 &#123; count++ &#125; if node.Left == nil &amp;&amp; node.Right == nil &#123; return count &#125; else if node.Left == nil &#123; return treeSum(node.Right, tmp, count) &#125; else if node.Right == nil &#123; return treeSum(node.Left, tmp, count) &#125; return treeSum(node.Left, tmp, count) + treeSum(node.Right, tmp, 0)&#125; 總結:若有一顆二元樹，其所有節點都能做為根節點，且達目標總合時不需於葉子節點結束，找出所有的路徑，而最大的麻煩在於任一個點都可以成為起始點，此外若有某條路徑已經達到目標總合，仍需繼續往下做判斷，因為還是有可能再次達到目標總合，這時又算是另外符合條件的路徑，因此總共需要兩次遍歷，一次遍歷所有的節點，另一次則是遍歷以該節點為根節點的樹並從其開始的所有路徑，最後再將每個獨立樹找出的所有路徑再全部做總合就是我們的結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"}]},{"title":"Number of Segments in a String","slug":"number-of-segments in a String","date":"2017-03-07T16:00:00.000Z","updated":"2017-04-05T15:16:59.000Z","comments":true,"path":"2017/03/08/number-of-segments in a String/","link":"","permalink":"https://blog.yunchen.tw/2017/03/08/number-of-segments in a String/","excerpt":"","text":"Number of Segments in a StringCount the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters. Please note that the string does not contain any non-printable characters. For Example:12Input: &quot;Hello, my name is John&quot;Output: 5 提示 解題應用 String 規律觀查 Default:123func countSegments(s string) int &#123;&#125; 解答思路:這題最主要是一定要先看到非空格的值，之後出現空格才將計數+1，如果只看空格有多少個，會因為參數只有滿滿的空格而誤判，而如果有非語系的特殊符號因為無法顯示也可能會產生空格，不過題目這邊就有強調不會包含任何印不出的字元，所以可以放心。 程式碼解說:一開始先利用迴圈一一取出字串中的字元，並將rune值轉為字串，接著當該字串非為空格時先做個註記，直到出現的字元為空格且先前已經有非空格的註記時，這時我們才把計數+1，並把notSpace改回false重新計算下一個單字直到遍歷結束，不過可能會發生該單字在字串的結尾，沒有了空格因而少算了一個單字，所以最後要再次判斷notSpace的註記是否為true，如果是就將結果+1再回傳，否則就直接回傳結果 12345678910111213141516var str stringvar count intvar notSpace boolfor _, v := range s &#123; str = string(v) if str != \" \" &#123; notSpace = true &#125; else if str == \" \" &amp;&amp; notSpace &#123; count++ notSpace = false &#125;&#125;if notSpace &#123; return count + 1&#125;return count 完整程式碼:123456789101112131415161718func countSegments(s string) int &#123; var str string var count int var notSpace bool for _, v := range s &#123; str = string(v) if str != \" \" &#123; notSpace = true &#125; else if str == \" \" &amp;&amp; notSpace &#123; count++ notSpace = false &#125; &#125; if notSpace &#123; return count + 1 &#125; return count&#125; 總結:要判斷一字串中有多少個單字，最主要就是一定要先看到非空格的值，之後出現空格才將計數+1，如果只看空格有多少個，會因為參數只有滿滿的空格而誤判。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"}]},{"title":"Add Strings","slug":"add-strings","date":"2017-03-06T16:00:00.000Z","updated":"2017-04-05T15:16:52.000Z","comments":true,"path":"2017/03/07/add-strings/","link":"","permalink":"https://blog.yunchen.tw/2017/03/07/add-strings/","excerpt":"","text":"Add StringsGiven two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2. Note: The length of both num1 and num2 is &lt; 5100. Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero. You must not use any built-in BigInteger library or convert the inputs to integer directly. 提示 解題應用 Math 規律觀查 Default:123func addStrings(num1 string, num2 string) string &#123;&#125; 解答思路:這題解法與我在ADD Binary極為相似，不過一開始的時候原本是直接各別將兩個數字的字串自行轉成數字相加後再轉回字串，然而題目有說數字的長度最長可以到5000多，所以一定是行不通會造成溢位，因此只能像二進位相加那樣，一個位元(或每個位數)慢慢相加處理再轉回字串，本題大致上來說就是將兩字串先從個位數開始計算，先將個位數字串轉為數字相加後再轉回字串(皆為利用ASCII轉換)，同時判斷是否超過10而標註進位，接著才繼續相加下一個位數，如果前一位數有進位就要記得再+1，最後重覆上述動作直到相加結束。 程式碼解說:一開始先取得兩字串的長度，因為在同時一一取出數字字串時可能發生其一已經取完了，而另一則還有數字尚未取出，因此在用迴圈無窮取出時，誰先將數字取完就成了終止條件，此時先將另一字串尚未取完的部分保存下來，同時順便計算長度以利後續處理，若兩字串皆尚未取出完畢，將分別取出的數字字串轉為數字，因字串”0”的ASCII為48，所以要先將rune值減去48再將其轉回數字，接著將兩個分別取出的數字做相加，如果先前有進位的情況則要再+1，接著再次判斷加否有超過10，如果有則標註為有進位true的狀況，沒有則將其改為false，最後再跟10取餘數，而這次要變回ASCII中的字串，所以要再加上48才轉回字串，最後才繼續處理下一個位數的相加 12345678910111213141516171819202122232425262728293031var result stringvar sum intvar tmp stringvar length intvar carry boollen1 := len(num1)len2 := len(num2)for true &#123; if len1 == 0 &#123; tmp = num2[0:len2] length = len(tmp) break &#125; if len2 == 0 &#123; tmp = num1[0:len1] length = len(tmp) break &#125; sum = int(num1[len1-1]-48) + int(num2[len2-1]-48) if carry &#123; sum++ &#125; if sum &gt;= 10 &#123; carry = true &#125; else &#123; carry = false &#125; result = string((sum%10)+48) + result len1-- len2--&#125; 上述處理完畢後，再來就是尚未取出的數字，因為相加大致上都已經處理完畢，只剩前面尚未取出的位數與上述完成相加後是否還有進位，因此若還有進位的情況迴圈就繼續處理，或者連未取出的部分都已經完全取出了但還是有進位的情況，表示相加後長度又增長了，此時只要在結果前面加上進位的”1”即可，若是有進位而數字也尚未完全取出，這時一樣也就是先將rune值減去48後再轉為數字，因為有進位所以+1，再來也是判斷有沒有超過10，沒有就標註false並且一樣轉回數字放入結果開頭，因為這部分只剩未取出的位數與進位的問題，所以一但沒有進位那麼後面也不會再進位了 1234567891011121314for carry &#123; if length == 0 &#123; if carry &#123; result = \"1\" + result &#125; break &#125; sum = int(tmp[length-1]-48) + 1 if sum &lt; 10 &#123; carry = false &#125; result = string((sum%10)+48) + result length--&#125; 因為可能進位只到一半就結束了，可能前面還是有未處理的數字，此時只要判斷先前剩餘的部分長度加否大於0，如果是就把最後剩下的全部直接放入結果開頭節可，若都已經沒有剩餘的部分則直接回傳結果 1234if length &gt; 0 &#123; result = tmp[0:length] + result&#125;return result 完整程式碼:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051func addStrings(num1 string, num2 string) string &#123; var result string var sum int var tmp string var length int var carry bool len1 := len(num1) len2 := len(num2) for true &#123; if len1 == 0 &#123; tmp = num2[0:len2] length = len(tmp) break &#125; if len2 == 0 &#123; tmp = num1[0:len1] length = len(tmp) break &#125; sum = int(num1[len1-1]-48) + int(num2[len2-1]-48) if carry &#123; sum++ &#125; if sum &gt;= 10 &#123; carry = true &#125; else &#123; carry = false &#125; result = string((sum%10)+48) + result len1-- len2-- &#125; for carry &#123; if length == 0 &#123; if carry &#123; result = \"1\" + result &#125; break &#125; sum = int(tmp[length-1]-48) + 1 if sum &lt; 10 &#123; carry = false &#125; result = string((sum%10)+48) + result length-- &#125; if length &gt; 0 &#123; result = tmp[0:length] + result &#125; return result&#125; 總結:要將兩數字字串相加並回傳字串，且不得使用任何library，大致上來說就是將兩字串先從個位數開始計算，先將個位數字串轉為數字相加後再轉回字串(皆為利用ASCII轉換)，同時判斷是否超過10而標註進位，接著才繼續相加下一個位數，如果前一位數有進位就要記得再+1，最後重覆上述動作直到相加結束。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"Third Maximum Number","slug":"third-maximum-number","date":"2017-03-05T16:00:00.000Z","updated":"2017-04-05T15:16:45.000Z","comments":true,"path":"2017/03/06/third-maximum-number/","link":"","permalink":"https://blog.yunchen.tw/2017/03/06/third-maximum-number/","excerpt":"","text":"Third Maximum NumberGiven a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n). Example 1: 12345Input: [3, 2, 1]Output: 1Explanation: The third maximum is 1. Example 2: 123456Input: [1, 2]Output: 2Explanation: The third maximum does not exist, so the maximum (2) is returned instead. Example 3: 123456Input: [2, 2, 3, 1]Output: 1Explanation: Note that the third maximum here means the third maximum distinct number.Both numbers with value 2 are both considered as second maximum. 提示 解題應用 Array Array Default:123func longestPalindrome(s string) int &#123;&#125; 解答思路:寫下來有兩個重點，一個是題目帶的參數會有32位元int的極小值，意味著初始化如果是0的情況下，比大小可能會產生問題，所以預設前三個大小的值一定也要是32位元int的極小值，另外一個重點是在判斷如果沒有第三大的數時要回傳最大的數，這邊可以用一hashmap來篩選共有多少不相同獨特的數字，最後如果hashmap的長度不滿3表示不可能有第三大的數，就可以直接回傳最大的數，至於前三大的數怎麼知道，就是將陣列一個個與前三個值相比，比較大就取代掉僅僅如此。 程式碼解說:一開始先初始化前三大數的值為int的32位元極小值及一hashmap來知道有多少獨特的數字，接著便是開始利用迴圈遍歷整個陣列，如果該值存在在hashmap之中表示已經重覆出現在前三大數中，此時就不需要在做判斷，如果尚未出現過的話則與前三大數做比較，如果比最大的值還大則原本第二大取代第三大，原本第一大取代第二大，再來才將最大值的位置給該值存放，而其它比第二大的值或第三大的值還大則一樣依序將值往後推，最後只要判斷hashmap的長度如果沒有超過3，表示獨特的數不足3因此不存在第三大的數，回傳最大值，若有超過3則回傳第三大的值 123456789101112131415161718192021222324first := math.MinInt32second := math.MinInt32third := math.MinInt32hashMap := make(map[int]int)for _, v := range nums &#123; _, ok := hashMap[v] if !ok &#123; if v &gt;= first &#123; third = second second = first first = v &#125; else if v &gt;= second &#123; third = second second = v &#125; else if v &gt;= third &#123; third = v &#125; hashMap[v] = v &#125;&#125;if len(hashMap) &lt; 3 &#123; return first&#125;return third 完整程式碼:1234567891011121314151617181920212223242526func thirdMax(nums []int) int &#123; first := math.MinInt32 second := math.MinInt32 third := math.MinInt32 hashMap := make(map[int]int) for _, v := range nums &#123; _, ok := hashMap[v] if !ok &#123; if v &gt;= first &#123; third = second second = first first = v &#125; else if v &gt;= second &#123; third = second second = v &#125; else if v &gt;= third &#123; third = v &#125; hashMap[v] = v &#125; &#125; if len(hashMap) &lt; 3 &#123; return first &#125; return third&#125; 總結:要找出一陣列中第三大的數有兩個重點，一個是題目帶的參數會有32位元int的極小值，意味著初始化如果是0的情況下，比大小可能會產生問題，所以預設前三個大小的值一定也要是32位元int的極小值，另外一個重點是在判斷如果沒有第三大的數時要回傳最大的數，這邊可以用一hashmap來篩選共有多少不相同獨特的數字，最後如果hashmap的長度不滿3表示不可能有第三大的數，就可以直接回傳最大的數，至於前三大的數怎麼知道，就是將陣列一個個與前三個值相比，比較大就取代掉僅僅如此。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"}]},{"title":"Fizz Buzz","slug":"fizz-buzz","date":"2017-03-04T16:00:00.000Z","updated":"2017-04-05T15:16:29.000Z","comments":true,"path":"2017/03/05/fizz-buzz/","link":"","permalink":"https://blog.yunchen.tw/2017/03/05/fizz-buzz/","excerpt":"","text":"Fizz BuzzWrite a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. For Example:1234567891011121314151617181920n = 15,Return:[ &quot;1&quot;, &quot;2&quot;, &quot;Fizz&quot;, &quot;4&quot;, &quot;Buzz&quot;, &quot;Fizz&quot;, &quot;7&quot;, &quot;8&quot;, &quot;Fizz&quot;, &quot;Buzz&quot;, &quot;11&quot;, &quot;Fizz&quot;, &quot;13&quot;, &quot;14&quot;, &quot;FizzBuzz&quot;] Default:123func fizzBuzz(n int) []string &#123;&#125; 解答思路:這題相當的讓我印象深刻，不外乎是朋友應徵資深工作而面試卻出了這麼一題，不論是資料分析的工作還是網頁的工作都有人碰到，總之這題就是給予1~n，當該數同時為3與5的倍數時，回傳FizzBuzz，若只是3的倍數則回傳Fizz，而若只是5的倍數則回傳Buzz，初次學習程式語言的人應該都有碰過類似的題目。 程式碼解說:首先先宣告一空陣列字串，接著就開始從1~n遍歷，當該數同時為3與5的倍數時(餘數為0)，插入FizzBuzz，你也可以直接寫15的倍數，而若只是3的倍數則插入Fizz，而若只是5的倍數則插入Buzz，如果上述的情況都不是的話則將該數轉為該數的字串並插入，最後在遍歷結束後回傳整個結果。 12345678910111213var result []stringfor i := 1; i &lt;= n; i++ &#123; if i%3 == 0 &amp;&amp; i%5 == 0 &#123; result = append(result, \"FizzBuzz\") &#125; else if i%3 == 0 &#123; result = append(result, \"Fizz\") &#125; else if i%5 == 0 &#123; result = append(result, \"Buzz\") &#125; else &#123; result = append(result, strconv.Itoa(i)) &#125;&#125;return result 完整程式碼:123456789101112131415func fizzBuzz(n int) []string &#123; var result []string for i := 1; i &lt;= n; i++ &#123; if i%3 == 0 &amp;&amp; i%5 == 0 &#123; result = append(result, \"FizzBuzz\") &#125; else if i%3 == 0 &#123; result = append(result, \"Fizz\") &#125; else if i%5 == 0 &#123; result = append(result, \"Buzz\") &#125; else &#123; result = append(result, strconv.Itoa(i)) &#125; &#125; return result&#125; 總結:Fizz Buzz是給予1~n，當該數同時為3與5的倍數時，回傳FizzBuzz，若只是3的倍數則回傳Fizz，而若只是5的倍數則回傳Buzz。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"}]},{"title":"Longest Palindrome","slug":"longest-palindrome","date":"2017-03-03T16:00:00.000Z","updated":"2017-04-05T15:16:17.000Z","comments":true,"path":"2017/03/04/longest-palindrome/","link":"","permalink":"https://blog.yunchen.tw/2017/03/04/longest-palindrome/","excerpt":"","text":"Longest PalindromeGiven a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example “Aa” is not considered a palindrome here. Note: Assume the length of given string will not exceed 1,010. For Example:12345678Input:&quot;abccccdd&quot;Output:7Explanation:One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7. 提示 解題應用 HashTable HashMap Default:123func longestPalindrome(s string) int &#123;&#125; 解答思路:如果要知道最長回文的長度，首先要知道回文的特色，通常就是兩兩對稱，換句話說就是兩個相同的為一組，而最中間的有可能一個落單，也有可能一樣是一組相同的值，利用這個大多數都是對稱兩個相同為一組的特性，只要找出像這樣相同的共有幾對，最後再看看有沒有剩下落單的值，就可以很容易找出最長回文的長度。 程式碼解說:因為要確定是否存在一組相同的字串，一開始先初始化一hashmap，key值拿來存字元的rune值而value則隨意，這邊也拿來存字元的rune值，接著開始遍歷字串中的每個字元，如果該字元存在在hashmap之中，就將該字元從hashmap中移除，並且將結果長度+2(一組2個)，如果該字元不存在或者已經找到成對而被移除了，就再一次放入hashmap之中直到出現下一個相同的字元，最後在結束遍歷之後檢查hashmap中有沒有剩下落單的字元，如果有就將任其一拿來當作回文最中間的值，此時回傳長度+1，若沒有則直接將長度回傳即可 123456789101112131415var length inthashMap := make(map[rune]rune)for _, v := range s &#123; _, ok := hashMap[v] if ok &#123; delete(hashMap, v) length = length + 2 &#125; else &#123; hashMap[v] = v &#125;&#125;if len(hashMap) &gt; 0 &#123; return length + 1&#125;return length 完整程式碼:1234567891011121314151617func longestPalindrome(s string) int &#123; var length int hashMap := make(map[rune]rune) for _, v := range s &#123; _, ok := hashMap[v] if ok &#123; delete(hashMap, v) length = length + 2 &#125; else &#123; hashMap[v] = v &#125; &#125; if len(hashMap) &gt; 0 &#123; return length + 1 &#125; return length&#125; 總結:要找出一字串中能組出最長回文的長度，首先要知道回文的特色，通常就是兩個相同的為一組對稱，而最中間的有可能一個落單，也有可能一樣是一組相同的值，利用這個大多數都是對稱兩個相同為一組的特性，只要找出相同的共有幾對，最後再看看有沒有剩下落單的值，就可以很容易找出最長回文的長度。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"}]},{"title":"Convert a Number to Hexadecimal","slug":"convert-a-number-to-hexadecimal","date":"2017-03-02T16:00:00.000Z","updated":"2017-04-05T15:16:06.000Z","comments":true,"path":"2017/03/03/convert-a-number-to-hexadecimal/","link":"","permalink":"https://blog.yunchen.tw/2017/03/03/convert-a-number-to-hexadecimal/","excerpt":"","text":"Convert a Number to HexadecimalGiven an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used. Note: All letters in hexadecimal (a-f) must be in lowercase. The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character ‘0’; otherwise, the first character in the hexadecimal string will not be the zero character. The given number is guaranteed to fit within the range of a 32-bit signed integer. You must not use any method provided by the library which converts/formats the number to hex directly. Example 1:12345Input:26Output:&quot;1a&quot; Example 2:12345Input:-1Output:&quot;ffffffff&quot; 提示 解題應用 BitManipulation Hex Default:123func toHex(num int) string &#123;&#125; 解答思路:基本上只要能將正值寫出了，負值就不是什麼大問題了，因為可以把負值當作溢位的正值，意思就是int的32位元極大值為2147483647，因為+1就會溢位但也表示2147483648等同於-2147483648，而如果在順勢向後推，4294967295也就等同於-1，再來只要以正常處理正值的處理方式，先除以16(16位元)取餘數後判斷其是否為10到15，如果是就轉為a~f，否則就直接將數字轉為字串型別，之後將結果放入回傳字串的開頭，最後原本正值除以16的商數，再拿來不斷重覆上述動作直到商數歸0為止。 程式碼解說:首先先判斷該10進位的值是否為負數，若是則轉成一超過極大值的正數，而若為0則回傳字串”0”，接著就開始不斷將該數與16相除，若餘數大於等於10則需轉為字母，先將該餘數-10再加上97之後直接強制將其值轉為字串(ASCII)，若小於10則將該數轉為該字的字串(強制轉會變ASCII)，之後再把剛剛的字串放入結果開頭，最後將正數與16相除的商數賦予回去，不斷重覆上述動作直到商數歸0並回傳結果 123456789101112131415if num &lt; 0 &#123; num = 4294967296 + num&#125; else if num == 0 &#123; return \"0\"&#125;var result stringfor num &gt; 0 &#123; if num%16 &gt;= 10 &#123; result = string((num%16-10)+97) + result &#125; else &#123; result = strconv.Itoa(num%16) + result &#125; num = num / 16&#125;return result 完整程式碼:1234567891011121314151617func toHex(num int) string &#123; if num &lt; 0 &#123; num = 4294967296 + num &#125; else if num == 0 &#123; return \"0\" &#125; var result string for num &gt; 0 &#123; if num%16 &gt;= 10 &#123; result = string((num%16-10)+97) + result &#125; else &#123; result = strconv.Itoa(num%16) + result &#125; num = num / 16 &#125; return result&#125; 總結:要將10進位制數轉為16進位制時，若原數字為負數，透過溢位的方式將負數轉為一個超過極大值的正數，再來只要不斷將其值除以16取餘數，並判斷該餘數要轉字母還是保留為數字後放入結果字串的開頭，最後不斷重覆將剛剛的商數再除16取餘數並判斷，直到商數歸0為止。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"BitManipulation","slug":"BitManipulation","permalink":"https://blog.yunchen.tw/tags/BitManipulation/"}]},{"title":"Sum of Left Leaves","slug":"sum-of-left-leaves","date":"2017-03-01T16:00:00.000Z","updated":"2017-04-05T15:15:53.000Z","comments":true,"path":"2017/03/02/sum-of-left-leaves/","link":"","permalink":"https://blog.yunchen.tw/2017/03/02/sum-of-left-leaves/","excerpt":"","text":"Sum of Left LeavesFind the sum of all left leaves in a given binary tree. For Example:1234567 3 / \\ 9 20 / \\ 15 7There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. 提示 解題應用 Tree 前序遍歷 Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func sumOfLeftLeaves(root *TreeNode) int &#123;&#125; 解答思路:非常容易的一題，基本上先寫出前序遍歷所有葉子節點的總合值之後，剩下的只要在多一個判斷來知道該”葉子”是否是右子節點，如果是就回傳0，否則就回傳節點原本的值，如此一來當”葉子”左右子節點都存在的時候，因為右子節點回傳值是0，總合相加的結果就會是只有”葉子”左子節點的值，之所以會強調葉子是因為若非葉子節點，不能直接將右子節點直接歸0，因為右邊可能還包含一顆子樹，所以最後判斷回傳值只能在確定為葉子節點的情況下做。 程式碼解說:一開始先確認根節點是否為nil，如果是就回傳0，否則才開始前序遍歷 123456func sumOfLeftLeaves(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; return preOrderTravel(root, false)&#125; 如果節點的左右子節點都為nil，就能確定該子節點為葉子節點，接著在判斷此葉子節點若為左側就回傳原本的值，如果是右則則回傳0，而如果該節點有一邊為nil另一邊不為nil，就繼續前序遍歷，並註明該子節點是否為左邊，如果是就將true做代入，否則右邊的子節點就代入false，而最後如果兩邊的子節點都存在，肯定不是葉子節點，直接將兩子節點值做總合回傳即可 12345678910111213func preOrderTravel(node *TreeNode, left bool) int &#123; if node.Left == nil &amp;&amp; node.Right == nil &#123; if left &#123; return node.Val &#125; return 0 &#125; else if node.Left == nil &#123; return preOrderTravel(node.Right, false) &#125; else if node.Right == nil &#123; return preOrderTravel(node.Left, true) &#125; return preOrderTravel(node.Left, true) + preOrderTravel(node.Right, false)&#125; 完整程式碼:12345678910111213141516171819func sumOfLeftLeaves(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; return preOrderTravel(root, false)&#125;func preOrderTravel(node *TreeNode, left bool) int &#123; if node.Left == nil &amp;&amp; node.Right == nil &#123; if left &#123; return node.Val &#125; return 0 &#125; else if node.Left == nil &#123; return preOrderTravel(node.Right, false) &#125; else if node.Right == nil &#123; return preOrderTravel(node.Left, true) &#125; return preOrderTravel(node.Left, true) + preOrderTravel(node.Right, false)&#125; 總結:要算出一樹某一側葉子節點的總合，首先先寫出全部葉子節點的總合，接著只要加入判斷是否為另一側的葉子節點，如果是的話在做回傳葉子節點值回傳值就回傳0，如此一來當左右葉子節點做總合時，就會是只有左葉子節點的值了。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"}]},{"title":"Binary Watch","slug":"binary-watch","date":"2017-02-28T16:00:00.000Z","updated":"2017-05-02T06:24:12.000Z","comments":true,"path":"2017/03/01/binary-watch/","link":"","permalink":"https://blog.yunchen.tw/2017/03/01/binary-watch/","excerpt":"","text":"Binary WatchA binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right. For example, the above binary watch reads “3:25”. Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent. Example:12Input: n = 1Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;] Note: The order of output does not matter. The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”. The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”. 提示 解題應用 Backtracking 遞回 BitManipulation 二進位位元組合 Default:123func backTracking(bin string, led int) []string &#123;&#125; 解答思路:一開始本來想用一陣列存著1,2,4,8,16,32然後再分別去排序組合所有情況，然而跟直接二進位組合只有0與1的情況相比，寫起來實在複雜太多，所以用二進位來傳值遞回的方式組合出所有的情況，你可以選擇小時與分鐘拆開來處理，不過因為手錶的信號也就10個燈，2的10次方不過1024種組合，所以我是將全數列出後才判斷小時與分鐘的規格是否正確。 程式碼解說:因為是使用遞回的關係，所以是不斷的呼叫自己，而直到長度到達10(手錶全部的燈)才停止遞回並做判斷，因為題目有限制一定要亮多少個燈的情況下的所有組合，所以如果前面還沒達到目標的燈數了，就再後頭補1並將燈數-1繼續遞回，其餘仍繼續後頭補0(表示不亮燈)尋找其它可能，最後等到兩者長度都達到10判斷結束後再一起合併將結果做回傳 123456789101112func backTracking(bin string, led int) []string &#123; var tmp []string var hrStr string var minStr string if len(bin) == 10 &#123; ... &#125; if led &gt; 0 &#123; tmp = backTracking(bin+\"1\", led-1) &#125; return append(backTracking(bin+\"0\", led), tmp...)&#125; 至於長度已經到達10的判斷，首先要先將沒有亮滿燈數的情況給除去(目標燈數歸0)，接著取前面四位元(代表四個燈)當做小時，其餘的則是當作分鐘，並將二進位字串轉回數字來判斷小時是否介於0~11，分鐘是否介於0~59，如果都符合則再判斷分鐘長度是否只有個位數來決定是否要在前面補0，最後才合併回傳字串陣列，若上述任一情況不符，則回傳空的字串陣列 12345678910111213if led == 0 &#123; hours, _ := strconv.ParseInt(bin[:4], 2, 64) minutes, _ := strconv.ParseInt(bin[4:], 2, 64) if hours &lt;= 11 &amp;&amp; minutes &lt;= 59 &#123; hrStr = strconv.Itoa(int(hours)) minStr = strconv.Itoa(int(minutes)) if len(minStr) == 1 &#123; minStr = \"0\" + minStr &#125; return []string&#123;hrStr + \":\" + minStr&#125; &#125;&#125;return []string&#123;&#125; 完整程式碼:123456789101112131415161718192021222324252627func readBinaryWatch(num int) []string &#123; return backTracking(\"\", num)&#125;func backTracking(bin string, led int) []string &#123; var tmp []string var hrStr string var minStr string if len(bin) == 10 &#123; if led == 0 &#123; hours, _ := strconv.ParseInt(bin[:4], 2, 64) minutes, _ := strconv.ParseInt(bin[4:], 2, 64) if hours &lt;= 11 &amp;&amp; minutes &lt;= 59 &#123; hrStr = strconv.Itoa(int(hours)) minStr = strconv.Itoa(int(minutes)) if len(minStr) == 1 &#123; minStr = \"0\" + minStr &#125; return []string&#123;hrStr + \":\" + minStr&#125; &#125; &#125; return []string&#123;&#125; &#125; if led &gt; 0 &#123; tmp = backTracking(bin+\"1\", led-1) &#125; return append(backTracking(bin+\"0\", led), tmp...)&#125; 總結:若需要列出所有二進位組合的情況，利用遞回新增0與1的方式是最快的選擇。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"},{"name":"BitManipulation","slug":"BitManipulation","permalink":"https://blog.yunchen.tw/tags/BitManipulation/"},{"name":"Backtracking","slug":"Backtracking","permalink":"https://blog.yunchen.tw/tags/Backtracking/"}]},{"title":"Nth Digit","slug":"nth-digit","date":"2017-02-27T16:00:00.000Z","updated":"2017-04-05T15:15:32.000Z","comments":true,"path":"2017/02/28/nth-digit/","link":"","permalink":"https://blog.yunchen.tw/2017/02/28/nth-digit/","excerpt":"","text":"Nth DigitFind the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, … Note: n is positive and will fit within the range of a 32-bit signed integer (n &lt; 231). Example 1:12345Input:3Output:3 Example 2:12345678Input:11Output:0Explanation:The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10. 提示 解題應用 Math 規律觀查 Default:123func findNthDigit(n int) int &#123;&#125; 解答思路:這題著手的關鍵點在於要先推算出的是原本的數值才找該個數字，而不是直接推算該個數字的規律，所以只要算出是幾位數，進而推出從該位數值開始算在第幾個而找出原本的數字，最後利用餘數找出在原本的數值上為第幾個數字。 程式碼解說:我們可以發現長度如下: 長度1 1~9 9個長度2 10~99 90個長度3 100~999 900個… 所以如果要找到原數的數值就先找出該數為幾位數(長度)，所以就將給予的n值依序減掉長度*有幾個數，然後每減掉一次就將計算的長度+1，直到n的值為負數，此時就可以得到原本數值的長度 12345678910var size intvar sizeCount inttmp := 9integer := 1for n &gt; 0 &#123; size++ sizeCount = size * tmp n = n - sizeCount tmp *= 10&#125; 因為n為負值，所以只要再把剛才減掉的數給加回來，此時的n值就代表某長度開始的第n個數字，再來開始找出原本的數值，因為各長度第一個數都是10的倍數，所以我們先找出該長度的第一個值，然後再將n除上長度(結果為該長度的第幾個數值)，兩個值相加後-1(因為包含該長度的第一個值)就可以找出從某長度開始的第n個數值 12345n = n + sizeCountfor i := 1; i &lt; size; i++ &#123; integer *= 10&#125;integer = integer + n/size - 1 不過如果n除上長度(結果為該長度的第幾個數值)有餘數存在，表示是在下一個數值，因此數值要再+1，又剛好此時的餘數正好代表該數值從前頭算起的目標數字，所以我們只要不斷從後頭除以10直到該位數字後取餘數，而如果沒有餘數存在就更容易了，表示目前找的數值的最後一位，直接跟10取餘數回傳即可 1234567if n%size != 0 &#123; integer++ for i := 1; i &lt;= size-n%size; i++ &#123; integer = integer / 10 &#125;&#125;return integer % 10 完整程式碼:123456789101112131415161718192021222324func findNthDigit(n int) int &#123; var size int var sizeCount int tmp := 9 integer := 1 for n &gt; 0 &#123; size++ sizeCount = size * tmp n = n - sizeCount tmp *= 10 &#125; n = n + sizeCount for i := 1; i &lt; size; i++ &#123; integer *= 10 &#125; integer = integer + n/size - 1 if n%size != 0 &#123; integer++ for i := 1; i &lt;= size-n%size; i++ &#123; integer = integer / 10 &#125; &#125; return integer % 10&#125; 總結:要推算一數列依序如字串般連結的第n個數字，著手的關鍵點在於要先推算出的是原本的數值才找該個數字，而不是直接推算該個數字的規律，所以只要算出是幾位數，進而推出從該位數值開始算在第幾個而找出原本的數字，最後利用餘數找出在原本的數值上為第幾個數字。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"Valid Perfect Square","slug":"valid-perfect-square","date":"2017-02-26T16:00:00.000Z","updated":"2017-04-05T15:15:25.000Z","comments":true,"path":"2017/02/27/valid-perfect-square/","link":"","permalink":"https://blog.yunchen.tw/2017/02/27/valid-perfect-square/","excerpt":"","text":"Valid Perfect SquareGiven a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1:12Input: 16Returns: True ###Example 2: 12Input: 14Returns: False 提示 解題應用 Math 規律觀查 Default:123func isPerfectSquare(num int) bool &#123;&#125; 解答思路:這題要判斷是否為平方數，且不能使用math的library，所以我們就從1的平方開始試，直到超過其值都還沒有發現某數的平方值等同於其值，最後才回傳false，如果中間有相同的結果則回傳true。 程式碼解說:用一變數來儲存我們計算平方值的結果，而從1來開始平方，如果計算出來的平方值等同其值，就回傳true，否則就繼續將常數+1，一直到算出的平方值超過其值，表示該值不為平方數回傳false 12345678910var square intcount := 1for square &lt; num &#123; square = count * count if square == num &#123; return true &#125; count++&#125;return false 完整程式碼:123456789101112func isPerfectSquare(num int) bool &#123; var square int count := 1 for square &lt; num &#123; square = count * count if square == num &#123; return true &#125; count++ &#125; return false&#125; 總結:要判斷一數是否為平方數，除了用開根號的方式來判斷是否為整數之外，也可以從1的平方開始嘗試，一直到超過其值都還沒有發現某數的平方值等同於其值，最後才回傳false，如果中間有相同的結果則回傳true。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://blog.yunchen.tw/tags/BinarySearch/"}]},{"title":"Sum of Two Integers","slug":"sum-of-two-integers","date":"2017-02-25T16:00:00.000Z","updated":"2017-04-05T15:15:17.000Z","comments":true,"path":"2017/02/26/sum-of-two-integers/","link":"","permalink":"https://blog.yunchen.tw/2017/02/26/sum-of-two-integers/","excerpt":"","text":"Sum of Two IntegersCalculate the sum of two integers a and b, but you are not allowed to use the operator + and -. For Example:1Given a = 1 and b = 2, return 3. 提示 解題應用 BitManipulation XOR,AND Default:123func getSum(a int, b int) int &#123;&#125; 解答思路:這讓我想到很久以前做的加法器Verilog，總之需要知道一些關於二進位上的實作，否則可能需要想一段時間，一般來說相加用XOR實作，因為1與0可以被保留，而1與1則歸0表示進位，正好是我們所需要的結果，但是還要再對那些進位的狀況做處理，會進位的狀況只有兩個1，所以先用AND來實做，接著才向左位移1，而這時候我們再用XOR對進位做相加，一直到沒有進位的狀況即可完成加法實作。 程式碼解說:這邊用遞回來實作，a是兩數XOR不包含進位的狀況運算後的結果，而b則是兩數AND後左移代表進位後的結果，如果b為0表示沒有進位的問題就直接回傳a，否則就再重覆上述動作直到b為0為止 123456func getSum(a int, b int) int &#123; if b == 0 &#123; return a &#125; return getSum(a^b, (a&amp;b)&lt;&lt;1)&#125; 完整程式碼:123456func getSum(a int, b int) int &#123; if b == 0 &#123; return a &#125; return getSum(a^b, (a&amp;b)&lt;&lt;1)&#125; 總結:要用XOR與AND來實作二進位加法，一般來說相加用XOR實作，因為1與0可以被保留，而1與1則歸0表示進位，正好是我們所需要的結果，但是還要再對那些進位的狀況做處理，會進位的狀況只有兩個1，所以先用AND來實做，接著才向左位移1，而這時候我們再用XOR對進位做相加，一直到沒有進位的狀況即可完成加法實作。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"BitManipulation","slug":"BitManipulation","permalink":"https://blog.yunchen.tw/tags/BitManipulation/"}]},{"title":"Reverse Vowels of a String","slug":"reverse-vowels-of-a-string","date":"2017-02-24T16:00:00.000Z","updated":"2017-04-05T15:15:09.000Z","comments":true,"path":"2017/02/25/reverse-vowels-of-a-string/","link":"","permalink":"https://blog.yunchen.tw/2017/02/25/reverse-vowels-of-a-string/","excerpt":"","text":"Reverse Vowels of a StringWrite a function that takes a string as input and reverse only the vowels of a string. Example1:1Given s = &quot;hello&quot;, return &quot;holle&quot;. Example 2:1Given s = &quot;leetcode&quot;, return &quot;leotcede&quot;. Note: The vowels does not include the letter “y”. 提示 解題應用 TwoPointers 記錄index位置 Default:123func reverseVowels(s string) string &#123;&#125; 解答思路:這題需要你依續從最前面與最後面往中間遍歷時，遇到母音a,e,i,o,u含大寫時，要將彼此對調，所以理所當然就是用兩個flag來記錄從最前面與最後面往中間遍歷時到達的位置，如果其中一邊碰上了母音就停止遍歷，必須要等另一邊也碰上母音才對調，之後兩邊才又繼續往中間移動判斷直到全部遍歷完。 程式碼解說:這邊用front與rear來紀錄目前從最前面與最後面開始往中間遍歷時所到達的index，自然front就是0而rear則是長度-1，接著就利用迴圈開始遍歷直到front超過rear，前後各取出rune值後就先轉成字串，接著就分別由兩個對應的switch來處理 123456789var frontChar stringvar rearChar stringfront := 0rear := len(s) - 1for front &lt; rear &#123; frontChar = string(s[front]) rearChar = string(s[rear])&#125;return s 如果開頭開始遍歷取出的字母為母音含大寫時，就將當前的index值給紀錄下來，如果從後頭遍歷的index還沒被紀錄(為極大值)，表示後頭尚未找到母音的字，必須要等雙方的index都被紀錄下來才能將彼此對調，說穿了對調字母其實就是重組整個字串，對調完成之後就將紀錄到的index值設回極大值，同時將前後目前遍歷到達的位置各往中間移，接著才又繼續開始遍歷，而其它非母音的值則是將開頭遍歷的index直接下移就好 1234567891011121314switch frontChar &#123;case \"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\": frontFlag = front if rearFlag != math.MaxInt32 &#123; s = string(s[:frontFlag]) + rearChar + string(s[frontFlag+1:rearFlag]) + frontChar + string(s[rearFlag+1:]) frontFlag = math.MaxInt32 rearFlag = math.MaxInt32 front++ rear-- continue &#125;default: front++&#125; 與開頭遍歷的做法一樣，從後頭遍歷就紀錄後頭所到達的index，接著並判斷前頭遍歷的index是否已被紀錄，而對調的程式碼則是一模一樣，最後其它非母音的值則是將後頭遍歷的index直接上移 1234567891011121314switch rearChar &#123;case \"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\": rearFlag = rear if frontFlag != math.MaxInt32 &#123; s = string(s[:frontFlag]) + rearChar + string(s[frontFlag+1:rearFlag]) + frontChar + string(s[rearFlag+1:]) frontFlag = math.MaxInt32 rearFlag = math.MaxInt32 front++ rear-- continue &#125;default: rear--&#125; 完整程式碼:1234567891011121314151617181920212223242526272829303132333435363738394041func reverseVowels(s string) string &#123; var frontChar string var rearChar string frontFlag := math.MaxInt32 rearFlag := math.MaxInt32 front := 0 rear := len(s) - 1 for front &lt; rear &#123; frontChar = string(s[front]) rearChar = string(s[rear]) switch frontChar &#123; case \"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\": frontFlag = front if rearFlag != math.MaxInt32 &#123; s = string(s[:frontFlag]) + rearChar + string(s[frontFlag+1:rearFlag]) + frontChar + string(s[rearFlag+1:]) frontFlag = math.MaxInt32 rearFlag = math.MaxInt32 front++ rear-- continue &#125; default: front++ &#125; switch rearChar &#123; case \"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\": rearFlag = rear if frontFlag != math.MaxInt32 &#123; s = string(s[:frontFlag]) + rearChar + string(s[frontFlag+1:rearFlag]) + frontChar + string(s[rearFlag+1:]) frontFlag = math.MaxInt32 rearFlag = math.MaxInt32 front++ rear-- continue &#125; default: rear-- &#125; &#125; return s&#125; 總結:要前後對調一字串中特定幾個字，可以利用兩個flag來紀錄從最前面與最後面往中間遍歷時到達的位置，如果其中一邊碰上了目標就停止遍歷，必須要等另一邊也碰上對應字才對調，之後兩邊才又繼續往中間移動判斷直到全部遍歷完。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"}]},{"title":"Ransom Note","slug":"ransom-note","date":"2017-02-23T16:00:00.000Z","updated":"2017-04-05T15:15:03.000Z","comments":true,"path":"2017/02/24/ransom-note/","link":"","permalink":"https://blog.yunchen.tw/2017/02/24/ransom-note/","excerpt":"","text":"Ransom NoteGiven an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. Note: You may assume that both strings contain only lowercase letters. 123canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true 提示 解題應用 String HashTable Default:123func canConstruct(ransomNote string, magazine string) bool &#123;&#125; 解答思路:要判斷一字串中是否包含另一字串的每一個字母，順序甚至是被打散都沒關係，只要有出現就可以了，那麼我們只要用hashmap將需要被包含的每個字母放入，而在遍歷目標字串時檢查hashmap是否有該字母，有的話就將其從hashmap中取出，最後遍歷完成時，如果hashmap為空表示目標字串完全包含了另一字串的每一個字母。 程式碼解說:一開始初始化完一hashmap之後，就將要被包含的字串ransomNote的每個字母放入hashmap，其中key為rune值而value則是用來存放每個字母出現的次數，再來就是開始核對目標字串magazine的字母是否有在hashmap之中，如果有就將數量-1，該字母的數量已經歸0了的話則直接將其從hashmap中移除，最後在目標字串遍歷結束之後檢查hashmap的長度，完全包含的情況下長度會為0回傳true，否則回傳false 123456789101112131415161718hashMap := make(map[rune]int)for _, v := range ransomNote &#123; hashMap[v] += 1&#125;for _, v := range magazine &#123; amount, ok := hashMap[v] if ok &#123; if amount-1 == 0 &#123; delete(hashMap, v) &#125; else &#123; hashMap[v] = amount - 1 &#125; &#125;&#125;if len(hashMap) == 0 &#123; return true&#125;return false 完整程式碼:1234567891011121314151617181920func canConstruct(ransomNote string, magazine string) bool &#123; hashMap := make(map[rune]int) for _, v := range ransomNote &#123; hashMap[v] += 1 &#125; for _, v := range magazine &#123; amount, ok := hashMap[v] if ok &#123; if amount-1 == 0 &#123; delete(hashMap, v) &#125; else &#123; hashMap[v] = amount - 1 &#125; &#125; &#125; if len(hashMap) == 0 &#123; return true &#125; return false&#125; 總結:要判斷一字串中是否包含另一字串的每一個字母，順序、位置不限，只要用hashmap將需要被包含的每個字母放入，而在遍歷目標字串時檢查hashmap是否有該字母，有的話就將其從hashmap中取出，最後遍歷完成時，如果hashmap為空表示目標字串完全包含了另一字串的每一個字母。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"}]},{"title":"Intersection of Two Arrays","slug":"intersection-of-two-arrays","date":"2017-02-22T16:00:00.000Z","updated":"2017-04-05T15:14:55.000Z","comments":true,"path":"2017/02/23/intersection-of-two-arrays/","link":"","permalink":"https://blog.yunchen.tw/2017/02/23/intersection-of-two-arrays/","excerpt":"","text":"Intersection of Two ArraysGiven two arrays, write a function to compute their intersection. ###For Example: 1Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2]. Note: Each element in the result must be unique. The result can be in any order. 提示 解題應用 HashTable HashMap Default:123func intersection(nums1 []int, nums2 []int) []int &#123;&#125; 解答思路:這次只是要找兩陣列有交集的部分，也就是說只要回傳兩陣列共同都有的值且不能重複，而最簡單的做法就是用hashmap來完成，只要其中一個陣列先存入hashmap，另一個只要核對就可以了，而先存入的那一個就算裡面有重覆也只是將key&amp;value做覆蓋，並不會再新增一個，而這邊我們key就放陣列的值，value則是放boolean值在核對完後，用來確認是否已將此數放入結果之中，如果已經有放入了就不需要再放一次以避免重覆。 程式碼解說:一開始先為結果初始化一空陣列及一個儲存的hashmap，而第一個迴圈就是遍歷第一個陣列並一一放入hashmap中，key值為元素值，而value則為false(此時尚未放入結果之中)，而就算陣列有值重覆，在hashamp之中也只是做覆蓋，而第二個迴\b圈開始遍歷第二個陣列核對其元素是否存在，如果存在表示該元素為兩陣列的交集之一，再來則是確認value(already)是否未放入結果之中，如果也尚未放入結果就可以安心將其值加入，並將該value值改成true，最後再第二個陣列核對完畢後回傳結果。 12345678910111213result := []int&#123;&#125;hashMap := make(map[int]bool)for _, v := range nums1 &#123; hashMap[v] = false&#125;for _, v := range nums2 &#123; already, ok := hashMap[v] if ok &amp;&amp; !already &#123; hashMap[v] = true result = append(result, v) &#125;&#125;return result 完整程式碼:123456789101112131415func intersection(nums1 []int, nums2 []int) []int &#123; result := []int&#123;&#125; hashMap := make(map[int]bool) for _, v := range nums1 &#123; hashMap[v] = false &#125; for _, v := range nums2 &#123; already, ok := hashMap[v] if ok &amp;&amp; !already &#123; hashMap[v] = true result = append(result, v) &#125; &#125; return result&#125; 總結:要尋找兩陣列的交集且回傳時不可包含重覆的元素，此時先用hashmap來儲存第一個陣列，key值為該陣列的元素，而value則是boolean值，value為當另一陣列除了要確認元素是否存在，還必需要知道此元素是否己經放入結果之中以避免重覆。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"},{"name":"Sort","slug":"Sort","permalink":"https://blog.yunchen.tw/tags/Sort/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://blog.yunchen.tw/tags/BinarySearch/"}]},{"title":"Intersection of Two Arrays II","slug":"intersection-of-two-arrays II","date":"2017-02-21T16:00:00.000Z","updated":"2017-04-05T15:14:49.000Z","comments":true,"path":"2017/02/22/intersection-of-two-arrays II/","link":"","permalink":"https://blog.yunchen.tw/2017/02/22/intersection-of-two-arrays II/","excerpt":"","text":"Intersection of Two Arrays IIGiven two arrays, write a function to compute their intersection. For Example:1Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2]. Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1’s size is small compared to nums2’s size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? 提示 解題應用 HashTable HashMap Default:123func intersect(nums1 []int, nums2 []int) []int &#123;&#125; 解答思路:這次需要你找出交集的部分，而且彼此都包含的部分可以重覆出現，所以這次在第一個陣列儲進hashmap時，key為元素值不變，而value改為儲存該元素出現的次數，到了第二個陣列要核對的只有該元素是否存在於hashmap之中，每核對完放入結果時該數的次數就要-1，至於兩陣列如果值能重覆都需有相同最大數量就看是hashmap的數量先歸0，還是第二個陣列的核對先結束來決定。 針對Follow Up的部分前1,2點如果是用HashMap來處理就不會有區別，而第三點如果是nums2沒辦法完全放入記憶體之中的話，就是先把第一個陣列放入hashmap之中，正好就是上\b述思路的做法，然後再\b批次到硬碟讀取nums2的資料來處理。 程式碼解說:一樣初始化一空陣列用於回傳結果，hashmap的value改儲存次數所以為int的型別，在第一個陣列用迴圈完全倒入hashmap之後，接著便是第二個陣列利用迴圈開始一一核對，如果該元素在hashmap存在且儲存的數量尚未歸0就放入結果之中同時將次數-1，如果該數的次數先歸0，表示在第一個陣列最多只能交集這些數量，反之尚未歸0而第二個陣列的核對已經結束了，表示第二個陣列最多只能交集這些數量，最後在核對結束之後將結果回傳 12345678910111213result := []int&#123;&#125;hashMap := make(map[int]int)for _, v := range nums1 &#123; hashMap[v] += 1&#125;for _, v := range nums2 &#123; amount, ok := hashMap[v] if ok &amp;&amp; amount &gt; 0 &#123; result = append(result, v) hashMap[v] -= 1 &#125;&#125;return result 完整程式碼:123456789101112131415func intersect(nums1 []int, nums2 []int) []int &#123; result := []int&#123;&#125; hashMap := make(map[int]int) for _, v := range nums1 &#123; hashMap[v] += 1 &#125; for _, v := range nums2 &#123; amount, ok := hashMap[v] if ok &amp;&amp; amount &gt; 0 &#123; result = append(result, v) hashMap[v] -= 1 &#125; &#125; return result&#125; 總結:如果需要找出兩陣列所交集的部分，且需包含重覆且相同的最大數量，此時在第一個陣列儲進hashmap時，key為元素值，而value改為儲存該元素出現的次數，到了第二個陣列要核對的只有該元素是否存在於hashmap之中，每核對完放入結果時該數的次數就要-1，最後重覆且相同的最大數量就看是hashmap的數量先歸0，還是第二個陣列的核對先結束來決定","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"},{"name":"Sort","slug":"Sort","permalink":"https://blog.yunchen.tw/tags/Sort/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"https://blog.yunchen.tw/tags/BinarySearch/"}]},{"title":"First Unique Character in a String","slug":"first-unique-character-in-a-string","date":"2017-02-20T16:00:00.000Z","updated":"2017-04-05T15:14:43.000Z","comments":true,"path":"2017/02/21/first-unique-character-in-a-string/","link":"","permalink":"https://blog.yunchen.tw/2017/02/21/first-unique-character-in-a-string/","excerpt":"","text":"First Unique Character in a StringGiven a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1. For Examples:12345s = &quot;leetcode&quot;return 0.s = &quot;loveleetcode&quot;,return 2. Note: You may assume the string contain only lowercase letters. 提示 解題應用 String HashTable Default:123func firstUniqChar(s string) int &#123;&#125; 解答思路:這題要你找出字串中獨一無二的字母，並且回傳其index值，基本上一樣採用hashmap來實作，key值為該字母，value則為index值，當發現其字母已經存在於hashmap之中表示重覆，將原本index值以-1來覆蓋，最後遍歷結束只要再次檢查找出值不為-1的value值，其key值就是獨一無二的字母。 程式碼解說:一開始先將回傳的預設值設為-1，再來初始化hashmap，其中key為字母的rune值而value則是儲存index值，接著開始以迴圈遍歷整個字串的字母，如果該字母不存在就將其字母與index值放入hashmap之中，如果存在表示不為獨一無二的字母，將原本的index值取代為-1，最後遍歷結束只要再次以迴圈確認每個hashmap的value是否存在不為-1的結果，只不過這邊要注意到的是因為字串可能存在一個以上獨一無二的字母，所以要回傳index值為最小的字母，偏偏hashmap儲存時是無序的狀況，還必須要多個判斷找出最小的index值，另外因為初始化回傳值為-1會永遠最小，所以再發現value不為-1時，記得要先將回傳值給蓋掉才開始找最小index值 12345678910111213141516result := -1hashMap := make(map[rune]int)for i, v := range s &#123; _, ok := hashMap[v] if !ok &#123; hashMap[v] = i &#125; else &#123; hashMap[v] = -1 &#125;&#125;for _, value := range hashMap &#123; if value != -1 &amp;&amp; (result == -1 || value &lt; result) &#123; result = value &#125;&#125;return result 完整程式碼:123456789101112131415161718func firstUniqChar(s string) int &#123; result := -1 hashMap := make(map[rune]int) for i, v := range s &#123; _, ok := hashMap[v] if !ok &#123; hashMap[v] = i &#125; else &#123; hashMap[v] = -1 &#125; &#125; for _, value := range hashMap &#123; if value != -1 &amp;&amp; (result == -1 || value &lt; result) &#123; result = value &#125; &#125; return result&#125; 總結:要出字串中獨一無二的字母並回傳index值，基本上一樣採用hashmap來實作，key值為該字母，value則為index值，當發現其字母已經存在於hashmap之中表示重覆，將原本index值以-1來覆蓋，最後遍歷結束只要再次檢查找出值不為-1的value值，其key值就是獨一無二的字母。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"}]},{"title":"Reverse String","slug":"reverse-string","date":"2017-02-19T16:00:00.000Z","updated":"2017-04-05T15:14:36.000Z","comments":true,"path":"2017/02/20/reverse-string/","link":"","permalink":"https://blog.yunchen.tw/2017/02/20/reverse-string/","excerpt":"","text":"Reverse StringWrite a function that takes a string as input and returns the string reversed. For Example:1Given s = &quot;hello&quot;, return &quot;olleh&quot;. 提示 解題應用 TwoPointers String Default:123func reverseString(s string) string &#123;&#125; 解答思路:這題要反轉一個字串，其實就是遍歷每個字母時，將每個字母放到新字串的開頭，如此一來在遍歷結束時，反轉字串也就完成了。 程式碼解說:首先先宣告一個空字串，接著利用迴圈將字母一一取出，並將rune值(ascii)轉成string再放到字串的開頭，如此一來在遍歷結束時，反轉字串也就完成了。 12345var result stringfor _, value := range s &#123; result = string(value) + result&#125;return result 完整程式碼:1234567func reverseString(s string) string &#123; var result string for _, value := range s &#123; result = string(value) + result &#125; return result&#125; 總結:要反轉一字串其實就是遍歷每個字母時，將每個字母放到新字串的開頭，如此一來在遍歷結束時，反轉字串也就完成了。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"}]},{"title":"Power of Four","slug":"power-of-four","date":"2017-02-18T16:00:00.000Z","updated":"2017-04-05T15:14:19.000Z","comments":true,"path":"2017/02/19/power-of-four/","link":"","permalink":"https://blog.yunchen.tw/2017/02/19/power-of-four/","excerpt":"","text":"Power of FourGiven an integer (signed 32 bits), write a function to check whether it is a power of 4. For Example:1Given num = 16, return true. Given num = 5, return false. Follow up: Could you solve it without loops/recursion? 提示 解題應用 BitManipulation 二進位長度 Default:123func isPowerOfFour(num int) bool &#123;&#125; 解答思路:先前曾經寫過類似的題目Power of Two，當然還有Power of Three，這次則是Power of Four，當然在想的時候會發現你在確認4的n次方同時，其值很可能也是2的n次方，畢竟4的n次方同時也是2的2n次方，所以倒不如直接用2的n次方尋找方式去篩選，而如果將值轉成二進位更可以發現到4的n次方二進位長度都為奇數，2的n次方則為偶數如下: 2 10 長度:24 100 長度:38 1000 長度:416 10000 長度:5 因此找出其為2次方的同時，再利用長度篩出是否為4次方即可達到目地。 程式碼解說:如之前找2的n次方程式碼差不多，該值與該值-1做AND，而這次為了要確認是否為4的n次方，多了一個二進位的長度判斷，這邊用上了strconv的library，將其值轉為二進位字串，接著再開始判斷長度是否為奇數，若長度為奇數又是二的n次方，其值必為4的n次方回傳，其餘2的n次方不為4的n次方或連2的n次方都不是的狀況則回傳false 12345binary := strconv.FormatInt(int64(num), 2)if num &gt; 0 &amp;&amp; len(binary)%2 != 0 &amp;&amp; num&amp;(num-1) == 0 &#123; return true&#125;return false 完整程式碼:1234567func isPowerOfFour(num int) bool &#123; binary := strconv.FormatInt(int64(num), 2) if num &gt; 0 &amp;&amp; len(binary)%2 != 0 &amp;&amp; num&amp;(num-1) == 0 &#123; return true &#125; return false&#125; 總結:要確認某值是否為4的n次方，換句話說其值也是2的2n次方，所以倒不如直接用2的n次方尋找方式去篩選，而將值轉成二進位更可以發現到4的n次方二進位長度都為奇數，2的n次方則為偶數，因此再確認其為2的n次方值的同時，再利用長度篩出是否為4的n次方即可達到目地。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"BitManipulation","slug":"BitManipulation","permalink":"https://blog.yunchen.tw/tags/BitManipulation/"}]},{"title":"Power of Three","slug":"power-of-three","date":"2017-02-17T16:00:00.000Z","updated":"2017-04-05T15:14:11.000Z","comments":true,"path":"2017/02/18/power-of-three/","link":"","permalink":"https://blog.yunchen.tw/2017/02/18/power-of-three/","excerpt":"","text":"Power of ThreeGiven an integer, write a function to determine if it is a power of three. Follow up: Could you do it without using any loop / recursion? 提示 解題應用 Math 腦力激盪 Default:123func isPowerOfThree(n int) bool &#123;&#125; 解答思路:先前曾經寫過類似的題目Power of Two，不過這邊看半天對於3的n次方數位元實在沒有什麼特別之處，follow up又希望你一樣能不用任何的迴圈及遞回，想了辦天也沒什麼辦法，只好去看其它人的討論，與其說是解題，倒不如說是腦力激盪，如果兩個同樣都是3的n次方數，比較大的那個去向比較小的取餘數必為0，就是運用這樣的概念，找一個3的n次方在32位元內極大值，可以發現是3的19次方1162261467，題目會帶入的值鐵定小於等於其極大值，透過這樣的小訣竅最後就可以很快速的找出解。 程式碼解說:非常單純的短短幾行，首先判斷n是否大於等於0，接著用算好的3次方在32位元內的極大值(1162261467)對n取餘數，若為0表示同為3的n次方回傳true，其它的狀況則回傳false 1234if n &gt; 0 &amp;&amp; 1162261467%n == 0 &#123; return true&#125;return false 完整程式碼:123456func isPowerOfThree(n int) bool &#123; if n &gt; 0 &amp;&amp; 1162261467%n == 0 &#123; return true &#125; return false&#125; 總結:相較於2的n次方是用位元的方法來判斷，3的n次方甚至是其它數的次方則可以用整除的方法來判斷，不過前提是要先知道取得帶入值型別是幾位元，且算出對應位元該相同數次方的極大值，最後用極大值對其帶入的數取餘數，若為0表示同為該數的n次方，此方法相對麻煩在於需事先算出極大值。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"Range Sum Query - Immutable","slug":"range-sum-query-immutable","date":"2017-02-16T16:00:00.000Z","updated":"2017-04-05T15:14:05.000Z","comments":true,"path":"2017/02/17/range-sum-query-immutable/","link":"","permalink":"https://blog.yunchen.tw/2017/02/17/range-sum-query-immutable/","excerpt":"","text":"Range Sum Query - ImmutableGiven an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. For Example:12345Given nums = [-2, 0, 3, -5, 2, -1]sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 Note: You may assume that the array does not change. There are many calls to sumRange function. 提示 解題應用 DynamicProgramming 物件概念 Default:1234567891011121314151617181920type NumArray struct &#123; &#125;func Constructor(nums []int) NumArray &#123; &#125;func (this *NumArray) SumRange(i int, j int) int &#123; &#125;/** * Your NumArray object will be instantiated and called as such: * obj := Constructor(nums); * param_1 := obj.SumRange(i,j); */ 解答思路:這題沒有什麼技巧，單純測試最基本的物件概念實作，而物件的function是要算出該陣列中index範圍間的總合，基本上就是初始化時將值存入物件，最後在function去呼叫儲存在物件的陣列，用迴圈遍歷範圍值總合回傳就結束了。 程式碼解說:首先先定義好要存在物件裡值的型別，接著當建構function被呼叫時將值帶入一個初始化的物件並回傳，最後在SumRange被呼叫時利用this來存取初始化帶入的陣列，並用迴圈遍歷範圍的index值做總合回傳 1234567891011121314type NumArray struct &#123; Nums []int&#125;func Constructor(nums []int) NumArray &#123; return NumArray&#123;nums&#125;&#125;func (this *NumArray) SumRange(i int, j int) int &#123; var sum int for i &lt;= j &#123; sum += this.Nums[i] i++ &#125; return sum&#125; 完整程式碼:1234567891011121314type NumArray struct &#123; Nums []int&#125;func Constructor(nums []int) NumArray &#123; return NumArray&#123;nums&#125;&#125;func (this *NumArray) SumRange(i int, j int) int &#123; var sum int for i &lt;= j &#123; sum += this.Nums[i] i++ &#125; return sum&#125; 總結:物件概念的基本實作。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"https://blog.yunchen.tw/tags/DynamicProgramming/"}]},{"title":"Nim Game","slug":"nim-game","date":"2017-02-15T16:00:00.000Z","updated":"2017-04-05T15:13:58.000Z","comments":true,"path":"2017/02/16/nim-game/","link":"","permalink":"https://blog.yunchen.tw/2017/02/16/nim-game/","excerpt":"","text":"Nim GameYou are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones. Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap. For example: 1If there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend. 提示 解題應用 Brainteaser 規律觀查 Default:123func canWinNim(n int) bool &#123;&#125; 解答思路:一開始本來想用遞回的方式將石頭分別-1,-2,-3順勢找出全部會贏的狀況，但這種情況包含了對方是亂玩的情況，所以結果就是都會贏根本猜不出結果，這種遊戲如果換個角度來想，當雙方能力皆為相等的狀況下，而且是相當優秀的兩人，那麼整個過程就會只有一種，而且誰先誰後就是最大的關鍵，如此一來我們倒不如從最少的石頭來開始推論，說不定可以發現規律存在: 因為是我們先的關係，所以只要小於等於3時必定會贏 win: 1, 2, 3 而到4的時候，不管拿1還是2還是3，最後剩下的數量肯定小於等於3給對方拿，所以必定會輸 lose: 4 5的時候一開始只拿一個最後不管對方怎麼拿肯定輸，而6則是兩個，7則是三個 win: 5, 6, 7 到8的時候不管我拿1~3個，最後對方的數量會變成5~7個，而之前一開始我們拿5~7時必贏，這次換對方的數量變為5~7，所以接下來肯定必輸 lose: 8 從上面的推論我們可以發現在我們先拿的情況下，只要是4的倍數時必定會輸，其餘的情況則是必贏，而這個就是我們最後的結論。 程式碼解說:從上述的結論可以知道4的倍數時必定會輸，所以取4的餘數如果為0就回傳false，其它的狀況則必定會贏就回傳true 1234if n%4 == 0 &#123; return false&#125;return true 完整程式碼:123456func canWinNim(n int) bool &#123; if n%4 == 0 &#123; return false &#125; return true&#125; 總結:如果是同等智力且聰明的人在玩遊戲(不含運氣成分)，其遊戲過程必為1種，如此一來便能夠透過統計來整理出結論，進而準確預測之後隨著條件不同而造成的結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Brainteaser","slug":"Brainteaser","permalink":"https://blog.yunchen.tw/tags/Brainteaser/"}]},{"title":"Word Pattern","slug":"word-pattern","date":"2017-02-14T16:00:00.000Z","updated":"2017-04-05T15:13:52.000Z","comments":true,"path":"2017/02/15/word-pattern/","link":"","permalink":"https://blog.yunchen.tw/2017/02/15/word-pattern/","excerpt":"","text":"Word PatternGiven a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. For Examples:1234pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot; should return true.pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot; should return false.pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot; should return false.pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot; should return false. Notes: You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space. 提示 解題應用 HashTable HashMap Default:123func wordPattern(pattern string, str string) bool &#123;&#125; 解答思路:這題沒有什麼大問題，基本上就是1個字母對上1個單字，而且關係為1對1的絕對關係，所以如果以hashmap來儲存的話可以以同一個來同時放key(字母)、value(單字)與key(單字)、value(字母)，或者是拆成兩個hashmap意思也一樣，總之一定要同時存放相反的key與value才能以空間來換取時間加快。 程式碼解說:一開始先將所給予的單字組以單一空白一一切開，接著先判斷字母組的長度是否與要對照的單字組一樣長，不一通樣的話就直接回傳false來篩選例外的狀況 1234strSplit := strings.Split(str, \" \")if len(pattern) != len(strSplit) &#123; return false&#125; 接著便能開始對照每個字組，如前述所提這邊我以兩個hashmap來儲存字母與單字分別為key與value的兩種狀況，接著就開始遍歷每個字組，不管是哪個hashmap，只要其中一個字組存在就檢查其key對應的value是否與儲存的相同，如果不同就回傳false，如果字組根本不在hashmap裡頭，就在後頭分別儲存至兩種hashmap(如果字組存在且值一樣會直接再覆蓋一次)，最後驗證完全部的字組後才回傳true 1234567891011121314151617var word stringorigin := make(map[rune]string)reverse := make(map[string]rune)for i, v := range pattern &#123; word = strSplit[i] oValue, oOk := origin[v] rValue, rOk := reverse[word] if oOk &amp;&amp; word != oValue &#123; return false &#125; if rOk &amp;&amp; v != rValue &#123; return false &#125; origin[v] = word reverse[word] = v&#125;return true 完整程式碼:1234567891011121314151617181920212223func wordPattern(pattern string, str string) bool &#123; strSplit := strings.Split(str, \" \") if len(pattern) != len(strSplit) &#123; return false &#125; var word string origin := make(map[rune]string) reverse := make(map[string]rune) for i, v := range pattern &#123; word = strSplit[i] oValue, oOk := origin[v] rValue, rOk := reverse[word] if oOk &amp;&amp; word != oValue &#123; return false &#125; if rOk &amp;&amp; v != rValue &#123; return false &#125; origin[v] = word reverse[word] = v &#125; return true&#125; 總結:如果有特定字母對照特定的單字，且為1對1的絕對關係的話，除用將字母對單字以key&amp;value來存放之外，也別忘記儲存相反的狀況:單字對字母，至於要存放在同一個hashmap或拆成兩個則隨意。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"Move Zeroes","slug":"move-zeroes","date":"2017-02-13T16:00:00.000Z","updated":"2017-04-05T15:13:46.000Z","comments":true,"path":"2017/02/14/move-zeroes/","link":"","permalink":"https://blog.yunchen.tw/2017/02/14/move-zeroes/","excerpt":"","text":"Move ZeroesGiven an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example:1Given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. 提示 解題應用 TwoPointers Index Value Default:123func moveZeroes(nums []int) &#123;&#125; 解答思路:最初想使用bubble sort或直接將0的元素從最後頭位置互換，可惜此題除了0之外的其它元素還要保留相對位置，所以就改用其它方式來處理，當發現元素為0時先暫存其index值，直到發現下一個非0的元素才互換位置，最後才從原本發現0位置的下一項繼續重覆上述動作。 程式碼解說:首先以一flag值來表示目前遍歷陣列所到達的位置，直到其index值超出陣列為止，此時一邊一一確認是否該元素的值為0且先前取出的元素都不為0，如果是的話就記錄0的位置並確認0存在，接著便繼續往下並再次確認是否先前有0存在且這次值不為0，如果也符合條件的話，就可以將先前記錄index位置的0與此index位置的其值互換，最後記得將zero改回false，並把flag值指回原本發現值為0的index位置，繼續再重新尋找下一個值為0的元素 123456789101112131415var zero boolvar zeroIndex intvar flag intfor flag != len(nums) &#123; if !zero &amp;&amp; nums[flag] == 0 &#123; zero = true zeroIndex = flag &#125; else if zero &amp;&amp; nums[flag] != 0 &#123; zero = false nums[zeroIndex] = nums[flag] nums[flag] = 0 flag = zeroIndex &#125; flag++&#125; 完整程式碼:1234567891011121314151617func moveZeroes(nums []int) &#123; var zero bool var zeroIndex int var flag int for flag != len(nums) &#123; if !zero &amp;&amp; nums[flag] == 0 &#123; zero = true zeroIndex = flag &#125; else if zero &amp;&amp; nums[flag] != 0 &#123; zero = false nums[zeroIndex] = nums[flag] nums[flag] = 0 flag = zeroIndex &#125; flag++ &#125;&#125; 總結:在一陣列中如需要將特定元素移至最後頭，若不需在意原本陣列值的相對位置，可使用bubble sort或直接將特定元素與最後頭儲存的值互換。若要考量相對位置的關係則可以先暫存其特定元素的index值，直到發現下一個非該元素才互換位置，並從原本該index值的下一項繼續檢查並重覆上述動作。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"}]},{"title":"Missing Number","slug":"missing-number","date":"2017-02-12T16:00:00.000Z","updated":"2017-04-05T15:13:40.000Z","comments":true,"path":"2017/02/13/missing-number/","link":"","permalink":"https://blog.yunchen.tw/2017/02/13/missing-number/","excerpt":"","text":"Missing NumberGiven an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array. For example:1Given nums = [0, 1, 3] return 2. Note: Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? 提示 解題應用 Math 規律觀查 BitManipulation XOR Default:123func missingNumber(nums []int) int &#123;&#125; 解答思路:只要能善用與先前類似的概念Single Number，成對的情況下可以很容易的找出少了哪一個值，便可以在線性的複雜度上達到目地，而剛好我們可以知道0~n的所有值，所以可以很容易的產生出完整的另一對，最後只要同時XOR原本陣列的值與另一對完整的值，剩下的值就會是我們的結果，不過要注意有兩個例外，一個是0的值會找不出來所有需要在一邊將值取出陣列時，一邊確定是否為0，另一個則是中間根本沒少值，最後要回傳的是第n的值。 程式碼解說:由於需要同時XOR陣列的值與0~n的值，剛好我們可以利用取出陣列元素值的同時，連同index值一起做XOR，不過因為陣列中有缺少一個元素，所以再取完值的同時還要再XOR陣列的長度(剛好為n值)，而因為0的值會找不出來，所以在迴圈取值時還需判斷是否有0存在，沒有則直接回傳0，如果0存在而且miss的結果剛好也是0，這時表示0~n-1中間完全沒有少值，便回傳n也就是陣列的長度 12345678910111213141516var miss intvar exist0 boolsize := len(nums)for i, v := range nums &#123; if v == 0 &#123; exist0 = true &#125; miss ^= v ^ i&#125;miss ^= sizeif !exist0 &#123; return 0&#125; else if miss == 0 &#123; return size&#125;return miss 完整程式碼:123456789101112131415161718func missingNumber(nums []int) int &#123; var miss int var exist0 bool size := len(nums) for i, v := range nums &#123; if v == 0 &#123; exist0 = true &#125; miss ^= v ^ i &#125; miss ^= size if !exist0 &#123; return 0 &#125; else if miss == 0 &#123; return size &#125; return miss&#125; 總結:要找出0~n中缺了哪個值，善用XOR成對為0的概念，同時XOR所有陣列中的值與完整的0~n，剩下的值就會是我們的結果，萬一缺的是0或是n則需要另外再做確認。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"},{"name":"BitManipulation","slug":"BitManipulation","permalink":"https://blog.yunchen.tw/tags/BitManipulation/"}]},{"title":"Ugly Number","slug":"ugly-number","date":"2017-02-11T16:00:00.000Z","updated":"2017-04-05T15:13:32.000Z","comments":true,"path":"2017/02/12/ugly-number/","link":"","permalink":"https://blog.yunchen.tw/2017/02/12/ugly-number/","excerpt":"","text":"Ugly NumberWrite a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number. 提示 解題應用 Math 規律觀查 Default:123func isUgly(num int) bool &#123;&#125; 解答思路:要判斷一數字是否僅由2、3、5所組成，最快的方式就是不斷的將該數利用回圈去除2、3、5，且各別除以時其餘數必須為0(因為是由2、3、5組成)，最後剩下的數如果為1表示其完全由2、3、5所組成為Ugly Number，如果不為1那麼就勢必存在著其它的質數回傳false。 程式碼解說:首先要將0這個例外給剔除掉回傳false，接著用flag來確定該數能否被2、3、5整除，如果有其一能被整除，就將該數除以其一接著再重新在判斷一次，直到完全不能被2、3、5整除(含其它質數)或該數為1(被完全整除)為止 12345678910111213141516171819if num == 0 &#123; return false&#125;flag := truefor flag &#123; flag = false if num%2 == 0 &#123; flag = true num = num / 2 &#125; if num%3 == 0 &#123; flag = true num = num / 3 &#125; if num%5 == 0 &#123; flag = true num = num / 5 &#125;&#125; 該數被完全拿掉2、3、5的組成要素後，最後再判斷剩下的值是否為1(被完全整除)，如果是就回傳true，否則回傳false 1234if num != 1 &#123; return false&#125;return true 完整程式碼:12345678910111213141516171819202122232425func isUgly(num int) bool &#123; if num == 0 &#123; return false &#125; flag := true for flag &#123; flag = false if num%2 == 0 &#123; flag = true num = num / 2 &#125; if num%3 == 0 &#123; flag = true num = num / 3 &#125; if num%5 == 0 &#123; flag = true num = num / 5 &#125; &#125; if num != 1 &#123; return false &#125; return true&#125; 總結:判斷一數字是否由某些特定的質數所組成，最快的方式就是不斷的將該數個別除以特定的質數，且若為組成的要素其餘數必為0，最後剩下的數如果為1表示其完全由該質數組成為Ugly Numer。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"Add Digits","slug":"add-digits","date":"2017-02-10T16:00:00.000Z","updated":"2017-04-05T15:13:22.000Z","comments":true,"path":"2017/02/11/add-digits/","link":"","permalink":"https://blog.yunchen.tw/2017/02/11/add-digits/","excerpt":"","text":"Add DigitsGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit. For example:1Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow up: Could you do it without any loop/recursion in O(1) runtime? 提示 解題應用 Math 公式 Default:123func addDigits(num int) int &#123;&#125; 解答思路:一般看到題目我想就直接用迴圈不斷去取餘數，將這些結果做總合再去判斷是否剩一個數字(除10商不為0)，如此一來便能快整寫出如下: 1234567891011121314func addDigits(num int) int &#123; var remainder int sum := num for sum/10 != 0 &#123; num = sum sum = 0 for num != 0 &#123; remainder = num % 10 sum = sum + remainder num = num / 10 &#125; &#125; return sum&#125; 不過注意到follow up，希望你可以不用任何的迴圈及遞回完成，除非先前就已經知道，否則要慢慢推出結論有一定的難度在，這邊就遵循 Digital Root 所給的公式直接套入即可解決。 程式碼解說:基本上就是套入上述所給予的公式: dr(n) = 1 + ((n-1) mod 9) 完整程式碼:123func addDigits(num int) int &#123; return 1 + (num-1)%9&#125; 總結:要找出一數字的Digital Root除了能用迴圈及遞回完成之外，如果有下述公式來結論的話便能在O(1)的複雜度完成。 dr(n) = 1 + ((n-1) mod 9)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"Binary Tree Paths","slug":"binary-tree-paths","date":"2017-02-09T16:00:00.000Z","updated":"2017-04-05T15:13:08.000Z","comments":true,"path":"2017/02/10/binary-tree-paths/","link":"","permalink":"https://blog.yunchen.tw/2017/02/10/binary-tree-paths/","excerpt":"","text":"Binary Tree PathsGiven a binary tree, return all root-to-leaf paths. For example, given the following binary tree: 12345 1 / \\2 3 \\ 5 All root-to-leaf paths are: 1[&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;] 提示 解題應用 Tree Pointer DepthFirstSearch PreOrderTravel Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func binaryTreePaths(root *TreeNode) []string &#123;&#125; 解答思路:列出一二元樹的特定路徑時，正如尋找最大深度所會碰上的問題一樣，在做前序遍歷時需要對那些左右子節點是否存在做處理，尤其是左或右子節點僅其中一點存在的情況下，容易將另一不存在的子節點當作終點作為其路徑，以上述例子來說存在著”1-&gt;2-&gt;5”，然而2的左子節點不存在，但”1-&gt;2”並非是能到達的最大路徑(深度)，這邊僅需要藉由其子節點存在的判斷來決定是否遍歷，便能輕易回避此問題取得所需的結果。 程式碼解說:一開始先確定根節點是否為nil，如果是就回傳空的字串陣列，否則才開始前序遍歷遞回每一個節點 123456func binaryTreePaths(root *TreeNode) []string &#123; if root == nil &#123; return []string&#123;&#125; &#125; return preOrderTravel(root, \"\")&#125; 如果節點的左右子節點都不存在，就表示已經來到了路徑的末端，這時只要將該節點的值附上，在帶入字串陣列中回傳即可，而如果是有子節點存在的情況就記得在字串的後頭加上”-&gt;”，正如先前所說我們藉由其子節點存在的判斷來決定是否遍歷，如果左子節點不存在就遍歷右子節點，如果右子節點不存在則遍歷左子節點，最後如果兩個子節點皆存在，等到兩子節點遞回結果後，才將兩字串陣列做合併向上回傳 12345678910111213141516func preOrderTravel(node *TreeNode, path string) []string &#123; if node.Left == nil &amp;&amp; node.Right == nil &#123; path = path + strconv.Itoa(node.Val) return []string&#123;path&#125; &#125; path = path + strconv.Itoa(node.Val) + \"-&gt;\" if node.Left == nil &#123; return preOrderTravel(node.Right, path) &#125; if node.Right == nil &#123; return preOrderTravel(node.Left, path) &#125; leftPath := preOrderTravel(node.Left, path) rightPath := preOrderTravel(node.Right, path) return append(leftPath, rightPath...)&#125; 完整程式碼:12345678910111213141516171819202122func binaryTreePaths(root *TreeNode) []string &#123; if root == nil &#123; return []string&#123;&#125; &#125; return preOrderTravel(root, \"\")&#125;func preOrderTravel(node *TreeNode, path string) []string &#123; if node.Left == nil &amp;&amp; node.Right == nil &#123; path = path + strconv.Itoa(node.Val) return []string&#123;path&#125; &#125; path = path + strconv.Itoa(node.Val) + \"-&gt;\" if node.Left == nil &#123; return preOrderTravel(node.Right, path) &#125; if node.Right == nil &#123; return preOrderTravel(node.Left, path) &#125; leftPath := preOrderTravel(node.Left, path) rightPath := preOrderTravel(node.Right, path) return append(leftPath, rightPath...)&#125; 總結:列出一二元樹的特定路徑時，前序遍歷時需要對那些左右子節點是否存在做處理，尤其是左或右子節點僅其中一點存在的情況下，容易將另一不存在的子節點當作終點作為其路徑，因此藉由其子節點存在的判斷來決定是否遍歷，便能輕易回避此問題取得所需的結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"},{"name":"DepthFirstSearch","slug":"DepthFirstSearch","permalink":"https://blog.yunchen.tw/tags/DepthFirstSearch/"}]},{"title":"Palindrome Linked List","slug":"palindrome-linked-list","date":"2017-02-05T16:00:00.000Z","updated":"2017-04-05T15:13:01.000Z","comments":true,"path":"2017/02/06/palindrome-linked-list/","link":"","permalink":"https://blog.yunchen.tw/2017/02/06/palindrome-linked-list/","excerpt":"","text":"Palindrome Linked ListGiven two strings s and t, write a function to determine if t is an anagram of s. For example:12s = &quot;anagram&quot;, t = &quot;nagaram&quot;, return true.s = &quot;rat&quot;, t = &quot;car&quot;, return false. Note: You may assume the string contains only lowercase alphabets. Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case? 提示 解題應用 HashTable HashMap Default:123func isAnagram(s string, t string) bool &#123;&#125; 解答思路:要比較兩個字串是否由相同字母且每個字母都數量都相同所組成，最簡單的方式就是統計此兩個字串的每個字母分別用了哪些又用了多少個，最後比較數量是否一致，要統計這些無序的字母用HashMap就可以達到我們要的目地了。 程式碼解說:一開始先判斷長度是否一致，不一致肯定不是由相同數量的字母組成，接著就是初始化兩字串所要儲存的hashmap，key值為每個字元的rune值，而value則是統計數量，待第一個迴圈將兩字串的字母全部取出做儲存統計後，最後在用第二個迴圈比較每組key所對應的值是否相同，如果不同就回傳false，直到全數檢查完畢才回傳true 1234567891011121314151617if len(s) != len(t) &#123; return false&#125;var char runesHashMap := make(map[rune]int)tHashMap := make(map[rune]int)for i, v := range s &#123; char = rune(t[i]) sHashMap[v] += 1 tHashMap[char] += 1&#125;for key, value := range sHashMap &#123; if value != tHashMap[key] &#123; return false &#125;&#125;return true 完整程式碼:12345678910111213141516171819func isAnagram(s string, t string) bool &#123; if len(s) != len(t) &#123; return false &#125; var char rune sHashMap := make(map[rune]int) tHashMap := make(map[rune]int) for i, v := range s &#123; char = rune(t[i]) sHashMap[v] += 1 tHashMap[char] += 1 &#125; for key, value := range sHashMap &#123; if value != tHashMap[key] &#123; return false &#125; &#125; return true&#125; 總結:要比較兩個字串是否由相同字母且每個字母都數量都相同所組成，最快的方式就是將每個字母分別利用hashmap做儲存統計，最後比較兩字串的hashmap每組key與value是否完全一致即可。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"},{"name":"Sort","slug":"Sort","permalink":"https://blog.yunchen.tw/tags/Sort/"}]},{"title":"Palindrome Linked List","slug":"palindrome-linked-list","date":"2017-02-04T16:00:00.000Z","updated":"2017-04-05T15:12:34.000Z","comments":true,"path":"2017/02/05/palindrome-linked-list/","link":"","permalink":"https://blog.yunchen.tw/2017/02/05/palindrome-linked-list/","excerpt":"","text":"Palindrome Linked ListGiven a singly linked list, determine if it is a palindrome. Follow up: Could you do it in O(n) time and O(1) space? 提示 解題應用 LinkedList Pointer Default:12345678910/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func isPalindrome(head *ListNode) bool &#123;&#125; 解答思路:在寫之前會發現到Follow up希望你能達到的條件，不過我認為要嚴格達到是非常具有爭議性的，因為要做回文的判斷，偏偏此題LinkedList的節點又是不可逆，此外用字串來強制儲存正反兩面做比較(可以參考:Valid Palindrome)，畢竟存的值不是字串會有正負數上處理的麻煩及負號會導致不對稱，所以最後的結論就是先找到中間節間為開始倒著回去的部分，接著就是將原本中間到最後的部分反轉，便同時與前面的部分開始遍歷比較是否相同，而爭議點在於反轉所花費的空間與時間，總之就先以此方式來當作目前最佳的解決方案。 程式碼解說:一開始先判斷LinkedList是否為nil，接著就是要來找出中間節點的位置，同時兩個指標以1:2的速度來遍歷整個LinkedList，當速度比較快的指標到底時，此時比較慢的指標會位在前半部最後一個節點的位置上，正如先前所說，這時就可以將後半部的部分給反轉，而在那之前要先將比較慢的指標位置往後移一格，變成後半LinkedList的開頭，最後與前半部開始同時遍歷一一檢查值是否相同，直到後半部的節點到達底部都沒有問題才回傳true 1234567891011121314151617181920func isPalindrome(head *ListNode) bool &#123; if head == nil &#123; return true &#125; fast := head.Next slow := head for fast != nil &amp;&amp; fast.Next != nil &#123; fast = fast.Next.Next slow = slow.Next &#125; slow = reverse(slow.Next) for slow != nil &#123; if head.Val != slow.Val &#123; return false &#125; head = head.Next slow = slow.Next &#125; return true&#125; 先前就有題目需要反轉LinkedList，此時就可以派上用場，詳細的解說可以參考:Reverse Linked List 1234567891011func reverse(head *ListNode) *ListNode &#123; var preNode *ListNode var tmp *ListNode for head != nil &#123; tmp = head head = head.Next tmp.Next = preNode preNode = tmp &#125; return tmp&#125; 完整程式碼:12345678910111213141516171819202122232425262728293031func isPalindrome(head *ListNode) bool &#123; if head == nil &#123; return true &#125; fast := head.Next slow := head for fast != nil &amp;&amp; fast.Next != nil &#123; fast = fast.Next.Next slow = slow.Next &#125; slow = reverse(slow.Next) for slow != nil &#123; if head.Val != slow.Val &#123; return false &#125; head = head.Next slow = slow.Next &#125; return true&#125;func reverse(head *ListNode) *ListNode &#123; var preNode *ListNode var tmp *ListNode for head != nil &#123; tmp = head head = head.Next tmp.Next = preNode preNode = tmp &#125; return tmp&#125; 總結:若要檢查一單向LinkedList是否為回文，且其節點所儲存的值非為字串，此時可以先找出中間節點的位置，接著將後半的LinkedList做反轉，最後再同時與前面的部分開始遍歷比較是否相同。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://blog.yunchen.tw/tags/LinkedList/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"}]},{"title":"Implement Queue using Stacks","slug":"implement-queue-using-stacks","date":"2017-02-03T16:00:00.000Z","updated":"2017-04-05T15:12:22.000Z","comments":true,"path":"2017/02/04/implement-queue-using-stacks/","link":"","permalink":"https://blog.yunchen.tw/2017/02/04/implement-queue-using-stacks/","excerpt":"","text":"Implement Queue using StacksImplement the following operations of a queue using stacks. push(x) – Push element x to the back of queue. pop() – Removes the element from in front of queue. peek() – Get the front element. empty() – Return whether the queue is empty. Notes: You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack. You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). 提示 解題應用 Stack Quene Default:12345678910111213141516171819202122232425262728293031323334353637383940414243type MyQueue struct &#123; &#125;/** Initialize your data structure here. */func Constructor() MyQueue &#123; &#125;/** Push element x to the back of queue. */func (this *MyQueue) Push(x int) &#123; &#125;/** Removes the element from in front of queue and returns that element. */func (this *MyQueue) Pop() int &#123; &#125;/** Get the front element. */func (this *MyQueue) Peek() int &#123; &#125;/** Returns whether the queue is empty. */func (this *MyQueue) Empty() bool &#123; &#125;/** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */ 解答思路:這次要用stack來實作quene就更怪了，這邊我以兩個stack來實作，其中一個stack是負責push也就是插入元素，另一個stack則是負責pop把元素取出，為什麼要這樣處理呢?想想看stack在插入新的元素時，新的總是在最上面，這就和quene新的總是在最後面是一樣的道理，至於pop對quene來說是要拿出最前面最舊的元素，我們如果把stack一個個元素取出，然後再倒入另一個stack時就會變成最舊的元素在最上面了，此時就可以順利的對pop做處理，所以利用這種方式不管是要用LinkedList或Array來實作大致概念都相同。 程式碼解說:這邊我以LinkedList的方式來實作stack，所以需要節點的結構，而實作出來的Quene最主要存了三項位置，分別是push元素用的stack，pop元素用的stack及一個flag用來指向最舊節點的位置，而由於stack在操作上並不需要頭節點來確保操作一致性，所以在建構function時就直接回傳即可 123456789101112type Node struct &#123; Val int Next *Node&#125;type MyQueue struct &#123; StackPush *Node StackPop *Node Flag *Node&#125;func Constructor() MyQueue &#123; return MyQueue&#123;&#125;&#125; 如解答思路所寫，在進行push或pop任一動作時，要先確定另一個stack是否已將元素倒入，而這邊我們就要看pop對應的stack是否為空，如果沒有則先暫存目前stack開頭的位置，將另一個stack元素搬來原本的頂端並接回原本存在舊的元素，然後才重覆上述動作直到確定另一stack的元素已完全倒入，最後就可以放心的新增一個節點帶入其值，一樣將舊的元素接上最後再將其指為頂端節點，要注意的是因為flag要存的是最舊節點位置，也就是quene的第一個節點，所以只有其為nil時才需要指派第一個節點的位置給它 12345678910111213141516func (this *MyQueue) Push(x int) &#123; var tmp *Node for this.StackPop != nil &#123; tmp = this.StackPush this.StackPush = this.StackPop this.StackPop = this.StackPop.Next this.StackPush.Next = tmp &#125; newNode := &amp;Node&#123;&#125; newNode.Val = x if this.Flag == nil &#123; this.Flag = newNode &#125; newNode.Next = this.StackPush this.StackPush = newNode&#125; 如前述確認另一stack是否完全倒入，此時stack頂端為最舊的節點也就是quene的第一個節頭，將其值暫存後就直指將頂端節點的位置往下指，因為pop出去後就不需要在理會，這邊也可以自行多加一行去釋放該節點的記憶體，記得在pop出去後flag也要跟著往下指向目前最舊節點的位置，最後回傳先前所儲存的值 12345678910111213func (this *MyQueue) Pop() int &#123; var tmp *Node for this.StackPush != nil &#123; tmp = this.StackPop this.StackPop = this.StackPush this.StackPush = this.StackPush.Next this.StackPop.Next = tmp &#125; popValue := this.StackPop.Val this.StackPop = this.StackPop.Next this.Flag = this.StackPop return popValue&#125; 因為flag在處理時始終指向最舊節點的位置，所以只要直接回傳其節點位置的值就好 123func (this *MyQueue) Peek() int &#123; return this.Flag.Val&#125; 如果要確認是否為空，最簡單的方式就是確認兩stack的頭節點存不存在，如果都不存在就表示quene沒有任何的元素回傳true 123456func (this *MyQueue) Empty() bool &#123; if this.StackPush == nil &amp;&amp; this.StackPop == nil &#123; return true &#125; return false&#125; 完整程式碼:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950type Node struct &#123; Val int Next *Node&#125;type MyQueue struct &#123; StackPush *Node StackPop *Node Flag *Node&#125;func Constructor() MyQueue &#123; return MyQueue&#123;&#125;&#125;func (this *MyQueue) Push(x int) &#123; var tmp *Node for this.StackPop != nil &#123; tmp = this.StackPush this.StackPush = this.StackPop this.StackPop = this.StackPop.Next this.StackPush.Next = tmp &#125; newNode := &amp;Node&#123;&#125; newNode.Val = x if this.Flag == nil &#123; this.Flag = newNode &#125; newNode.Next = this.StackPush this.StackPush = newNode&#125;func (this *MyQueue) Pop() int &#123; var tmp *Node for this.StackPush != nil &#123; tmp = this.StackPop this.StackPop = this.StackPush this.StackPush = this.StackPush.Next this.StackPop.Next = tmp &#125; popValue := this.StackPop.Val this.StackPop = this.StackPop.Next this.Flag = this.StackPop return popValue&#125;func (this *MyQueue) Peek() int &#123; return this.Flag.Val&#125;func (this *MyQueue) Empty() bool &#123; if this.StackPush == nil &amp;&amp; this.StackPop == nil &#123; return true &#125; return false&#125; 總結:若需要以stack的方式來實作quene，可以使用兩個stack來達到目標，在push時其一先是用來插入元素，當需要pop元素時，可以將原本push所用的stack倒入另一個stack之中，此時最舊的元素就會在最頂端，若是透過這種方式實作，不管之後是要做push或pop，在動作之前都要先確認其動作所對應的stack，是不是已經將另一個stack的元素完全倒入，若確認無誤才開始處理。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Stack","slug":"Stack","permalink":"https://blog.yunchen.tw/tags/Stack/"},{"name":"Design","slug":"Design","permalink":"https://blog.yunchen.tw/tags/Design/"}]},{"title":"Power of Two","slug":"power-of-two","date":"2017-02-02T16:00:00.000Z","updated":"2017-04-05T15:12:16.000Z","comments":true,"path":"2017/02/03/power-of-two/","link":"","permalink":"https://blog.yunchen.tw/2017/02/03/power-of-two/","excerpt":"","text":"Power of TwoGiven an integer, write a function to determine if it is a power of two. 提示 解題應用 Math 規律觀查 BitManipulation AND Default:123func isPowerOfTwo(n int) bool &#123; &#125; 解答思路:一開始對BitManipulation思索半天，唯一能確定的是如果是在二進位中，要符合二的n次方肯定第一個位元是1而且只有1個，至於後面有多少個0就看次方是多少，但如果我們是以這樣的來方判斷是不是二進位只有一個1，意味著要遍歷每一個位元，這樣需要的時間其實就和我們將值不斷除以2來確認餘數是否為0差不多: 123456789101112func isPowerOfTwo(n int) bool &#123; if n &lt;= 0 &#123; return false &#125; for n != 1 &#123; if n%2 != 0 &#123; return false &#125; n = n / 2 &#125; return true&#125; 至於在確認完其它人對BitManipulation解法後恍然大悟，只要將該數與該數-1兩個值做AND便能輕易的判斷，因為如果是二的n次方在二進位中是必開頭位元為1其餘位元為0，此時如果將該值-1就會變成開頭位元為0其餘位元為1，如果將兩個值做AND就可以知道為0的結果勢必為2的n次方，因為1與0做AND為0，其餘的狀況則非為2的n次方值。 程式碼解說:一開始要先判斷該數是不是為0或為負數，因為0與負數肯定不是2的n次方值，接著我們才確認如上述所說的(該數)與(該數-1)做二進位的&amp;(AND)，如果結果為0就回傳true，否則回傳false 1234if n &gt; 0 &amp;&amp; n&amp;(n-1) == 0 &#123; return true&#125;return false 完整程式碼:123456func isPowerOfTwo(n int) bool &#123; if n &gt; 0 &amp;&amp; n&amp;(n-1) == 0 &#123; return true &#125; return false&#125; 總結:要確認一數是否為2的n次方有兩種方法，其一是將該數不斷除以2來確認餘數是否為0直到值為1，另一種方是則是將(該數)與(該數-1)做二進位的&amp;(AND)，若為二的n次方其結果必為0。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"},{"name":"BitManipulation","slug":"BitManipulation","permalink":"https://blog.yunchen.tw/tags/BitManipulation/"}]},{"title":"Invert Binary Tree","slug":"invert-binary-tree","date":"2017-02-01T16:00:00.000Z","updated":"2017-04-05T15:12:10.000Z","comments":true,"path":"2017/02/02/invert-binary-tree/","link":"","permalink":"https://blog.yunchen.tw/2017/02/02/invert-binary-tree/","excerpt":"","text":"Invert Binary TreeInvert a binary tree. 12345 4 / \\ 2 7 / \\ / \\1 3 6 9 to 12345 4 / \\ 7 2 / \\ / \\9 6 3 1 提示 解題應用 Tree 樹的遍歷方式 Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func invertTree(root *TreeNode) *TreeNode &#123;&#125; 解答思路:仔細觀查的話會發現只是子節點兩兩互換，而節點與節點間的子間點並不會互相影響，所以我們就可以先將左右子節點互換後再繼續往下遍歷，為前序遍歷的方式做處理就能很容易搞定了。 程式碼解說:在前序遍歷的遞回中，只要記得先判斷該節點是否存在，就不需擔心其餘的處理會有問題，用一變數來暫存任一子節點的位置，將子節點兩兩互換後再對其遍歷，至於是否要有回傳值端看個人寫法，畢竟是傳址處理而又不需要比較回傳的結果 123456789var tmp *TreeNodeif node != nil &#123; tmp = node.Left node.Left = node.Right node.Right = tmp preOrderTravel(node.Left) preOrderTravel(node.Right)&#125;return node 完整程式碼:1234567891011121314func invertTree(root *TreeNode) *TreeNode &#123; return preOrderTravel(root)&#125;func preOrderTravel(node *TreeNode) *TreeNode &#123; var tmp *TreeNode if node != nil &#123; tmp = node.Left node.Left = node.Right node.Right = tmp preOrderTravel(node.Left) preOrderTravel(node.Right) &#125; return node&#125; 總結:要將一樹節點的子節點左右兩兩位置互換，且節點與節點間的子間點並不會互相影響的話，藉由先將左右子節點互換後再往下遍歷(前序遍歷)即可。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"}]},{"title":"Implement Stack using Queues","slug":"implement-stack-using-queues","date":"2017-01-28T16:00:00.000Z","updated":"2017-04-05T15:12:04.000Z","comments":true,"path":"2017/01/29/implement-stack-using-queues/","link":"","permalink":"https://blog.yunchen.tw/2017/01/29/implement-stack-using-queues/","excerpt":"","text":"Implement Stack using QueuesImplement the following operations of a stack using queues. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. empty() – Return whether the stack is empty. Note: You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack). 提示 解題應用 Stack Quene Default:12345678910111213141516171819202122232425262728293031323334353637383940414243type MyStack struct &#123; &#125;/** Initialize your data structure here. */func Constructor() MyStack &#123; &#125;/** Push element x onto stack. */func (this *MyStack) Push(x int) &#123; &#125;/** Removes the element on top of the stack and returns that element. */func (this *MyStack) Pop() int &#123; &#125;/** Get the top element. */func (this *MyStack) Top() int &#123; &#125;/** Returns whether the stack is empty. */func (this *MyStack) Empty() bool &#123; &#125;/** * Your MyStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Empty(); */ 解答思路:這題要你設計一個stack，不過說穿了不盡然是個stack，而是要用quene的方式去模擬，要利用隊列的特性來實作stack也就是先進先出，這邊我仍採用linkedlist方式來實作，最主要關注在物件的兩個function:push與pop，以原本的stack設計來說，push新的節點都是在最頂端，而舊的則是接在後頭，但在隊列實作則是新的節點一直在後頭，這還沒什麼問題，我們只要以一個flag一直指向最新新增的節點位置即可，但是pop就有點麻煩了，原本只要將頂端的節點拿掉，變成隊列後就要一個個遍歷，並將出隊列的節點再塞回隊列之中，直到找到要取出的節點為止再做嫁接。 程式碼解說:初始化一LinkedList需要自行訂義節點，包含值與下一個目標位置，而MyStack主要用來存放頭節點的位置以判斷是否stack為空(只有該頭節點存在)，而flag則是指向最新的節點位置，方便做節點插入與得知對stack來說其為頂端的節點，最後在建構的function就是初始化頭節點並指派其為Header與Flag的值 12345678910111213type Node struct &#123; Val int Next *Node&#125;type MyStack struct &#123; Header *Node Flag *Node&#125;func Constructor() MyStack &#123; newNode := &amp;Node&#123;&#125; newNode.Next = newNode return MyStack&#123;newNode, newNode&#125;&#125; 與原本stack節點都是從頭插入不同，在隊列中都是從最後頭塞入節點，而Flag就將舊節點的下一個指向新節點並將Flag也跟著移到新節點的位置，而在隊列中最新的節點在初始化時，我們將其下一個目標位置指回了頭節點，以方便遍歷時判斷是否還有其它節點存在(沒有的話就只有頭節點) 12345func (this *MyStack) Push(x int) &#123; newNode := &amp;Node&#123;x, this.Header&#125; this.Flag.Next = newNode this.Flag = newNode&#125; 一開始先將最新節點也就是要Pop出去的節點位置給儲存下來，接著開始從隊列開頭一個個遍歷(頭節點除外)，如果為我們要Pop的節點，就將頭節點嫁接到目標節點的下一個節點並回傳其值，也可以在這邊多加一行去釋放目標節點的記憶體空間，至於那些從隊列拿出但不是目標的節點，就將其塞回隊列尾端，同時將Flag做更新，最後與push時相同，將當前最新節點的下一個目標位置指回了頭節點，以方便遍歷時判斷是否還有其它節點存在，至於如果有任何的例外狀況，像是stack沒有任何值卻要pop，這時就回傳一任意值(這邊以0做為範例) 123456789101112131415func (this *MyStack) Pop() int &#123; popNode := this.Flag head := this.Header.Next for head != this.Header &#123; if head == popNode &#123; this.Header.Next = head.Next return head.Val &#125; this.Flag.Next = head this.Flag = head head = head.Next this.Flag.Next = this.Header &#125; return 0&#125; 因為\bFlag始終指向最新節點的位置，所以這時就只要回傳Flag位置節點的值即可 123func (this *MyStack) Top() int &#123; return this.Flag.Val&#125; 如果stack之中沒有其它的節點存在，表示quene之中只存在頭節點，而這時只要判斷是否頭節點的下一個目標節點仍為頭節點，如果是就回傳true，否則就回傳false 123456func (this *MyStack) Empty() bool &#123; if this.Header.Next == this.Header &#123; return true &#125; return false&#125; 完整程式碼:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748type Node struct &#123; Val int Next *Node&#125;type MyStack struct &#123; Header *Node Flag *Node&#125;func Constructor() MyStack &#123; newNode := &amp;Node&#123;&#125; newNode.Next = newNode return MyStack&#123;newNode, newNode&#125;&#125;func (this *MyStack) Push(x int) &#123; newNode := &amp;Node&#123;x, this.Header&#125; this.Flag.Next = newNode this.Flag = newNode&#125;func (this *MyStack) Pop() int &#123; popNode := this.Flag head := this.Header.Next for head != this.Header &#123; if head == popNode &#123; this.Header.Next = head.Next return head.Val &#125; this.Flag.Next = head this.Flag = head head = head.Next this.Flag.Next = this.Header &#125; return 0&#125;func (this *MyStack) Top() int &#123; return this.Flag.Val&#125;func (this *MyStack) Empty() bool &#123; if this.Header.Next == this.Header &#123; return true &#125; return false&#125; 總結:設計一個stack要用quene的方式去模擬，最主要關注在物件的兩個function:push與pop。 Push: 以原本的stack設計來說，push新的節點都是在最頂端，而舊的則是接在後頭，但在隊列實作則是新的節點一直在後頭 Pop: 原本stack設計只要將頂端的節點拿掉，變成隊列後就要一個個遍歷，並將出隊列的節點再塞回隊列之中，直到找到要取出的節點為止再做嫁接","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Stack","slug":"Stack","permalink":"https://blog.yunchen.tw/tags/Stack/"},{"name":"Design","slug":"Design","permalink":"https://blog.yunchen.tw/tags/Design/"}]},{"title":"Contains Duplicate II","slug":"contains-duplicate-II","date":"2017-01-27T16:00:00.000Z","updated":"2017-04-05T15:11:57.000Z","comments":true,"path":"2017/01/28/contains-duplicate-II/","link":"","permalink":"https://blog.yunchen.tw/2017/01/28/contains-duplicate-II/","excerpt":"","text":"Contains Duplicate IIGiven an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k. 提示 解題應用 HashTable HashMap Default:123func containsNearbyDuplicate(nums []int, k int) bool &#123;&#125; 解答思路:這次要檢查是否存在一組值相同而且彼此的index值差不大於k，這邊要注意到一點是雖然是要找一組，但是也有可能出現3個或以上相同的值，而這些值只要有一組的index不大於k就算符合條件，並沒有強制規定該值一定只有兩個(一組)，所以我們在取出值的同時，除了判斷其是否存在，也不過多了再確認index值的差距，如果超過k值就將原本存在值的index給取代(因為越後面差距只會越大)，直到發現符合條件的結果。 程式碼解說:一開始一樣先初始化一hashMap，接著再以回圈一一取出值來判斷是否存在於hashmap中，如果存在而且彼此值之間的index小於等於k就回傳true，否則就將值放入key而index做value，不存在的話就是塞入值，不然就是將原本存在值的index給取代(因為越後面差距只會越大)，最後如果找不到符合條件的結果則回傳false 123456789hashTable := make(map[int]int)for i, v := range nums &#123; index, ok := hashTable[v] if ok &amp;&amp; i-index &lt;= k &#123; return true &#125; hashTable[v] = i&#125;return false 完整程式碼:1234567891011func containsNearbyDuplicate(nums []int, k int) bool &#123; hashTable := make(map[int]int) for i, v := range nums &#123; index, ok := hashTable[v] if ok &amp;&amp; i-index &lt;= k &#123; return true &#125; hashTable[v] = i &#125; return false&#125; 總結:檢查是否存在一組值相同而且彼此的index值差不大於k，除了判斷其是否存在在hashmap，也要再確認index值的差距，如果超過k值就將原本存在值的index給取代(因為越後面差距只會越大)，直到發現符合條件的結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"}]},{"title":"Contains Duplicate","slug":"contains-duplicate","date":"2017-01-26T16:00:00.000Z","updated":"2017-04-05T15:11:50.000Z","comments":true,"path":"2017/01/27/contains-duplicate/","link":"","permalink":"https://blog.yunchen.tw/2017/01/27/contains-duplicate/","excerpt":"","text":"Contains DuplicateGiven an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. 提示 解題應用 HashTable HashMap Default:123func containsDuplicate(nums []int) bool &#123;&#125; 解答思路:檢查其陣列元元素是否每個都獨一無二，如果不是就回傳true，否則就回傳false，而想當然就是將不存在的值塞入HashTable中，直到發現該值存在在其中就回傳true，大致上是這樣。 程式碼解說:一開始先初始化一個hashmap，接著在以迴圈一一取出元素時，判斷該值是否存在hashmap之中，如果存在就表示有兩個以上回傳true，否則就將其值同時放入key與value之中，直到都沒有發現有重覆的狀況才回傳false 123456789hashTable := make(map[int]int)for _, v := range nums &#123; _, ok := hashTable[v] if ok &#123; return true &#125; hashTable[v] = v&#125;return false 完整程式碼:1234567891011func containsDuplicate(nums []int) bool &#123; hashTable := make(map[int]int) for _, v := range nums &#123; _, ok := hashTable[v] if ok &#123; return true &#125; hashTable[v] = v &#125; return false&#125; 總結:檢查一陣列元元素是否每個都獨一無二，使用HashMap來做儲存並判斷其是否存在是很好的選擇。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"}]},{"title":"Reverse Linked List","slug":"reverse-linked-list","date":"2017-01-25T16:00:00.000Z","updated":"2017-04-05T15:11:43.000Z","comments":true,"path":"2017/01/26/reverse-linked-list/","link":"","permalink":"https://blog.yunchen.tw/2017/01/26/reverse-linked-list/","excerpt":"","text":"Reverse Linked ListReverse a singly linked list. 提示 解題應用 LinkedList Pointer Default:12345678910/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func reverseList(head *ListNode) *ListNode &#123;&#125; 解答思路:僅需要一次的遍歷就可以同時反轉整個LinkedList，想好每一個操作的流程就可以很輕易的完成，只是要記得在將節點的位置移動到下一個之前，要先記錄前一個節點的位置，以繼續將其目標再指向更前方。 程式碼解說:這邊我以flag來記錄目前正在處理的節點，以方便我們將整個節點移動到下一個時，能繼續將前一個節點的目標再往前指向，而preNode就是其所指向的位置，既然是反轉LinkedList，那麼原本第一個節點會成為最後一個，而最後一個節點的下一個自然就是空節點nil，而flag指定完畢往下移動後，自然preNode也就跟著往下移變到flag的位置，最後處理完最後一個節點時，回傳當下處理的節點位置，也就是原本最後一個的節點變成第一個節點且處理完畢的flag 123456789var flag *ListNodevar preNode *ListNodefor head != nil &#123; flag = head head = head.Next flag.Next = preNode preNode = flag&#125;return flag 完整程式碼:1234567891011func reverseList(head *ListNode) *ListNode &#123; var flag *ListNode var preNode *ListNode for head != nil &#123; flag = head head = head.Next flag.Next = preNode preNode = flag &#125; return flag&#125; 總結:如果要反轉一個LinkedList，記得在將節點的位置移動到下一個之前，要先記錄前一個節點的位置，以繼續將其目標再指向更前方。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://blog.yunchen.tw/tags/LinkedList/"}]},{"title":"Isomorphic Strings","slug":"isomorphic-strings","date":"2017-01-24T16:00:00.000Z","updated":"2017-04-05T15:11:36.000Z","comments":true,"path":"2017/01/25/isomorphic-strings/","link":"","permalink":"https://blog.yunchen.tw/2017/01/25/isomorphic-strings/","excerpt":"","text":"Isomorphic StringsGiven two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. For example:12345Given &quot;egg&quot;, &quot;add&quot;, return true.Given &quot;foo&quot;, &quot;bar&quot;, return false.Given &quot;paper&quot;, &quot;title&quot;, return true. 提示 解題應用 HashTable HashMap Default:123func isIsomorphic(s string, t string) bool &#123;&#125; 解答思路:這個最初在寫時會因為題意上的陷阱而讓你忽略了一些細節，乍看之下要的是字串的結構相同，很容易就會將兩個字串間的字母做連結，但重點在於真的是1對1的關係嗎?以egg與add來說，直接把”e與a”做連結，”g與d”做連結後存入hashMap之中都沒有問題，eggb與adda呢?這時多出了”b與a”做連結，結果當然是false，因為有兩個(含)以上的點與a做連結，但是egga與addb的結果卻是true，原本的”e與a”做連結且多出”a與b”做連結是沒有問題的，看起來不僅僅是1對1的關係，而是以”連結點”與”被連結點”的關係，也就是說a點可以當連結點與被連結點各一個，但是不能存在a同時為兩個其它點的連結點或a為其它兩個點的被連結點，只要能抓住這個訣竅就可以很順利的寫出想要的程式。 程式碼解說:如上述所說，以兩個不同的hashmap來存放”連結點”(origin)及”被連結點”(reverse)與其它點的關係，接著在迴圈取出字母的同時分別確認兩個hashmap是否存在其字母的關係，如果不存在就分別在兩個hashmap建立其字母的關係(例:一個存放a→b，另一則b→a)，如果存在就檢查目前該字母在hashmap中所對應到的關係，是否與另一字串中對應的字母相同，若不同就回傳false，直到全數檢查完畢才回傳true。 12345678910111213141516var runeT runeorigin := make(map[rune]rune)reverse := make(map[rune]rune)for i, v := range s &#123; runeT = rune(t[i]) char, ok := origin[v] _, exist := reverse[runeT] if !ok &amp;&amp; !exist &#123; origin[v] = runeT reverse[runeT] = v continue &#125; else if char != runeT &#123; return false &#125;&#125;return true 完整程式碼:123456789101112131415161718func isIsomorphic(s string, t string) bool &#123; var runeT rune origin := make(map[rune]rune) reverse := make(map[rune]rune) for i, v := range s &#123; runeT = rune(t[i]) char, ok := origin[v] _, exist := reverse[runeT] if !ok &amp;&amp; !exist &#123; origin[v] = runeT reverse[runeT] = v continue &#125; else if char != runeT &#123; return false &#125; &#125; return true&#125; 總結:要判斷兩字串結構上是否相同，首先要注意的是字串的字母間關係是否為1對1的關係或是”連結點”與”被連結點”的關係以點a到點b來說，若為前者是絕對關係，a→b,b→a要放入相同的hashmap中，若為後者則是存在a點或b點可以當連結點與被連結點各一個，且不存在同時為兩個其它點的連結點或被連結點，a→b放入一hashmap而b→a放入另一hashmap以區別。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"}]},{"title":"Count Primes","slug":"count-primes","date":"2017-01-20T16:00:00.000Z","updated":"2017-04-05T15:11:29.000Z","comments":true,"path":"2017/01/21/count-primes/","link":"","permalink":"https://blog.yunchen.tw/2017/01/21/count-primes/","excerpt":"","text":"Count PrimesCount the number of prime numbers less than a non-negative number, n. 提示 解題應用 HashTable Array Math 規律觀查 Default:123func countPrimes(n int) int &#123;&#125; 解答思路:非常典型的空間換取時間，因為在最初一開始我是將2~n的數字每個去除2~√n如果餘數為0就表示非質數，不從1開始是因為1不是質數，除數為1也沒有意義，至於為什麼不是除數除到n而是根號n，可以去參考leetcode本題的提示有解說原理，以前寫類似的題目是直接除數除到n/2要再快些才√n，而以go來說出來的結果要上約1500ms，超時沒辦法通過，就算為了避免呼叫到開根號的函式而將其判斷式平方(j&lt;=√n)[j^2&lt;=n]也只約1400ms一樣沒辦法，如下: 123456789101112131415var count intflag := truefor i := 2; i &lt; n; i++ &#123; for j := 2; j*j &lt;= i; j++ &#123; if i%j == 0 &#123; flag = false break &#125; &#125; if flag &#123; count++ &#125; flag = true&#125;return count 即然不需要擔心空間上的問題就只好以空間來換取時間，將2~n所有是否為質數的狀態全部儲存下來，之後每發現一個質數，就再利用迴圈將其所有倍數的狀態給相反直到n，而最後保留下來狀態沒被改變的就是我們要的結果，可以一邊做計算或是選擇最後再遍歷全部的狀態來計算，此方式甚至連1ms都不到，但是會花費大量的空間。 程式碼解說:一開始要宣告與n相同長度的陣列，用來儲存2~n所有是否為質數的狀態，不過在儲存時因為是index，所以要記得-1，之後就開始以迴圈一個個找出質數，正因為開頭的2、3…皆為質數，所以一開始再以另一個迴圈篩選所有其倍數時就已經除去大部分非質數的結果了，此時便可以安心的一邊做計算數量，一邊繼續找質數並篩選其倍數，最後就可以將總數做回傳 1234567891011var count intnotPrime := make([]bool, n)for i := 2; i &lt; n; i++ &#123; if !notPrime[i-1] &#123; count++ for j := 2; i*j &lt; n; j++ &#123; notPrime[i*j-1] = true &#125; &#125;&#125;return count 完整程式碼:12345678910111213func countPrimes(n int) int &#123; var count int notPrime := make([]bool, n) for i := 2; i &lt; n; i++ &#123; if !notPrime[i-1] &#123; count++ for j := 2; i*j &lt; n; j++ &#123; notPrime[i*j-1] = true &#125; &#125; &#125; return count&#125; 總結:如果在做質數上的判斷超時，建議以空間來換取時間，將2~n所有是否為質數的狀態全部儲存下來，之後每發現一個質數，就再利用迴圈將其所有倍數的狀態給相反直到n，而最後保留下來狀態沒被改變的就是結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"Remove Linked List Elements","slug":"remove-linked-list-elements","date":"2017-01-19T16:00:00.000Z","updated":"2017-04-05T15:11:21.000Z","comments":true,"path":"2017/01/20/remove-linked-list-elements/","link":"","permalink":"https://blog.yunchen.tw/2017/01/20/remove-linked-list-elements/","excerpt":"","text":"Remove Linked List ElementsRemove all elements from a linked list of integers that have value val. Example:12Given: 1 --&gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6, val = 6Return: 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5 提示 解題應用 LinkedList Pointer Default:12345678910/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func removeElements(head *ListNode, val int) *ListNode &#123;&#125; 解答思路:總覺得類似的題目非常的多，而一樣為了要確保操作上的一致性，所以在第一個節點前再加上一個頭節點，接著就是找到目標節點然後對其做嫁接，至於要不要再多寫一行去釋放其記憶體就看個人，只是要記得再往下一個節點尋找時要記錄前一個節點的位置，畢竟節點設計的遍歷是不可逆，記錄後便能直接進行嫁接而不需再去尋找前一個節點的位置。 程式碼解說:正如前述為了要確保一致性，所以就先初始化一個節點然後指向原本第一個節點的位置，而且最後仍須回傳整個LinkedList的第一個節點，只管回傳頭節點的所指向的下一個位置，不需要擔心如果是前面節點被砍掉還要判斷回傳後頭節點的問題，不過這次我們就直接從第一個節點開始，而不是從我們新增的頭節點開始，因為檢查自己加頭節點的值根本沒有意義，同時也要記得要記錄前一個節點的位置，方便在迴圈進行節點遍歷而找到目標節點時進行的嫁接，在嫁接時可能會出現連續要跳過好幾個目標節點，這時前一個節點的位置就不需要改變，一直到沒有再嫁接的狀況出現，當前節點開始繼續往下移動，紀錄前一個節點的位置才需要隨著改變 12345678910111213header := &amp;ListNode&#123;&#125;var preNode *ListNodeheader.Next = headpreNode = headerfor head != nil &#123; if head.Val == val &#123; preNode.Next = head.Next &#125; else &#123; preNode = head &#125; head = head.Next&#125;return header.Next 完整程式碼:123456789101112131415func removeElements(head *ListNode, val int) *ListNode &#123; header := &amp;ListNode&#123;&#125; var preNode *ListNode header.Next = head preNode = header for head != nil &#123; if head.Val == val &#123; preNode.Next = head.Next &#125; else &#123; preNode = head &#125; head = head.Next &#125; return header.Next&#125; 總結:在一個LinkedList中如果要移除任一個目標節點，在操作之前可以再第一個節點前再加上一個頭節點，以確保後續迴圈在操作上第一個節點也能與其它節點達成一致性。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://blog.yunchen.tw/tags/LinkedList/"}]},{"title":"Happy Number","slug":"happy-number","date":"2017-01-18T16:00:00.000Z","updated":"2017-04-05T15:11:09.000Z","comments":true,"path":"2017/01/19/happy-number/","link":"","permalink":"https://blog.yunchen.tw/2017/01/19/happy-number/","excerpt":"","text":"Happy NumberWrite an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example:19 is a happy number 12341^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1 提示 解題應用 Math 規律觀查 HashTable HashMap Default:123func isHappy(n int) bool &#123;&#125; 解答思路:相當直覺好解的題目，不過重點在於什麼時候停下來，其實就是一路記錄總合的結果，直到發現有值重覆的情況或是最後總合為1兩種情況，其餘的就是一直不斷的重覆探究各種可能的結果，有一數列在開頭一小段之後，中間的數列便出現了不斷重覆的情況有人稱為龜兔賽跑定理，總而言之在這裡只要用hashMap做儲存，一發現該值的總合已經存在裡頭，表示此刻已經開始重覆先前的數列，如果先前都不是總合為1，那麼肯定之後重覆的數列也不會出現了。 程式碼解說:如果要判斷總合是否出現重覆，那麼一開始給的值記得也要塞入hashmap中，不過我們只關注key的值是否重覆出現，至於value則是都可以，這裡我就直接塞與key一樣的值，第一個迴圈發現hashmap沒有這個值的話就繼續查看下一個總合，不過在那之前先把其值給存入hashmap，接著將舊的總合歸0，然後開始重新計算每位數次方總合的結果，如果總合為1當然就是目標值回傳true，否則就再繼續判斷是否hashmap存在這個總合的結果，然後重覆上述步驟直到找到目標或發覆重覆結果。 1234567891011121314151617sum := nhashMap := make(map[int]int)_, ok := hashMap[sum]for !ok &#123; hashMap[sum] = sum sum = 0 for n != 0 &#123; sum += (n % 10) * (n % 10) n = n / 10 &#125; if sum == 1 &#123; return true &#125; n = sum _, ok = hashMap[sum]&#125;return false 完整程式碼:12345678910111213141516171819func isHappy(n int) bool &#123; sum := n hashMap := make(map[int]int) _, ok := hashMap[sum] for !ok &#123; hashMap[sum] = sum sum = 0 for n != 0 &#123; sum += (n % 10) * (n % 10) n = n / 10 &#125; if sum == 1 &#123; return true &#125; n = sum _, ok = hashMap[sum] &#125; return false&#125; 總結:快樂數的找法就和龜兔賽跑定理一樣，其實就是一路記錄總合的結果，直到發現有值出現重覆或是達成指定結果兩種情況，其餘的就是一直不斷的重覆探究各種可能的結果，而因為不需理會值之間的關係，便以hashmap做儲存來方便快速查詢。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"House Robber","slug":"house-robber","date":"2017-01-17T16:00:00.000Z","updated":"2017-04-05T15:11:02.000Z","comments":true,"path":"2017/01/18/house-robber/","link":"","permalink":"https://blog.yunchen.tw/2017/01/18/house-robber/","excerpt":"","text":"House RobberYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 提示 解題應用 DynamicProgramming 規律觀查 Default:123func rob(nums []int) int &#123;&#125; 解答思路:這題卡了滿長一段時間，原因在於不曉得要從何下手，如果是要找偷兩棟不連續的房子求最大值，那只要把所有除了連續狀況遍歷一次就好了，但這題要的不只有單單兩棟，而是不會在相連房子盜取的情況下盡可能去盜取最大資產，所以看來是要換個方式來想，如果只是分成第1、3、5棟全偷再與2、4、6全偷比較兩者誰的多當然也許有這種狀況，不過實際上有可能出現會1、3、6偷出來的結果會更多，所以如果能一步步模擬會出現的結果，或許就有辦法推出結論: 這邊有一數列為[3, 2, 1, 5]，將其分為左(index奇數)與右(index偶數)來區別，之後只要判斷如果輪到該數而那一側的總合結果比另一側小，這時另一側的總合就能取代原本那一側的總合變成兩側值都一樣，因為另一側index比較小不用擔心相鄰問題，變成可以選擇要繼續往下跳做總合或是往下下個跳(其實就是原本那側的下一個，所以才用取代以方便寫程式)，再分別繼續往下重覆上述動作。 1234 51 2 ← 第二個值進來的時候發現比另一側小3(此時3可以繼續與1做總合，或是與5做總合[把2取代掉的意思]) 程式碼解說:首先利用迴圈將值一個個取出，接著再藉由index為奇、偶數分為兩側，如果另一側的總合大於輪到該數的那一側，就將另一側的總合取代該側，此時就等於是以另一側為主來找最大值，繼續做下一項的總合或下下項的總合(index比較小不用擔心相鄰問題)，最後跳開迴圈再做最後一次比較兩側的總合，較大的就回傳結果 12345678910111213141516171819var odd intvar even intfor i, v := range nums &#123; if i%2 != 0 &#123; odd = odd + v if even &gt; odd &#123; odd = even &#125; &#125; else &#123; even = even + v if odd &gt; even &#123; even = odd &#125; &#125;&#125;if odd &gt; even &#123; return odd&#125;return even 完整程式碼:123456789101112131415161718192021func rob(nums []int) int &#123; var odd int var even int for i, v := range nums &#123; if i%2 != 0 &#123; odd = odd + v if even &gt; odd &#123; odd = even &#125; &#125; else &#123; even = even + v if odd &gt; even &#123; even = odd &#125; &#125; &#125; if odd &gt; even &#123; return odd &#125; return even&#125; 總結:要在一數列中找出不連續的極大值總合，訣竅就是將其分為左(index奇數)與右(index偶數)來區別，之後只要判斷如果輪到該數而那一側的總合結果比另一側小，這時另一側的總合就能取代原本那一側的總合變成兩側值都一樣，再分別繼續往下(兩側跳項做總合)重覆上述動作(因另一側index比較小不用擔心相鄰問題)。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"https://blog.yunchen.tw/tags/DynamicProgramming/"}]},{"title":"Rotate Array","slug":"rotate-array","date":"2017-01-16T16:00:00.000Z","updated":"2017-04-05T15:10:56.000Z","comments":true,"path":"2017/01/17/rotate-array/","link":"","permalink":"https://blog.yunchen.tw/2017/01/17/rotate-array/","excerpt":"","text":"Rotate ArrayRotate an array of n elements to the right by k steps. For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. 提示 解題應用 Array Array/Slice Default:123func rotate(nums []int, k int) &#123;&#125; 解答思路:之所以這題沒有一個回傳值是因為要你乖乖的做陣列的位移，否則如果是一般有腳本語言特性的程式語言大概一行便能搞定了吧!因為只是回傳該陣列的嫁接罷了(array[起始index:長度])，所以必需要幫array的每一個值做移動，雖然至少有三種以上的方式可以完成，不過目前還是暫時只寫想到的其中一種，總之就是先記錄陣列中的最後一個值，接著在開始將元素一個個向後取代，之到結束才將剛剛存的最後一個值放入第一個，再看總共需要重覆做幾次上述的動作即可。 程式碼解說:正如先前所說，第一個迴圈用來計算共需重覆做多少次向右位移，而在第二個迴圈開始將一個個值向後移動取代之前，先將陣列最後一個值取出暫存以防止被覆蓋，最後在全部位移完畢後，才將暫存的最後一個值放入index為0的位置 123456789var last intlength := len(nums)for i := 1; i &lt;= k; i++ &#123; last = nums[length-1] for j := length - 2; j &gt;= 0; j-- &#123; nums[j+1] = nums[j] &#125; nums[0] = last&#125; 完整程式碼:1234567891011func rotate(nums []int, k int) &#123; var last int length := len(nums) for i := 1; i &lt;= k; i++ &#123; last = nums[length-1] for j := length - 2; j &gt;= 0; j-- &#123; nums[j+1] = nums[j] &#125; nums[0] = last &#125;&#125; 總結:遇到需要將陣列向右位移(旋轉)的狀況時，先將陣列中最後一個值給暫存起來，接著才一個個將往後做取代，完成之後才將暫存的值放入陣列的第一個，最後再依題目共需要做幾次位移重覆上述的動作。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"}]},{"title":"Factorial Trailing Zeroes","slug":"factorial-trailing-zeroes","date":"2017-01-12T16:00:00.000Z","updated":"2017-04-05T15:10:49.000Z","comments":true,"path":"2017/01/13/factorial-trailing-zeroes/","link":"","permalink":"https://blog.yunchen.tw/2017/01/13/factorial-trailing-zeroes/","excerpt":"","text":"Factorial Trailing ZeroesGiven an integer n, return the number of trailing zeroes in n!. Note: Your solution should be in logarithmic time complexity. 提示 解題應用 Math 觀查規律 Default:123func trailingZeroes(n int) int &#123;&#125; 解答思路:這題時間上訂的滿嚴格，只要沒有用對方法基上都不會過，而在n!要求後頭有幾個0最重要的在於怎麼湊到0，既然有0想必為10的倍數才有可能，而10進而拆開的話是2與5做相乘，所以在乘階上要湊到尾數有0相必至少有相應數量的2與5，而2的數量光是2與4與6及8的倍數就太多了，觀查會發現尾數有多少個0在乘階上就會有多少個5的倍數，如此一來我們只要找出5的倍數有多少個就可以了，在一開始我用一回圈遍歷5的倍數直到小於給的n!，之中再一回圈去算該數的5的倍數共有多少個5的乘積，但是仍然超過時間，因為有更簡單的方式，直接將n!的n去除5，再除25、125…一直到n/(5的x次方)為0，就可以直接算出n!因式分解後共有多少個5的乘積，等同推出結果尾數有多少個0。 程式碼解說:有了公式就是不斷的將n!的n去除以5的次方總合後，再來就是用迴圈不斷將n去除5的次方，然後將每次除完的結果做總合，再將除數乘上5繼續重覆執行，直到要增加至總合的結果為0才跳開回圈回傳總合 123456789var count inttmp := 5mult5 := n / tmpfor mult5 != 0 &#123; count = count + mult5 tmp = tmp * 5 mult5 = n / tmp&#125;return count 完整程式碼:1234567891011func trailingZeroes(n int) int &#123; var count int tmp := 5 mult5 := n / tmp for mult5 != 0 &#123; count = count + mult5 tmp = tmp * 5 mult5 = n / tmp &#125; return count&#125; 總結:n!要求後頭有幾個0，想必為10的乘積有多少個，間接推出5的乘積有多少個，畢竟2的乘積數量足夠多了，所以重點在於5，而n!因式分解後要知道有多少個5的乘積數最簡單的方式如下: n!的5乘積數 = [n/5] + [n/25] + [n/125] … + ([n/5的某次方]此值為0為止)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"Excel Sheet Column Number","slug":"excel-sheet-column-number","date":"2017-01-11T16:00:00.000Z","updated":"2017-04-05T15:10:38.000Z","comments":true,"path":"2017/01/12/excel-sheet-column-number/","link":"","permalink":"https://blog.yunchen.tw/2017/01/12/excel-sheet-column-number/","excerpt":"","text":"Excel Sheet Column NumberRelated to question Excel Sheet Column Title Given a column title as appear in an Excel sheet, return its corresponding column number. For example:1234567A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 提示 解題應用 Math 觀查規律 Default:123func titleToNumber(s string) int &#123;&#125; 解答思路:這題與先前的一篇 Excel Sheet Column Title 有相關。 這次給你字母要你還原回數字，相較於數字要轉字母會有借位的情況，字母轉回數字就沒有特例了，所以可以放心去直接轉換，如果反而會覺得複雜的話，想成是在做26進位制就容易多了，每26個數字就進一位，所以說每一位的字母要還原回數字時就是26的n次方(位數-1)再乘上該數字(字母)，一直將每一位的結果總合到最後一位也就是26的0次方為1再乘上該數字(字母)就大功告成了，跟先前一樣因為要定義A~Z為1~26太麻煩，所以最後就直接將字母轉成ASCII再減64以方便處理。 程式碼解說:在將字母轉成數字時，先從最後一位開始算起，因為26的0次方為1，所以一開始先用tmp做暫存，接著與字母做相乘，我們直接強制轉成ASCII後減64，每往前一個字母就表示進了一位，所以tmp就要多乘上64，最後將每一位的結果做相加後回傳 1234567var sum inttmp := 1for i := len(s) - 1; i &gt;= 0; i-- &#123; sum = sum + tmp*(int(s[i])-64) tmp = tmp * 26&#125;return sum 完整程式碼:123456789func titleToNumber(s string) int &#123; var sum int tmp := 1 for i := len(s) - 1; i &gt;= 0; i-- &#123; sum = sum + tmp*(int(s[i])-64) tmp = tmp * 26 &#125; return sum&#125; 總結:如果覺得字母轉數字複雜的話，想成是在做26進位制就容易多了，每26個數字就進一位，所以說每一位的字母要還原回數字時就是26的n次方(位數-1)再乘上該數字(字母)，一直將每一位的結果總合到最後一位也就是26的0次方為1再乘上該數字(字母)就大功告成了。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"Majority Element","slug":"majority-element","date":"2017-01-10T16:00:00.000Z","updated":"2017-04-05T15:10:21.000Z","comments":true,"path":"2017/01/11/majority-element/","link":"","permalink":"https://blog.yunchen.tw/2017/01/11/majority-element/","excerpt":"","text":"Majority ElementGiven an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. 提示 解題應用 HashTable HashMap Default:123func majorityElement(nums []int) int &#123;&#125; 解答思路:雖然本題的標籤提示為Array，不過我自己覺得用HashTable的方式處理比較直覺，即然要計算每個數字出現的頻率，Map方式做儲存或許是最簡單的方式，所以藉由Map來統計每個數字出現了多少次，每次當該數字出現時，先從Map拿出該數字出現的次數並+1，接著判斷出現的次數有沒有超過全體數字的一半，有的話就直接回傳該數字不需要繼續做統計，沒有則將該數字出現的次數+1放回Map之中繼續做統計。 程式碼解說:一開始先初始化我們要的Map類型，我把出現的該數字當做key值，value當然就是出現的次數，接著當然就是用for一個個取出數字開始做統計，首先先從Map取出該數字出現的次數，接著+1並判斷是否超過全部數字的一半，有的話就回傳該數字，不過如果Map目前根本就沒有存入那個數字的話呢?沒有的話再放入即可，因為此時取出的值為0，一樣+1再把該數字與出現次數放入Map，並不需要特別再多一步判斷是否存在，而題目有明說必定存在一個高頻率的數字，不過對於不存在的狀況還是要回傳一個值，所以就用0來替代一下 123456789element := make(map[int]int)for _, v := range nums &#123; times, _ := element[v] if times+1 &gt; len(nums)/2 &#123; return v &#125; element[v] = times + 1&#125;return 0 完整程式碼:1234567891011func majorityElement(nums []int) int &#123; element := make(map[int]int) for _, v := range nums &#123; times, _ := element[v] if times+1 &gt; len(nums)/2 &#123; return v &#125; element[v] = times + 1 &#125; return 0&#125; 總結:統計一陣列數字出現的頻率，採用HashMap的方式做儲存或許最直覺且簡單。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"BitManipulation","slug":"BitManipulation","permalink":"https://blog.yunchen.tw/tags/BitManipulation/"},{"name":"DivideAndConquer","slug":"DivideAndConquer","permalink":"https://blog.yunchen.tw/tags/DivideAndConquer/"}]},{"title":"Excel Sheet Column Title","slug":"excel-sheet-column-title","date":"2017-01-09T16:00:00.000Z","updated":"2017-04-05T15:10:16.000Z","comments":true,"path":"2017/01/10/excel-sheet-column-title/","link":"","permalink":"https://blog.yunchen.tw/2017/01/10/excel-sheet-column-title/","excerpt":"","text":"Excel Sheet Column TitleGiven a positive integer, return its corresponding column title as appear in an Excel sheet. For Example:12345671 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB 提示 解題應用 Math 觀查規律 Default:123456789101112131415161718192021222324func convertToTitle(n int) string &#123;&#125;#### 解答思路:這題只要能看出規律就沒什麼大問題了，題目自己定義了1~26為A~Z，但是我不想要也跟著去用Map或Array存這些順序關係，所以就直接將這些數字+64也就是變成了65~90，其實就是ASCII的A~Z，如此一來就能省下不少工夫，當然這是最後才要做的，在那之前首先我們能發現到每一位數其實就是該數字除上26的餘數(因為26個字母一循環)，而如果商數超過26表示結果的字母會更長些，這時就重複上一步的動作，不斷的將商數除以26去取得結果的餘數(字母由後網前排序)，直到商數也小於等於26才大功告成，唯一要注意的是整除的情況，以52來說就是AZ，如果該數字除26後的餘數為0時，這時就直接跟商數借1，因為A~Z為1~26，餘數為0反而不知道要表示哪個字母，也就變成餘數變為26而商數要再-1，這樣就算是整除的狀況也能順利的表示出來了。#### 程式碼解說:最主要就是要判斷目前的數字是否超過26，如同上述所說的要對整除的狀況向商數借1，所以變成是餘數26而商數-1，有了餘數之後便直接+64變成ASCII轉成string就成了我們目標的字母，這邊要注意的是每找出新的字母要往前放，畢竟我們是從最後頭的字母開始算起```govar result stringfor n &gt; 26 &#123; if n%26 != 0 &#123; result = string(n%26+64) + result n = n / 26 &#125; else &#123; result = string(26+64) + result n = n/26 - 1 &#125;&#125;return string(n+64) + result 完整程式碼:12345678910111213func convertToTitle(n int) string &#123; var result string for n &gt; 26 &#123; if n%26 != 0 &#123; result = string(n%26+64) + result n = n / 26 &#125; else &#123; result = string(26+64) + result n = n/26 - 1 &#125; &#125; return string(n+64) + result&#125; 總結:透過題目定義的數字來位移成ASCII，好讓我們省下不少功夫，透過觀查我們可以發現excel每一列的字母規則不過就是數字除以26(A~Z為26個字母)的餘數，如果商數超過26表示字母的長度可以更長，就不斷的將商數除以26取得餘數，直到商數也小於等於26，此外如果有整除的情況發生，以1~26表示為A~Z來說，餘數為0時並無法表示任字母，此時商數要-1而餘數就變為26(Z)。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"Single Number","slug":"single-number","date":"2017-01-08T16:00:00.000Z","updated":"2017-04-05T15:10:06.000Z","comments":true,"path":"2017/01/09/single-number/","link":"","permalink":"https://blog.yunchen.tw/2017/01/09/single-number/","excerpt":"","text":"Single NumberGiven an array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 提示 解題應用 HashTable Hash Map BitManipulation XOR Default:123func singleNumber(nums []int) int &#123;&#125; 解答思路:最初看到發現這題也有一對一的關係存在，因為強調有每一組數字，而我們要找的就是那唯一一個落單的數字，也許可以用stack來處理，或者是Hash Map(如果每組數字都不一樣沒有重覆的話)，不過在註記的部分發現到不但要實現O(1)的複雜度，而且也不能用額外的空間，換句話說不需要用到空間換取時間，有更簡單的方式可以完成，在注意到BitManipulation之後，進而才發現XOR也是一個不錯的方式，XOR原理是將兩數字換成2進位之後，1與1的部分歸0，1與0則保留1，0與0則依舊為0，所以說如果是相同的數字做XOR自然就為0，而0與其它數字做XOR就會保留該數字，如下: 1234A ^ B ^ C ^ B ^ C ^ A ^ N= A ^ A ^ B ^ B ^ C ^ C ^ N= 0 ^ 0 ^ 0 ^ N= N 如此一來就能在不利用額外空間的狀況下達到O(1)的複雜度。 程式碼解說:看起來似乎沒什麼要提的，只是對整個數字陣列一個個取出做XOR(^)，最後剩下的就是目標 12345var result intfor _, v := range nums &#123; result ^= v&#125;return result 完整程式碼:1234567func singleNumber(nums []int) int &#123; var result int for _, v := range nums &#123; result ^= v &#125; return result&#125; 總結:一對一的關係除了可以用stack或Hash Map(如果每組數字都不一樣沒有重覆的話)來處理，如果是要找唯一一個非對應的結果除了可以用上述的方式來篩選到最後剩下來的之外，對所有的資料做XOR也是一個不錯的選擇，尤其是當每筆資料能單單只轉成數字的時候。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"},{"name":"BitManipulation","slug":"BitManipulation","permalink":"https://blog.yunchen.tw/tags/BitManipulation/"}]},{"title":"Min Stack","slug":"min-stack","date":"2017-01-08T16:00:00.000Z","updated":"2017-04-05T15:09:59.000Z","comments":true,"path":"2017/01/09/min-stack/","link":"","permalink":"https://blog.yunchen.tw/2017/01/09/min-stack/","excerpt":"","text":"Min StackDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. For Example:12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2. 提示 解題應用 Stack LinkedList Default:123456789101112131415161718192021222324252627282930313233343536373839type MinStack struct &#123; &#125;/** initialize your data structure here. */func Constructor() MinStack &#123; &#125;func (this *MinStack) Push(x int) &#123; &#125;func (this *MinStack) Pop() &#123; &#125;func (this *MinStack) Top() int &#123; &#125;func (this *MinStack) GetMin() int &#123; &#125;/** * Your MinStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.GetMin(); */ 解答思路:如果前面需要用上stack的部分都是自己實作的話，那麼應該可以很輕易的完成，畢竟只是從頭來接個LinkedList的方式而已，或是用Array來實作，懂得基本概念的話應該很容易。 程式碼解說:如果是像我一樣用LinkedList來實作的話，就需要有節點的實作，所以就先建立一個節點的架構，包含了該節點要儲存的值與下一個節點的位置，因為stack不會有節點往回走的情況，只有新增與刪除才會造成位置移動 1234type Node struct &#123; Val int Next *Node&#125; 因為題目要的話初始化一個stack，雖然用LinkedList來實作的話大部分的東西是放在節點，不過還是需要有一個地方自始自終都儲放stack的第一個節點的位置，以方便在做新增與刪除時有個依循，而建構的function就直接回傳空的MinStack物件 123456type MinStack struct &#123; Header *Node&#125;func Constructor() MinStack &#123; return MinStack&#123;&#125;&#125; 因為stack插入值都是從頭開始放入，所以不需要考量到前一個節點的位置，所以只要將目前頭節點的位置接在新節點位置的後頭即可，也就是在初始化節點的時候連同要新增的值與頭節點的位置塞入就完成了，只是要記得這是頭節點的位置已經是新節點的位置了，所以要把stack的header指向新節點 1234func (this *MinStack) Push(x int) &#123; newNode := &amp;Node&#123;x, this.Header&#125; this.Header = newNode&#125; Pop故名思義就是要將第一個節點給彈出，不過這邊我只要將頭節點的位置指向下一個即可，你也可以再後頭多加一行釋放彈出節點的記憶體空間，換句話說就是砍掉該節點 123func (this *MinStack) Pop() &#123; this.Header = this.Header.Next&#125; Top就直接回傳頭節點所儲存的值即可 123func (this *MinStack) Top() int &#123; return this.Header.Val&#125; 最後要找最小值，因為不曉得stack中間會經過多少次的push與pop，當然也可以每次push與pop都確認一次，不過這邊我還是用一個迴圈將整個stack給遍歷一次以找出最小值，你可以設一個很大的數字或是像我一樣放入一個32位元int的極大值來初始化，方便後續比對尋找最小值的節點 1234567891011func (this *MinStack) GetMin() int &#123; travel := this.Header minVal := math.MaxInt32 for travel != nil &#123; if travel.Val &lt; minVal &#123; minVal = travel.Val &#125; travel = travel.Next &#125; return minVal&#125; 完整程式碼:12345678910111213141516171819202122232425262728293031323334353637type Node struct &#123; Val int Next *Node&#125;type MinStack struct &#123; Header *Node&#125;func Constructor() MinStack &#123; return MinStack&#123;&#125;&#125;func (this *MinStack) Push(x int) &#123; newNode := &amp;Node&#123;x, this.Header&#125; this.Header = newNode&#125;func (this *MinStack) Pop() &#123; this.Header = this.Header.Next&#125;func (this *MinStack) Top() int &#123; return this.Header.Val&#125;func (this *MinStack) GetMin() int &#123; travel := this.Header minVal := math.MaxInt32 for travel != nil &#123; if travel.Val &lt; minVal &#123; minVal = travel.Val &#125; travel = travel.Next &#125; return minVal&#125; 總結:Stack的基本概念是資料從頭來插入，而舊的資料就往後移動，取出資料也是從頭先拿，這時舊的資料則往前移動，總之就是先進後出的概念，也因為操作都是在開頭，所以像是用LinkedList實作時就不需要有個節點在頭的前面來確保操作一致。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Stack","slug":"Stack","permalink":"https://blog.yunchen.tw/tags/Stack/"},{"name":"Design","slug":"Design","permalink":"https://blog.yunchen.tw/tags/Design/"}]},{"title":"Valid Palindrome","slug":"valid-palindrome","date":"2017-01-07T16:00:00.000Z","updated":"2017-04-05T15:09:53.000Z","comments":true,"path":"2017/01/08/valid-palindrome/","link":"","permalink":"https://blog.yunchen.tw/2017/01/08/valid-palindrome/","excerpt":"","text":"Valid PalindromeGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example:12&quot;A man, a plan, a canal: Panama&quot; is a palindrome.&quot;race a car&quot; is not a palindrome. 提示 解題應用 TwoPointers String Default:123func isPalindrome(s string) bool &#123;&#125; 解答思路:(此題思路有修正，建議看完直接拉到最底下參考修正的部分) 這題給你一段字串來要確認是否回文，而且這段字串也會有其它符號存在，不過我想如果曾寫過程式的人一定有摸過ASCII，如此一來只要注意大小寫、數字及ASCII的範圍就可以很輕易的完成。 程式碼解說:一開始先初始兩個字串，一個用來儲存去除掉符號之後的原始字串，另一個則是存放原始字串的相反結果，將給予的字串先全部轉成小寫，方便我們在一個個字元取出時好判斷，畢竟回文也是無視大小寫，至於判斷就利用取出字串的字元在go中會自動轉為rune值(int)，是否介於97~122之間(a~z)或48~57之間(0~9)，然後將一個個字元分別從後頭放入新字串(原始字串)與從前頭放入新字串(相反字串)，最後比對這兩個字串是否相同便等同判斷是否回文 1234567891011121314var origin stringvar reverse strings = strings.ToLower(s)for _, v := range s &#123; if v &gt;= 97 &amp;&amp; v &lt;= 122 || v &gt;= 48 &amp;&amp; v &lt;= 57 &#123; origin = origin + string(v) reverse = string(v) + reverse &#125;&#125;if origin == reverse &#123; return true&#125; else &#123; return false&#125; 完整程式碼:12345678910111213141516func isPalindrome(s string) bool &#123; var origin string var reverse string s = strings.ToLower(s) for _, v := range s &#123; if v &gt;= 97 &amp;&amp; v &lt;= 122 || v &gt;= 48 &amp;&amp; v &lt;= 57 &#123; origin = origin + string(v) reverse = string(v) + reverse &#125; &#125; if origin == reverse &#123; return true &#125; else &#123; return false &#125;&#125; 總結:字串的回文要注意到大小寫、數字及ASCII的範圍，接著只要用兩個字串儲存正、反結果後對比即可。 修正:同時從整個字串的頭與尾遍歷，如果頭尾任一端遇上非英文字母的字元，該端就不斷的往前(或往後)找到英文字母為止，接著才進行比較兩端的字母是否相同，如果整串都只有特殊字元，頭的那端會一口氣遍歷到底，此時就直接回傳true，最後如果頭端的位置大於尾端表示檢查完畢，此時才回傳true 12345678910111213141516171819202122232425262728func isPalindrome(s string) bool &#123; s = strings.ToLower(s) var strFront rune var strRear rune front := 0 rear := len(s) - 1 for front &lt; rear &#123; strFront = rune(s[front]) strRear = rune(s[rear]) for !(strFront &gt;= 97 &amp;&amp; strFront &lt;= 122 || strFront &gt;= 48 &amp;&amp; strFront &lt;= 57) &#123; front++ if front == len(s) &#123; return true &#125; strFront = rune(s[front]) &#125; for !(strRear &gt;= 97 &amp;&amp; strRear &lt;= 122 || strRear &gt;= 48 &amp;&amp; strRear &lt;= 57) &#123; rear-- strRear = rune(s[rear]) &#125; if strFront != strRear &#123; return false &#125; front++ rear-- &#125; return true&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"},{"name":"Modify","slug":"Modify","permalink":"https://blog.yunchen.tw/tags/Modify/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"}]},{"title":"Best Time to Buy and Sell Stock","slug":"best-time-to-buy-and-sell-stock","date":"2017-01-03T16:00:00.000Z","updated":"2017-04-05T15:09:45.000Z","comments":true,"path":"2017/01/04/best-time-to-buy-and-sell-stock/","link":"","permalink":"https://blog.yunchen.tw/2017/01/04/best-time-to-buy-and-sell-stock/","excerpt":"","text":"Best Time to Buy and Sell StockSay you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example1:1234Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example2:1234Input: [7, 6, 4, 3, 1]Output: 0In this case, no transaction is done, i.e. max profit = 0. 提示 解題應用 Array Array/Slice DynamicProgramming 規律觀查 Default:123func maxProfit(prices []int) int &#123;&#125; 解答思路:此題意思是給予一段每日股票票價的陣列，要求你來找出賺取最大差價的利潤，不過在賺錢之前當然要先把股票買好，這樣在最大差價的時候才能把股票給賣掉，意思就是說如果你在第三天才買股票，就算前兩天的賣價不錯，你也沒辦法販賣，因為當下你手上根本就沒有半張股票，就只能找第三天之後的股價來賣，所以這題的目標是要你找出在適當時機購買並販售出去的最大利潤，關鍵在於邊找最大利潤的同時，如果發現有更便宜的股價想要賺買並嘗試尋找利潤時，此時記得將先前找到的最佳出售價格給歸0，畢竟買了才能拿來賣，理所當然出售價格要重新開始找。 程式碼解說:這邊先把空陣列的狀況給過濾掉，以方便我們在一開始就先把第一天的價格初始化買價與賣價，如此一來就能依據第一天的價格來判斷後續價格相對於買與賣究竟是高還是低，所以再來迴圈取出價格時就是從index為1，也就是第二天開始取出，正如先前所說的，如果發現較低的價格能購入時，要記得把先前找到的最佳賣價給歸0以利重新尋找，如果發現的是較高的賣價時，因為先前就已經決定好買價了，所以就不需要客氣直接賣了，不過前提題不做虧本生意，當然賣價要比買價高才行，剩下的就是與先前的價差來比較是否為最大利潤 12345678910111213141516171819if len(prices) == 0 &#123; return 0&#125;var maxProfit intbuyPrice := prices[0]sellPrice := prices[0]for _, v := range prices[1:] &#123; if v &lt; buyPrice &#123; buyPrice = v sellPrice = 0 &#125; if v &gt; sellPrice &#123; sellPrice = v if buyPrice &lt; sellPrice &amp;&amp; sellPrice-buyPrice &gt; maxProfit &#123; maxProfit = sellPrice - buyPrice &#125; &#125;&#125;return maxProfit 完整程式碼:123456789101112131415161718192021func maxProfit(prices []int) int &#123; if len(prices) == 0 &#123; return 0 &#125; var maxProfit int buyPrice := prices[0] sellPrice := prices[0] for _, v := range prices[1:] &#123; if v &lt; buyPrice &#123; buyPrice = v sellPrice = 0 &#125; if v &gt; sellPrice &#123; sellPrice = v if buyPrice &lt; sellPrice &amp;&amp; sellPrice-buyPrice &gt; maxProfit &#123; maxProfit = sellPrice - buyPrice &#125; &#125; &#125; return maxProfit&#125; 總結:給予一段每日股票票價的陣列，要求找出賺取最大差價的利潤，關鍵在於邊找利潤的同時，如果發現有更便宜的股價想要賺買並嘗試尋找最大利潤時，此時記得將先前找到的最佳出售價格給歸0，畢竟買了才能拿來賣，理所當然出售價格要重新開始找。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"https://blog.yunchen.tw/tags/DynamicProgramming/"}]},{"title":"Pascal's Triangle II","slug":"pascal's-triangle-II","date":"2017-01-02T16:00:00.000Z","updated":"2017-04-05T15:09:36.000Z","comments":true,"path":"2017/01/03/pascal's-triangle-II/","link":"","permalink":"https://blog.yunchen.tw/2017/01/03/pascal's-triangle-II/","excerpt":"","text":"Pascal’s Triangle IIGiven an index k, return the kth row of the Pascal’s triangle. For example, given k = 3,Return [1,3,3,1]. Note: Could you optimize your algorithm to use only O(k) extra space? 提示 解題應用 Array Array/Slice Default:123func getRow(rowIndex int) []int &#123;&#125; 解答思路:這題是巴斯卡三角形的進階題，說穿了只是多了一個對儲存空間的要求，這次你只能使用一個陣列，而且長度只能是要求列數的長度，第1列陣列長度就只能1，第2列陣列長度就只能2，題目給的是列的index值，所以要記得長度要+1，基本上就只不過是重覆使用同一個陣列罷了，只是原本巴斯卡三角形某列的中間第n項值為前一列的第n-1項值加上第n項值，在只有一個陣列而重覆使用的狀況下，原本第n項的值會被之後第n-1項值加上第n項值給覆蓋，問題在於求n+1項值需要用上第n項值加上第n+1項值時，因為先前的第n項已經被覆蓋而失去了原本的值，導致後面的項目無法求出正確的值，此時最好的做法就是從列的最後頭開始求值，因為每一列項目數都比前一列長度多出1，所以如果從最後開始算，新的第n項值就會擺到最後一個多出的位置，此時可以避免覆蓋掉需要用到的原始值，就可以放心的往前求出結果。 程式碼解說:大致上與前一題求巴斯卡三角形類似，不過因為這次給的是列的index值而非第幾列，所以空間上要記得多補1，第一個迴圈因為同樣是index值就可以多個”等於”，至於關鍵就在於第二個迴圈上，為了不覆蓋需要用到的原始值所以要從後頭開始擺新的值，而最後頭的index值當然就是該列列數的index值，所以就直接將第一個迴圈的i值直接給第二個迴圈初始化即可，再來就只要從最後頭做到開頭index為0時就完成了 1234567891011result := make([]int, rowIndex+1)for i := 0; i &lt;= rowIndex; i++ &#123; for j := i; j &gt;= 0; j-- &#123; if j == 0 || j == i &#123; result[j] = 1 &#125; else &#123; result[j] = result[j-1] + result[j] &#125; &#125;&#125;return result 完整程式碼:12345678910111213func getRow(rowIndex int) []int &#123; result := make([]int, rowIndex+1) for i := 0; i &lt;= rowIndex; i++ &#123; for j := i; j &gt;= 0; j-- &#123; if j == 0 || j == i &#123; result[j] = 1 &#125; else &#123; result[j] = result[j-1] + result[j] &#125; &#125; &#125; return result&#125; 總結:巴斯卡三角形在只有一個陣列而重覆使用的狀況下，原本第n項的值會被之後第n-1項值加上第n項值給覆蓋，問題在於求n+1項值需要用上第n項值加上第n+1項值時，因為先前的第n項已經被覆蓋而失去了原本的值，導致後面的項目無法求出正確的值，此時最好的做法就是從列的最後頭開始求值，因為每一列項目數都比前一列長度多出1，所以如果從最後開始算，新的第n項值就會擺到最後一個多出的位置，此時可以避免覆蓋掉需要用到的原始值，就可以放心的往前求出結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"}]},{"title":"Pascal's Triangle","slug":"pascal's-triangle","date":"2017-01-01T16:00:00.000Z","updated":"2017-04-05T15:09:26.000Z","comments":true,"path":"2017/01/02/pascal's-triangle/","link":"","permalink":"https://blog.yunchen.tw/2017/01/02/pascal's-triangle/","excerpt":"","text":"Pascal’s TriangleGiven numRows, generate the first numRows of Pascal’s triangle. For example:Given numRows = 5, Return 1234567[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 提示 解題應用 Array Array/Slice Default:123func generate(numRows int) [][]int &#123;&#125; 解答思路:只要了解巴斯卡三角形規律是如何，應該都可以輕易的完成本題，以每一列來說就是頭與尾皆為1，而中間n的值就是前一列n-1的值與n的值相加，知道規則之後，如此一來應該不需要多大的功夫就可以解出來了。 程式碼解說:首先先初始化一個二階陣列，之後第一個迴圈就是開始執行需要的巴斯卡三角形共要幾列，這邊我從0來開始計算以方便我們在二元陣列時能直接用index值來指定該列的陣列，因為最初僅初始化二階陣列，然而實際上二階陣列裡並沒有任何一個陣列，所以在確定需要的巴斯卡三角形列數之後，就接著在裡頭新增相同數目的陣列，之後第二個迴圈就是執行該列的陣列中有多少個值，列如第一列就只有1個，第二列有2個…以此類推，一樣也是從0開始方便直接在陣列用index值指定哪一項的值，前置工作都完成後再來就只要判斷如果是該列的頭與尾也就是index值的0與目前在巴斯卡三角形的第幾列再減1，此時就將1新增至該列的陣列之中，至於中間的n值正如先前所說，不過就是前一列n-1的值與n的值相加，一樣也插入該列的陣列後就完成了 123456789101112result := make([][]int, 0)for i := 0; i &lt; numRows; i++ &#123; result = append(result, make([]int, 0)) for j := 0; j &lt;= i; j++ &#123; if j == 0 || j == i &#123; result[i] = append(result[i], 1) &#125; else &#123; result[i] = append(result[i], result[i-1][j-1]+result[i-1][j]) &#125; &#125;&#125;return result 完整程式碼:1234567891011121314func generate(numRows int) [][]int &#123; result := make([][]int, 0) for i := 0; i &lt; numRows; i++ &#123; result = append(result, make([]int, 0)) for j := 0; j &lt;= i; j++ &#123; if j == 0 || j == i &#123; result[i] = append(result[i], 1) &#125; else &#123; result[i] = append(result[i], result[i-1][j-1]+result[i-1][j]) &#125; &#125; &#125; return result&#125; 總結:巴斯卡三角形的規律以每列來說就是頭與尾皆為1，而中間n的值就是前一列n-1的值與n的值相加。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"}]},{"title":"Path Sum","slug":"path-sum","date":"2016-12-31T16:00:00.000Z","updated":"2017-04-05T15:09:18.000Z","comments":true,"path":"2017/01/01/path-sum/","link":"","permalink":"https://blog.yunchen.tw/2017/01/01/path-sum/","excerpt":"","text":"Path SumGiven a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. For example:Given the below binary tree and sum = 22, 1234567 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\7 2 1 return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 提示 解題應用 Tree 樹的遍歷方式 DepthFirstSearch PostOrderTravel Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func hasPathSum(root *TreeNode, sum int) bool &#123;&#125; 解答思路:(此題思路有修正，建議看完直接拉到最底下參考修正的部分) 與尋找二元樹的最小深度一樣，要注意的是一定要從存在的樹根到樹末(樹葉)來尋找，所以會發生只到中間的節點符合條件，反而往其子節點走就不符合條件，對於那些nil節點一樣要做些處理以免誤判，nil節點我回傳了一個32位元int的極大值，如果其一節點的兩個左右子節點都回傳極大值，如此一來便知道已經到達了樹葉節點，此時在判斷節點總合是否符合目標值，其餘的節點若有任一左右子節點就繼續遞回做後序遍歷，而不符合目標值的路徑則回傳一個極小值，與符合條件的任一值以此區分空節點、不符合的路徑、符合的路徑。 程式碼解說:這邊一開始先判斷節點是否存在，不存在就回傳一個極大值，接著便分左右子節點來做遞回，而至於是否於目標值相符，這邊我將目標值與路徑上的節點做相減，當結果為0且回傳的左右子節點皆為極大值，表示存在著符合條件的路徑以回傳0來表示，不過因為在向上回傳的過程中，節點會碰上像是左子樹的路徑符合，而另一右子樹則無，此時只要其一路徑符合就繼續向上回傳0，最後不符合的路徑就回傳極小值來區別 12345678910111213var sumL intvar sumR intif node == nil &#123; return math.MaxInt32&#125;sumL = postOrderTravel(node.Left, sum-node.Val)sumR = postOrderTravel(node.Right, sum-node.Val)if sum-node.Val == 0 &amp;&amp; sumL == math.MaxInt32 &amp;&amp; sumR == math.MaxInt32 &#123; return 0&#125; else if sumL == 0 || sumR == 0 &#123; return 0&#125;return math.MinInt32 完整程式碼:12345678910111213141516171819202122func hasPathSum(root *TreeNode, sum int) bool &#123; result := postOrderTravel(root, sum) if result == 0 &#123; return true &#125; return false&#125;func postOrderTravel(node *TreeNode, sum int) int &#123; var sumL int var sumR int if node == nil &#123; return math.MaxInt32 &#125; sumL = postOrderTravel(node.Left, sum-node.Val) sumR = postOrderTravel(node.Right, sum-node.Val) if sum-node.Val == 0 &amp;&amp; sumL == math.MaxInt32 &amp;&amp; sumR == math.MaxInt32 &#123; return 0 &#125; else if sumL == 0 || sumR == 0 &#123; return 0 &#125; return math.MinInt32&#125; 總結:在二元樹中尋找特定的路徑(從樹根到樹葉)，像是二元樹的最短路徑與節點總合，都是一定要是從根到葉的完整路徑，就算僅到中間的節點便符合條件，只要該節點仍有任一子節點就一定要往下走，很容易因為這樣而將原本不符合條件的結果回傳成符合條件的結果。 二元樹路徑上的節點值總合是否存在符合目標值，首先要注意nil節點回傳極大值以避免上述情況，當左右子節點回傳皆為極大值時，便能知道已經到達樹葉節點，此時在判斷總合是否相符，而對於最終總合不符的樹節點，再往上回傳極小值，以此來區分: 不符合條件的路徑(極小值) 空節點(極大值) 符合條件的路徑(任一值) 修正主要是不需要用極大值、極小值的方式判斷路徑，直接從節點判斷左右子節點是否存在，再考慮需不需要遍歷該子節點，如此一來就可以省去非常多的麻煩，大多數關於樹的遍歷都可以用此方式處理。 12345678910111213141516171819func hasPathSum(root *TreeNode, sum int) bool &#123; if root == nil &#123; return false &#125; return preOrderTravel(root, sum)&#125;func preOrderTravel(node *TreeNode, sum int) bool &#123; if node.Left == nil &amp;&amp; node.Right == nil &#123; if sum-node.Val == 0 &#123; return true &#125; return false &#125; else if node.Left == nil &#123; return preOrderTravel(node.Right, sum-node.Val) &#125; else if node.Right == nil &#123; return preOrderTravel(node.Left, sum-node.Val) &#125; return preOrderTravel(node.Left, sum-node.Val) || preOrderTravel(node.Right, sum-node.Val)&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Modify","slug":"Modify","permalink":"https://blog.yunchen.tw/tags/Modify/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"},{"name":"DepthFirstSearch","slug":"DepthFirstSearch","permalink":"https://blog.yunchen.tw/tags/DepthFirstSearch/"}]},{"title":"Minimum Depth of Binary Tree","slug":"minimum-depth-of-binary-tree","date":"2016-12-26T16:00:00.000Z","updated":"2017-04-05T15:09:09.000Z","comments":true,"path":"2016/12/27/minimum-depth-of-binary-tree/","link":"","permalink":"https://blog.yunchen.tw/2016/12/27/minimum-depth-of-binary-tree/","excerpt":"","text":"Minimum Depth of Binary TreeGiven a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. 提示 解題應用 Tree 樹的遍歷方式 DepthFirstSearch PostOrderTravel Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func minDepth(root *TreeNode) int &#123;&#125; 解答思路:一般來說題目所給的通常是要你找出二元樹的最大深度，不過此題卻你要找的是最小深度，而最小深度要注意的是如果是從最大深度來做修改，那麼對於左右子節點若其一為nil，並不表示這就是最小深度，因為最小深度要找的是從存在的樹根中尋找最短的，所以在做遞回後序遍歷時，原本碰上nil節點回傳該節點的深度-1改為一個32位元int的最大值，如此一來就可以直接拿來做比較，也不會受到nil節點的影響了(因為一定不是最小)。 程式碼解說:(此題思路有修正，建議看完直接拉到最底下參考修正的部分) 除了在最一開始root根節點為nil時要回傳0之外，其餘的nil值一律回傳最大值方便後續比較，而存在節點的左右子節點就一樣分別做遞回，如果其中一個子樹最小深度不是最大值(該子樹存在)，就只要直接與另一個子樹做比較，就算比較的子樹不存在也會因為回傳的值是極大值而傳回原本比較小且存在的子樹深度，而如果是兩個子樹都存在的情況也不需要再加判斷式，因為原本就是在做最小值的比較，而最後如果兩左右子節點都不存在，才回傳該節點的深度。 12345678910111213var maxRowL intvar maxRowR intif node == nil &#123; return math.MaxInt32&#125;maxRowL = postOrderTravel(node.Left, maxRow+1)maxRowR = postOrderTravel(node.Right, maxRow+1)if maxRowL != math.MaxInt32 &amp;&amp; maxRowL &lt;= maxRowR &#123; return maxRowL&#125; else if maxRowR != math.MaxInt32 &amp;&amp; maxRowR &lt;= maxRowL &#123; return maxRowR&#125;return maxRow 完整程式碼:123456789101112131415161718192021func postOrderTravel(node *TreeNode, maxRow int) int &#123; var maxRowL int var maxRowR int if node == nil &#123; return math.MaxInt32 &#125; maxRowL = postOrderTravel(node.Left, maxRow+1) maxRowR = postOrderTravel(node.Right, maxRow+1) if maxRowL != math.MaxInt32 &amp;&amp; maxRowL &lt;= maxRowR &#123; return maxRowL &#125; else if maxRowR != math.MaxInt32 &amp;&amp; maxRowR &lt;= maxRowL &#123; return maxRowR &#125; return maxRow&#125;func minDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; return postOrderTravel(root, 1)&#125; 總結:在找二元樹的最小深度時，如果是從最大深度來做修改，注意若其一子節點為nil，並不表示其為最小深度，因為最小深度要找的是從存在樹根中尋找最短的，所以在做遞回後序遍歷時，原本碰上nil節點回傳該節點的深度-1改為一個32位元int的最大值，如此一來就會回傳比較小且存在的另一個子樹最小深度。 修正:主要是不需要用極大值、極小值的方式判斷路徑，直接從節點判斷左右子節點是否存在，再考慮需不需要遍歷該子節點，如此一來就可以省去非常多的麻煩，大多數關於樹的遍歷都可以用此方式處理。 123456789101112131415161718192021func minDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; return preOrderTravel(root, 0)&#125;func preOrderTravel(node *TreeNode, maxRow int) int &#123; if node.Left == nil &amp;&amp; node.Right == nil &#123; return maxRow + 1 &#125; else if node.Left == nil &#123; return preOrderTravel(node.Right, maxRow+1) &#125; else if node.Right == nil &#123; return preOrderTravel(node.Left, maxRow+1) &#125; maxRowL := preOrderTravel(node.Left, maxRow+1) maxRowR := preOrderTravel(node.Right, maxRow+1) if maxRowL &lt; maxRowR &#123; return maxRowL &#125; return maxRowR&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Modify","slug":"Modify","permalink":"https://blog.yunchen.tw/tags/Modify/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"},{"name":"DepthFirstSearch","slug":"DepthFirstSearch","permalink":"https://blog.yunchen.tw/tags/DepthFirstSearch/"},{"name":"BreadthFirstSearch","slug":"BreadthFirstSearch","permalink":"https://blog.yunchen.tw/tags/BreadthFirstSearch/"}]},{"title":"Balanced Binary Tree","slug":"balanced-binary-tree","date":"2016-12-25T16:00:00.000Z","updated":"2017-04-05T15:09:01.000Z","comments":true,"path":"2016/12/26/balanced-binary-tree/","link":"","permalink":"https://blog.yunchen.tw/2016/12/26/balanced-binary-tree/","excerpt":"","text":"Balanced Binary TreeGiven a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 提示 解題應用 Tree 樹的遍歷方式 DepthFirstSearch PostOrderTravel Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func isBalanced(root *TreeNode) bool &#123;&#125; 解答思路:這題單純的只是要判斷樹是否平衡而已，所幸不是要做複雜的樹平衡AVL，而既然要判斷是否平衡就需要知道左右子節點的最大深度，理所當然就先將判斷樹最大深度的部分寫出來，接著利用在判斷該節點的最大深度時必會先拿到左右子節點最大深度的特性，藉此將左右子節點最大深度做相減來判斷是否平衡，如果確定平衡才將該節點的最大深度向上回傳繼續做比較。 程式碼解說:基本上與樹最大深度判斷所做的遞回後序遍歷非常相似，只是多了需要判斷平衡的部分，而在一開始如果節點為nil或已經到了樹的末端就回傳最大深度-1(因為該節點不存在)，既然是空節點就肯定沒有平衡問題就回傳true，而節點不為nil就繼續分成左右兩子節點做遞回，當左右子節點的值回來時，先判斷左右子樹是否已經平衡，接著才將左右子樹的最大深度相減是否超過1以此判斷該樹是否平衡，這邊要注意的是因為不曉得左右子樹誰的深度比較大，所以相減有負的情況也要考量進去。 12345678910111213141516var maxRowL intvar maxRowR intif node == nil &#123; return maxRow - 1, true&#125;maxRowL, balanceL := postOrderTravel(node.Left, maxRow+1)maxRowR, balanceR := postOrderTravel(node.Right, maxRow+1)if balanceL &amp;&amp; balanceR &#123; if maxRowL-maxRowR &gt;= 0 &amp;&amp; maxRowL-maxRowR &lt;= 1 &#123; return maxRowL, true &#125; else if maxRowR-maxRowL &gt;= 0 &amp;&amp; maxRowR-maxRowL &lt;= 1 &#123; return maxRowR, true &#125; return 0, false&#125;return 0, false 完整程式碼:12345678910111213141516171819202122func isBalanced(root *TreeNode) bool &#123; _, balance := postOrderTravel(root, 1) return balance&#125;func postOrderTravel(node *TreeNode, maxRow int) (int, bool) &#123; var maxRowL int var maxRowR int if node == nil &#123; return maxRow - 1, true &#125; maxRowL, balanceL := postOrderTravel(node.Left, maxRow+1) maxRowR, balanceR := postOrderTravel(node.Right, maxRow+1) if balanceL &amp;&amp; balanceR &#123; if maxRowL-maxRowR &gt;= 0 &amp;&amp; maxRowL-maxRowR &lt;= 1 &#123; return maxRowL, true &#125; else if maxRowR-maxRowL &gt;= 0 &amp;&amp; maxRowR-maxRowL &lt;= 1 &#123; return maxRowR, true &#125; return 0, false &#125; return 0, false&#125; 總結:判斷二元樹是否平衡時，不妨先將二元樹的最大深度給寫出來，利用計算最大深度會算出左右子樹的最大深度特性，將其稍作修改便能得知樹是否平衡。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"},{"name":"DepthFirstSearch","slug":"DepthFirstSearch","permalink":"https://blog.yunchen.tw/tags/DepthFirstSearch/"}]},{"title":"Binary Tree Level Order Traversal II","slug":"binary-tree-level-order-traversal-II","date":"2016-12-14T16:00:00.000Z","updated":"2017-04-05T15:08:51.000Z","comments":true,"path":"2016/12/15/binary-tree-level-order-traversal-II/","link":"","permalink":"https://blog.yunchen.tw/2016/12/15/binary-tree-level-order-traversal-II/","excerpt":"","text":"Binary Tree Level Order Traversal IIGiven a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 return its bottom-up level order traversal as: 12345[ [15,7], [9,20], [3]] 提示 解題應用 Tree 樹的遍歷方式 BreadthFirstSearch Quene Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func levelOrderBottom(root *TreeNode) [][]int &#123;&#125; 解答思路:此題和先前文章的Binary Tree Level Order Traversal思路太過類似所以內容就大部分照貼，雖然你可以直接拿該題程式照貼，不過最後還會要多一步將結果反轉，與其這樣倒不如一開始就將每一列陣列往開頭插入，而且修改的部分也只有一點點。 很明顯的是要使用廣度優先遍歷的方式來遍歷整棵二元樹，雖然不一定是完全二元樹，不過既然最後一列要在最前頭，這意味著每次二元樹的每一列要將新的陣列差插入結果時，一定是在最前面，也就是index為0的位置，這讓我們省去了找哪個節點是在哪一列的問題，因為一定是往index為0的陣列放，不過列的位數還是要存著，因為仍不曉得什麼時候要將值插入index為0的陣列或是要在原本index為0的位置放入新陣列。 程式碼解說:這邊我是用LinkedList的方式來實現隊列，當然也可以用陣列的方式來實現，作法因人而異 12345type QueneNode struct &#123; Row int Node *TreeNode Next *QueneNode&#125; 將根節點放入隊列中，同時也將列的位數也儲存起來，這邊從0開始做第n列的起頭，方便我們知道什麼時候該再往index為0的位置放入新陣列 12345678910var row intvar tmp *QueneNodevar front *QueneNodevar rear *QueneNodetmp = &amp;QueneNode&#123;&#125;tmp.Node = roottmp.Row = rowfront = tmprear = tmp 在開頭依舊是利用結果的長度(有幾個陣列)來與節點的列數做比較，如果節點已經到下一列了而陣列數量還沒準備給下一列的值塞入，這時就需要產生一個新的陣列包含該節點的值在最前面，然後在把原本的結果依序從其後頭插入，至於那些不是每一列第一個的節點，只管往index為0的陣列塞就對了，因為每一列新插入的值一定都在最前面的陣列，而最後只要判斷節點左右的子節點存不存在依序插入隊列就完成了 1234567891011121314151617181920212223for front != nil &#123; if len(result) &lt; front.Row+1 &#123; result = append([][]int&#123;[]int&#123;front.Node.Val&#125;&#125;, result...) &#125; else &#123; result[0] = append(result[0], front.Node.Val) &#125; if front.Node.Left != nil &#123; tmp = &amp;QueneNode&#123;&#125; tmp.Node = front.Node.Left tmp.Row = front.Row + 1 rear.Next = tmp rear = tmp &#125; if front.Node.Right != nil &#123; tmp = &amp;QueneNode&#123;&#125; tmp.Node = front.Node.Right tmp.Row = front.Row + 1 rear.Next = tmp rear = tmp &#125; front = front.Next&#125;return result 完整程式碼:12345678910111213141516171819202122232425262728293031323334353637383940414243type QueneNode struct &#123; Row int Node *TreeNode Next *QueneNode&#125;func levelOrderBottom(root *TreeNode) [][]int &#123; var result [][]int if root == nil &#123; return result &#125; var row int var tmp *QueneNode var front *QueneNode var rear *QueneNode tmp = &amp;QueneNode&#123;&#125; tmp.Node = root tmp.Row = row front = tmp rear = tmp for front != nil &#123; if len(result) &lt; front.Row+1 &#123; result = append([][]int&#123;[]int&#123;front.Node.Val&#125;&#125;, result...) &#125; else &#123; result[0] = append(result[0], front.Node.Val) &#125; if front.Node.Left != nil &#123; tmp = &amp;QueneNode&#123;&#125; tmp.Node = front.Node.Left tmp.Row = front.Row + 1 rear.Next = tmp rear = tmp &#125; if front.Node.Right != nil &#123; tmp = &amp;QueneNode&#123;&#125; tmp.Node = front.Node.Right tmp.Row = front.Row + 1 rear.Next = tmp rear = tmp &#125; front = front.Next &#125; return result&#125; 總結:碰上二元樹要做廣度優先遍歷，然後結果卻要相反的儲存，不妨先將依序做儲存的結果給實作出來，如此一來便能很輕易的修改成相反儲存的結果。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"},{"name":"BreadthFirstSearch","slug":"BreadthFirstSearch","permalink":"https://blog.yunchen.tw/tags/BreadthFirstSearch/"}]},{"title":"Maximum Depth of Binary Tree","slug":"maximum-depth-of-binary-tree","date":"2016-12-13T16:00:00.000Z","updated":"2017-04-05T15:08:43.000Z","comments":true,"path":"2016/12/14/maximum-depth-of-binary-tree/","link":"","permalink":"https://blog.yunchen.tw/2016/12/14/maximum-depth-of-binary-tree/","excerpt":"","text":"Maximum Depth of Binary TreeGiven a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 提示 解題應用 Tree 樹的遍歷方式 DepthFirstSearch 後序遍歷 Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func maxDepth(root *TreeNode) int &#123;&#125; 解答思路:(此題思路有修正，建議看完直接拉到最底下參考修正的部分) 決定一棵樹的深度，用深度優先遍歷是最好不過了，而就一節點來說其子節點有分左子節點與右子節點，要知道該節點的最大深度就必需要先比較左右兩子節點的深度，換句話說就是要等到左右節點都深度遍歷完了才有辦法做判斷，所以我們就要用後序遍歷來實作深度優先遍歷，當然用遞回的方式來做便再簡單不過了。 程式碼解說:接下來就是用遞回的方式做處理，在一開始因為進來的節點有可能是nil該層的深度就不算數，所以需要回傳的是最大深度再-1，而如果節點存在當然就是繼續去做遞回，而因為要等左右節點的最大深度回來才能做比較，此為後序遍歷的方式判斷式都要在後頭 12345678910111213if node == nil &#123; return maxRow - 1&#125;var maxRowL intvar maxRowR intmaxRowL = postOrderTravel(node.Left, maxRow+1)maxRowR = postOrderTravel(node.Right, maxRow+1)if maxRowL &gt;= maxRow &amp;&amp; maxRowL &gt;= maxRowR &#123; return maxRowL&#125; else if maxRowR &gt;= maxRow &amp;&amp; maxRowR &gt;= maxRowL &#123; return maxRowR&#125;return maxRow 完整程式碼:123456789101112131415161718func postOrderTravel(node *TreeNode, maxRow int) int &#123; if node == nil &#123; return maxRow - 1 &#125; var maxRowL int var maxRowR int maxRowL = postOrderTravel(node.Left, maxRow+1) maxRowR = postOrderTravel(node.Right, maxRow+1) if maxRowL &gt;= maxRow &amp;&amp; maxRowL &gt;= maxRowR &#123; return maxRowL &#125; else if maxRowR &gt;= maxRow &amp;&amp; maxRowR &gt;= maxRowL &#123; return maxRowR &#125; return maxRow&#125;func maxDepth(root *TreeNode) int &#123; return postOrderTravel(root, 1)&#125; 總結:決定一棵樹的深度就用深度優先遍歷的方式，而因為需先比較左、右兩節點的深度才有辦法往上回傳最大深度，因此就要用後序遍序來實作深度優先遍歷。 修正:主要是不需要用極大值、極小值的方式判斷路徑，直接從節點判斷左右子節點是否存在，再考慮需不需要遍歷該子節點，如此一來就可以省去非常多的麻煩，大多數關於樹的遍歷都可以用此方式處理。 123456789101112131415161718192021func maxDepth(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; return preOrderTravel(root, 0)&#125;func preOrderTravel(node *TreeNode, maxRow int) int &#123; if node.Left == nil &amp;&amp; node.Right == nil &#123; return maxRow + 1 &#125; else if node.Left == nil &#123; return preOrderTravel(node.Right, maxRow+1) &#125; else if node.Right == nil &#123; return preOrderTravel(node.Left, maxRow+1) &#125; maxRowL := preOrderTravel(node.Left, maxRow+1) maxRowR := preOrderTravel(node.Right, maxRow+1) if maxRowL &gt; maxRowR &#123; return maxRowL &#125; return maxRowR&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Modify","slug":"Modify","permalink":"https://blog.yunchen.tw/tags/Modify/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"},{"name":"DepthFirstSearch","slug":"DepthFirstSearch","permalink":"https://blog.yunchen.tw/tags/DepthFirstSearch/"}]},{"title":"Binary Tree Level Order Traversal","slug":"binary-tree-level-order-traversal","date":"2016-12-12T16:00:00.000Z","updated":"2017-04-05T15:08:35.000Z","comments":true,"path":"2016/12/13/binary-tree-level-order-traversal/","link":"","permalink":"https://blog.yunchen.tw/2016/12/13/binary-tree-level-order-traversal/","excerpt":"","text":"Binary Tree Level Order TraversalGiven a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] 提示 解題應用 Tree 樹的遍歷方式 BreadthFirstSearch Quene Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func levelOrder(root *TreeNode) [][]int &#123;&#125; 解答思路:很明顯的是要使用廣度優先遍歷的方式來遍歷整棵二元樹，只是因為不一定是完全二元樹，所以不能用計算的方式來記錄要存到第幾個陣列，那麼就只好將該列的位數與節點一起儲存，並且當其左右子節點要進入隊列時將列的位數+1就可以了，如此以來在取出的時候就可以知道要存入哪個陣列(其實就是結果的最後一個陣列)。 程式碼解說:這邊我是用LinkedList的方式來實現隊列，當然也可以用陣列的方式來實現，作法因人而異 12345type QueneNode struct &#123; Row int Node *TreeNode Next *QueneNode&#125; 將根節點放入隊列中，同時也將列的位數也儲存起來，這邊從0開始做第n列的起頭，方便我們等等在存入index值時就可以直接使用 12345678910var row intvar tmp *QueneNodevar front *QueneNodevar rear *QueneNodetmp = &amp;QueneNode&#123;&#125;tmp.Node = roottmp.Row = rowfront = tmprear = tmp 因為在遍歷的過程中如果已經有該列的陣列，那麼直接將數字插入即可，但如果沒有也就是說是該列的第一個，這時就需要初始化一個新的slice，這邊我是直接將一個新的陣列連同值一起做插入，而最後只要判斷左右的子節點存不存在依序插入隊列就完成了 123456789101112131415161718192021222324for front != nil &#123; if len(result) &lt; front.Row+1 &#123; result = append(result, []int&#123;front.Node.Val&#125;) &#125; else &#123; result[front.Row] = append(result[front.Row], front.Node.Val) //result[len(result)-1] = append(result[len(result)-1], front.Node.Val) &#125; if front.Node.Left != nil &#123; tmp = &amp;QueneNode&#123;&#125; tmp.Node = front.Node.Left tmp.Row = front.Row + 1 rear.Next = tmp rear = tmp &#125; if front.Node.Right != nil &#123; tmp = &amp;QueneNode&#123;&#125; tmp.Node = front.Node.Right tmp.Row = front.Row + 1 rear.Next = tmp rear = tmp &#125; front = front.Next&#125;return result 完整程式碼:1234567891011121314151617181920212223242526272829303132333435363738394041424344type QueneNode struct &#123; Row int Node *TreeNode Next *QueneNode&#125;func levelOrder(root *TreeNode) [][]int &#123; var result [][]int if root == nil &#123; return result &#125; var row int var tmp *QueneNode var front *QueneNode var rear *QueneNode tmp = &amp;QueneNode&#123;&#125; tmp.Node = root tmp.Row = row front = tmp rear = tmp for front != nil &#123; if len(result) &lt; front.Row+1 &#123; result = append(result, []int&#123;front.Node.Val&#125;) &#125; else &#123; result[front.Row] = append(result[front.Row], front.Node.Val) //result[len(result)-1] = append(result[len(result)-1], front.Node.Val) &#125; if front.Node.Left != nil &#123; tmp = &amp;QueneNode&#123;&#125; tmp.Node = front.Node.Left tmp.Row = front.Row + 1 rear.Next = tmp rear = tmp &#125; if front.Node.Right != nil &#123; tmp = &amp;QueneNode&#123;&#125; tmp.Node = front.Node.Right tmp.Row = front.Row + 1 rear.Next = tmp rear = tmp &#125; front = front.Next &#125; return result&#125; 總結:如果要記錄二元樹遍歷的每列橫排數字，那除了要用廣度優先遍歷來做之外，也別忘記一併記下每一個節點是在哪一列的位置，如此一來其子節點只要在放入隊列前依尋這個父節點的列位置+1，在取出時就可以知道該節點是第幾列了。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"},{"name":"BreadthFirstSearch","slug":"BreadthFirstSearch","permalink":"https://blog.yunchen.tw/tags/BreadthFirstSearch/"}]},{"title":"Symmetric Tree","slug":"symmetric-tree","date":"2016-12-11T16:00:00.000Z","updated":"2017-04-05T15:08:27.000Z","comments":true,"path":"2016/12/12/symmetric-tree/","link":"","permalink":"https://blog.yunchen.tw/2016/12/12/symmetric-tree/","excerpt":"","text":"Symmetric TreeGiven a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 12345 1 / \\ 2 2 / \\ / \\3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 12345 1 / \\2 2 \\ \\ 3 3 Note: Bonus points if you could solve it both recursively and iteratively. 提示 解題應用 Tree 樹的遍歷方式 BreadthFirstSearch Quene Default:1234567891011/** * Definition for a binary tree node. * type TreeNode struct &#123; * Val int * Left *TreeNode * Right *TreeNode * &#125; */func isSymmetric(root *TreeNode) bool &#123;&#125; 解答思路:這題需要判斷是不是一棵對稱樹，想必馬上就知道要樹的每一橫排來分別比對，進一步了解到要用廣度優先遍歷的方式來做，而對稱樹不一定是完全二元樹，所以意味著下述情況也是對稱: 12345 1 / \\2 2 \\ / 3 3 這表示要考慮到不存在節點的位置是否也對稱，而在最初的想法中我利用做假點的方式，也就是遇上值為nil的情況就自己加了一個值為int32位元的最小值，可是這會碰到一個問題，在最後樹末點時值也是nil，就算你寫若其節點為nil值就不再新增左、右兩個假節點，這樣頂多就是再檢查一排nil的值，但是如果又碰上了極端的情況: 1234567 1 / \\ 2 2 / \\ 3 3 / \\4 4 這會使得自己陷入了兩難，所以可見得做假點的方式行不通，那麼要有其它的方式來判斷對稱，就是將整個樹再複製一份，一棵樹一律先往左邊跑，另一棵則是一律先往右邊，如此一來只要知道這左右兩邊節點的值是否相同就可以很輕易的知道是否對稱，當p節點往左就看q節點往右的值，而p節點換往右就看q節點往左的值，這也少了很多如果是做假點的話會碰上的麻煩，像是還需要二個陣列以中央為準，其一為左側廣度遍歷依序放入，而過了中央後廣度遍歷放入另一則要反著放，最後還要再判斷兩陣列是否相同簡直耗費太多時間，而用stack來存每列也行不通，stack為判斷一對一的對應關係而非對稱，就像是括號相對的關係 {()[]{}[()]} 這也不是對稱，同理此題也是如此，最後如果沒有上述錯誤的思考方向，那麼接下來的只要再用隊列來做廣度優先遍歷就可以解決了。 程式碼解說:這邊我是用LinkedList的方式來實現隊列，當然也可以用陣列的方式來實現，作法因人而異 1234type QueneNode struct &#123; Node *TreeNode Next *QueneNode&#125; 如果根節點為nil就直接丟回true，若有存在就繼續往下走，這邊我們因為要複製為兩棵樹，說穿了就是同時遍歷這棵樹兩次罷了，所以我們就連續將兩個根節點放入隊列之中，然後用front標定隊列的起始點以利判定隊列是否還有節點，而rear則是隊列的尾巴方便找到下一次插入點，這邊只用上一個隊列來儲存，當然也可以一樣用兩個隊列來分別取出比較，只是如果是一個隊列的話，在儲存方面每次就要分別塞兩個節點，同樣的在比較的時候就要一次取出兩個節點 1234567891011121314151617if root == nil &#123; return true&#125;var tmp *QueneNodevar front *QueneNodevar rear *QueneNodetmp = &amp;QueneNode&#123;&#125;tmp.Node = rootfront = tmprear = tmptmp = &amp;QueneNode&#123;&#125;tmp.Node = rootrear.Next = tmprear = tmp p與q就是每次從隊列中取出兩個點來比較，如果節點都是nil表示左右對稱就繼續檢查下一組，記得要繼續之前要先把front移到下一組節點的開頭，否則會因為兩節點值不變而進入死回圈。接著只要其中一組為nil另一組不是，就意味著不對稱便直接回傳false，最後檢查這兩個節點的值是否相同，然後才接著依續去塞入其子節點，這邊要注意的是在塞入時的順序，因為每次都是取出p、q兩點來檢查是否相同，那我們為了要知道是否對稱，所以在子節點要放入隊列時就要以p的左子節點與q的右子節點為一組，再來是p的右子節點與q的左子節點為一組，如此一來在從隊列取出的時候就只要檢查其值兩兩是否相同就好，不用在考慮現在的節點是左邊還右邊或者對不對稱的問題 123456789101112131415161718192021222324252627282930313233343536var p *QueneNodevar q *QueneNodefor front != nil &#123; p = front q = front.Next if p.Node == nil &amp;&amp; q.Node == nil &#123; front = front.Next.Next continue &#125; else if p.Node == nil || q.Node == nil &#123; return false &#125; else if p.Node.Val != q.Node.Val &#123; return false &#125; tmp = &amp;QueneNode&#123;&#125; tmp.Node = p.Node.Left rear.Next = tmp rear = tmp tmp = &amp;QueneNode&#123;&#125; tmp.Node = q.Node.Right rear.Next = tmp rear = tmp tmp = &amp;QueneNode&#123;&#125; tmp.Node = p.Node.Right rear.Next = tmp rear = tmp tmp = &amp;QueneNode&#123;&#125; tmp.Node = q.Node.Left rear.Next = tmp rear = tmp front = front.Next.Next&#125;return true 完整程式碼:Iteratively: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253type QueneNode struct &#123; Node *TreeNode Next *QueneNode&#125;func isSymmetric(root *TreeNode) bool &#123; if root == nil &#123; return true &#125; var tmp *QueneNode var p *QueneNode var q *QueneNode var front *QueneNode var rear *QueneNode tmp = &amp;QueneNode&#123;&#125; tmp.Node = root front = tmp rear = tmp tmp = &amp;QueneNode&#123;&#125; tmp.Node = root rear.Next = tmp rear = tmp for front != nil &#123; p = front q = front.Next if p.Node == nil &amp;&amp; q.Node == nil &#123; front = front.Next.Next continue &#125; else if p.Node == nil || q.Node == nil &#123; return false &#125; else if p.Node.Val != q.Node.Val &#123; return false &#125; tmp = &amp;QueneNode&#123;&#125; tmp.Node = p.Node.Left rear.Next = tmp rear = tmp tmp = &amp;QueneNode&#123;&#125; tmp.Node = q.Node.Right rear.Next = tmp rear = tmp tmp = &amp;QueneNode&#123;&#125; tmp.Node = p.Node.Right rear.Next = tmp rear = tmp tmp = &amp;QueneNode&#123;&#125; tmp.Node = q.Node.Left rear.Next = tmp rear = tmp front = front.Next.Next &#125; return true&#125; Recursively: 12345678910111213func isSymmetric(root *TreeNode) bool &#123; return preOrderTravel(root, root)&#125;func preOrderTravel(p *TreeNode, q *TreeNode) bool &#123; if p == nil &amp;&amp; q == nil &#123; return true &#125; else if p == nil || q == nil &#123; return false &#125; else if p.Val != q.Val &#123; return false &#125; return true &amp;&amp; preOrderTravel(p.Left, q.Right) &amp;&amp; preOrderTravel(p.Right, q.Left)&#125; 總結:二元樹的對稱不一定是完全二元樹，所以要考慮空節點的位置，其中做假節點的方式行不通尤其碰上了極端的樹狀會陷入兩難，此外也不能用stack來檢查每列是否對稱，stack僅能判定一對一的關係而非對稱，所以比較好的方式是在完全複製一棵樹，其一p樹的左子節點與另一q樹的右子節點為一組，再來則是p樹的右子節點與q樹的左子節點為一組，兩組分別進入隊列來同時做廣度優先遍歷，如此一來只要每次都從隊列取兩點來檢查值是否相同就好，不需要擔心是否對稱的問題。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"},{"name":"DepthFirstSearch","slug":"DepthFirstSearch","permalink":"https://blog.yunchen.tw/tags/DepthFirstSearch/"},{"name":"BreadthFirstSearch","slug":"BreadthFirstSearch","permalink":"https://blog.yunchen.tw/tags/BreadthFirstSearch/"}]},{"title":"Same Tree","slug":"same-tree","date":"2016-12-02T16:00:00.000Z","updated":"2017-04-05T15:08:16.000Z","comments":true,"path":"2016/12/03/same-tree/","link":"","permalink":"https://blog.yunchen.tw/2016/12/03/same-tree/","excerpt":"","text":"Same TreeGiven two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. 提示 解題應用 Tree 樹的遍歷方式 DepthFirstSearch 前序遍歷 Default:123func preOrderTravel(p *TreeNode, q *TreeNode) bool &#123;&#125; 解答思路:既然要比較兩個樹是否相同的話，就意味著需要做樹的遍歷，而二元樹的遍歷一般來說就想到前序、中序與後續遍歷，因為我們需要先比較值是否相同才繼續往下，所以就採用前序遍歷的方式來處理，既然用上了遞回來處理自然程式的編寫上就輕鬆不少。 程式碼解說:為了加快判斷兩二元樹是否完全相同，首先可以先確認樹的形狀是否相同，可以先藉由兩兩節點是否都同時存在來決定，這在遍歷到樹的末支節點時可以少幾個步驟，不必每次都去取得節點的值才做判斷，而一定要到最後兩兩皆不存在，也就是到末支節點了才可以回傳true，若先前的形狀都相同的話，再來才是判斷兩兩節點的值是否相同，如果也沒有問題的話，這時才將二元樹分拆成左二元樹與右二元樹再重新遞回，如果有其中一個分支回傳false就會依序往上遞回回去，表示並非完全相同，直到所有二元樹的節點完全遍歷後沒有問題，最終才能夠確信這是兩棵完全相同的二元樹。 123456if p == nil &amp;&amp; q == nil &#123; return true&#125; else if p == nil || q == nil &#123; return false&#125;return (p.Val == q.Val) &amp;&amp; preOrderTravel(p.Left, q.Left) &amp;&amp; preOrderTravel(p.Right, q.Right) 完整程式碼:1234567891011func preOrderTravel(p *TreeNode, q *TreeNode) bool &#123; if p == nil &amp;&amp; q == nil &#123; return true &#125; else if p == nil || q == nil &#123; return false &#125; return (p.Val == q.Val) &amp;&amp; preOrderTravel(p.Left, q.Left) &amp;&amp; preOrderTravel(p.Right, q.Right)&#125;func isSameTree(p *TreeNode, q *TreeNode) bool &#123; return preOrderTravel(p, q)&#125; 總結:若需要比對兩二元樹是否完全相同，可以用前序遍歷的方式來做，先行判斷再來決定要不要再繼續進行樹的遍歷，除了值是否相同之外，也可以透過兩兩節點是否都存在斷定樹的形狀，來提前得知是否兩二元樹完全相同。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Tree","slug":"Tree","permalink":"https://blog.yunchen.tw/tags/Tree/"},{"name":"DepthFirstSearch","slug":"DepthFirstSearch","permalink":"https://blog.yunchen.tw/tags/DepthFirstSearch/"}]},{"title":"Merge Sorted Array","slug":"merge-sorted-array","date":"2016-12-01T16:00:00.000Z","updated":"2017-05-02T06:37:33.000Z","comments":true,"path":"2016/12/02/merge-sorted-array/","link":"","permalink":"https://blog.yunchen.tw/2016/12/02/merge-sorted-array/","excerpt":"","text":"Merge Sorted ArrayGGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 提示 解題應用 Array 每格儲存值整體位移 TwoPointers 記錄Array位移位置 Default:123func merge(nums1 []int, m int, nums2 []int, n int) &#123;&#125; 解答思路:先前也有類似的題目，只是當時是Linked List，這次是用Array來處理，麻煩上來說Array並不比Linked List輕鬆，既然已經告訴你第一個Array已經有足夠的長度就意味著你不需要新增新的陣列來儲存，也就是說當該陣列在前面新增一個值時，你需要將後頭的值一個個向後移，這會浪費不少時間在處理位移，唯一的優點就是取值時不再需要遍歷，而重點就是需要幾個flag來紀錄第一個陣列的開頭index與尾巴index和第二個陣列的開頭index， 程式碼解說:第一個陣列結尾的index值最為重要，因為第二個陣列的值是要插入第一個陣列排序，這意味著當值依大小放入第一個陣列之中時，在該值後頭原本就在的資料就要依序往後挪一格讓該值有空間存放，而移動時則是從原本第一陣列最後頭有資料的那格開始移問題會最小，而隨著前面資料的增加理所當然結尾的index值也會跟著變大，再加上如果接下來要插入的值都比第一個陣列的所有資料都大，也需要知道第一個陣列結尾的index在哪才能夠將剩餘的值依續往該index後頭放，而至於兩個陣列開頭的index則是記錄目前值的大小已經比較到哪裡，用於將要插入的值準確的放入大小有序的陣列之中 123flag1 := 0flag1e := m - 1flag2 := 0 利用一回圈來逐步比較兩陣列值的大小來尋求插入點，原則上來說當第一個陣列的長度遍歷等於所有資料長度時，會與第二個陣列遍歷的資料同時達成(畢竟是第二個陣列的資料已經全塞入第一個陣列之中了)，不過這邊還是寫成達成其一條件就結束迴圈，而正如先前所說當插入值在第一個陣列尋找比其大的值，比其小第一個陣列就繼續往下一個走直到發現較大值的位置，再來就將資料放在該值的前面，這時就需要再一個迴圈從陣列最後的index將資料一個個向後移以多出一格空間，隨著值放入之後，最後的index值當然也會跟著變大，而第二個陣列因為已經將值放入，自然就找下一個值準備再插入，直到要插入的點已經超過第一個陣列尾巴index值的下一個(意味著目前插入的值已經都比第一個陣列的所有資料來的大)，那最後就只要將第二個陣列中其餘的資料依序往後頭放即可結束 1234567891011121314151617181920for true &#123; if flag1 == m+n || flag2 == n &#123; break &#125; else if nums1[flag1] &gt;= nums2[flag2] &#123; for i := flag1e; i &gt;= flag1; i-- &#123; nums1[i+1] = nums1[i] &#125; nums1[flag1] = nums2[flag2] flag1e++ flag2++ &#125; else if flag1 == flag1e+1 &#123; for j := flag2; j &lt; n; j++ &#123; nums1[flag1] = nums2[j] flag1++ &#125; break &#125; else &#123; flag1++ &#125;&#125; 完整程式碼:12345678910111213141516171819202122232425func merge(nums1 []int, m int, nums2 []int, n int) &#123; flag1 := 0 flag1e := m - 1 flag2 := 0 for true &#123; if flag1 == m+n || flag2 == n &#123; break &#125; else if nums1[flag1] &gt;= nums2[flag2] &#123; for i := flag1e; i &gt;= flag1; i-- &#123; nums1[i+1] = nums1[i] &#125; nums1[flag1] = nums2[flag2] flag1e++ flag2++ &#125; else if flag1 == flag1e+1 &#123; for j := flag2; j &lt; n; j++ &#123; nums1[flag1] = nums2[j] flag1++ &#125; break &#125; else &#123; flag1++ &#125; &#125;&#125; 總結:兩大小有序的陣列要做合併時，需要記錄三個值，分別是兩陣列的開頭index用於表示目前兩陣列值大小比較後的位置以尋求插入點，而第三個值最為重要，記錄著第一個要合併陣列的index值，用於當值插入陣列前方時需要從最後頭將原資料一個個向後移動以空出新位置，此外當插入的點已經超過第一個陣列尾巴index值的下一個，意味著目前插入的值已經比第一個陣列的所有資料來的大，這時僅需將其餘的資料依序往後頭放即可。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"}]},{"title":"Remove Duplicates from Sorted List","slug":"remove-duplicates-from-sorted-list","date":"2016-11-30T16:00:00.000Z","updated":"2017-05-12T13:36:01.000Z","comments":true,"path":"2016/12/01/remove-duplicates-from-sorted-list/","link":"","permalink":"https://blog.yunchen.tw/2016/12/01/remove-duplicates-from-sorted-list/","excerpt":"","text":"Remove Duplicates from Sorted ListGiven a sorted linked list, delete all duplicates such that each element appear only once. For example:12Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 提示 解題應用 Linked List Pointer Default:12345678910/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func deleteDuplicates(head *ListNode) *ListNode &#123;&#125; 解答思路:也是相當單純的Linked List應用，基本上只要注意有相同值時，該節點只需改變下一個指向的點就好，本身的位置先不需改變，因為有可能下下個的節點值還是一樣的，例如: ‘1’-&gt;1-&gt;1-&gt;2，第一個1的位置仍不動，只需把指向改到第三個1再繼續做判斷 ‘1’-&gt;1-&gt;2 其它的就沒什麼大問題了。 程式碼解說:這邊一開始先用了flag暫存第一個節點的位置，節點往下走處理完後，最後用於回傳最初的節點，而暫存值是用來儲存前一個節點的值來判斷是否相同，這邊預設就先塞了int32位元的最大值來以防重覆，因為一定不會對第一個節點做操作，就算值重覆也是砍掉後頭的節點，所以這次也不需要有新的頭節點來確保操作一致性，之後就是利用一迴圈來不斷的遍歷整個Linked List，如果值不相同就把當前節點(連同暫存前一節點的位置)往下移動，直到回傳nil才跳開回圈，但如果相同就需要做嫁接了，這時就需要前一個節點的位置，並在前一節點的下一個直接指向當前節點的下一個，大致上來說只有前一節點的位置會因為值相同與否才做更動，另外沒有釋放節點的記憶體，所以如果你想做這個動作就不妨再多加個一行去處理 12345678910111213var flag *ListNodevar preNode *ListNodetmp := math.MaxInt32flag = headfor head != nil &#123; if tmp != head.Val &#123; tmp = head.Val preNode = head &#125; else &#123; preNode.Next = head.Next &#125; head = head.Next&#125; 完整程式碼:12345678910111213141516func deleteDuplicates(head *ListNode) *ListNode &#123; var flag *ListNode var preNode *ListNode tmp := math.MaxInt32 flag = head for head != nil &#123; if tmp != head.Val &#123; tmp = head.Val preNode = head &#125; else &#123; preNode.Next = head.Next &#125; head = head.Next &#125; return flag&#125; 總結:將Linked List中相同值的節點移除，基本上就是只有前一節點的位置會因為值相同與否才做嫁接，而當前的節點就是一直往下走到底。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://blog.yunchen.tw/tags/LinkedList/"}]},{"title":"Climbing Stairs","slug":"climbing-stairs","date":"2016-11-29T16:00:00.000Z","updated":"2017-04-05T15:06:36.000Z","comments":true,"path":"2016/11/30/climbing-stairs/","link":"","permalink":"https://blog.yunchen.tw/2016/11/30/climbing-stairs/","excerpt":"","text":"Climbing StairsYou are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 提示 解題應用 DynamicProgramming 規律觀察 Default:123func climbStairs(n int) int &#123;&#125; 解答思路:也許是解題的敏感度不足，看到此題便很快速的想要用排序組合的方式來運算，好比說4個階梯有2個1步與2個2步的不同走法數就是4!/(2!2!)，在排序組合就是總數!(階)去除上兩個彼此相異數!的乘積，如此一來其它狀況也藉由此方式來算最後總合起來就是結果，聽起來合情合理，可是電腦要算的話光是35階這個數或更小就足以讓你溢位了，所以看來不是以這種方式來解決問題，而最後從整體數序來觀察規律就可以很輕易的將此題給搞定了，1, 2, 3, 5, 8…，其實就是很標準的費式數列: *第三項值 = 第一項值 + 第二項值 程式碼解說:因為相當單純，就直接用迴圈來做就不使用遞回的方式了，因為費式數列至少需要開頭兩項的值，1階當然只有一種走法，而2階則兩種走法，其餘的階梯算法就只要先把總階數減2(第1,第二階)再不斷用迴圈計算第三項，並暫存前兩項的值即可 1234567891011121314151617func climbStairs(n int) int &#123; var result int tmp1 := 1 tmp2 := 2 if n == 1 &#123; return 1 &#125; else if n == 2 &#123; return 2 &#125; else &#123; for i := 1; i &lt;= n-2; i++ &#123; result = tmp1 + tmp2 tmp1 = tmp2 tmp2 = result &#125; &#125; return result&#125; 完整程式碼:1234567891011121314151617func climbStairs(n int) int &#123; var result int tmp1 := 1 tmp2 := 2 if n == 1 &#123; return 1 &#125; else if n == 2 &#123; return 2 &#125; else &#123; for i := 1; i &lt;= n-2; i++ &#123; result = tmp1 + tmp2 tmp1 = tmp2 tmp2 = result &#125; &#125; return result&#125; 總結:算階梯走法不是考數學，所以不需要會排序組合，要的只是對數列做觀查，從而發現其為費式數列。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"DynamicProgramming","slug":"DynamicProgramming","permalink":"https://blog.yunchen.tw/tags/DynamicProgramming/"}]},{"title":"Add Binary","slug":"add-binary","date":"2016-11-28T16:00:00.000Z","updated":"2017-04-05T15:06:28.000Z","comments":true,"path":"2016/11/29/add-binary/","link":"","permalink":"https://blog.yunchen.tw/2016/11/29/add-binary/","excerpt":"","text":"Add BinaryGiven two binary strings, return their sum (also a binary string). For Example:123a = &quot;11&quot;b = &quot;1&quot;Return &quot;100&quot;. 提示 解題應用 String 觀查規律 Math 觀查規律 Default:123func addBinary(a string, b string) string &#123;&#125; 解答思路:一般來說看到題目就會曉得1與1就進位，0與1則為1，0與0則為0，這三個基本上就是二進位加法的全部了，不過因為有可能長度會不一樣，也許將短的前頭捕一排0也是個辦法，不過一開始嫌麻煩就直接將兩個先轉成數字加起來，位數合為2的就進位，看起來就簡單非常多，寫好送出馬上就發現了大問題，就是給的參數數字未免也太龐大的，連int64都放不下，可想而之就是要你乖乖的用字串來處理，而這邊我將較長的部分給拆開變成兩個參數一樣長，待判斷完如果有進位再與原本較長的部分判斷，好處就是如果沒有進位，原本較長拆開多出的二進字串最後就直接接在前面就搞定了，尤其是兩個參數差異極大步驟就少了許多。 程式碼解說:因為相加一定是從尾數開始，所以拿到兩個字串長度後，用一個迴圈來將兩個字串分別從尾部將字元一一取出，之後正如一開始所說的1與1就是回傳1，其中一個為1的就是回傳1，而兩個為0則為0，不過因為還要考量到進位的問題，用了一個flag在確認是否有進位，所以上述的情況就又各別多了進位後會產生的回傳，好比兩個皆為1時，但如果又有進位值來該位數+1的話，這時的位數就不是0而是為1了，其它的就以此類推，要注意的是在迴圈一開始的判斷式是用來得知哪一個參數字串的長度比較長，而比較短的在從最後頭取值時自然就會先歸0了，這時就將另一個較長多餘的部分連同長度給另存起來到下一個迴圈繼續處理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var tmp stringvar length intvar result stringvar achar stringvar bchar stringalen := len(a)blen := len(b)flag := falsefor true &#123; if alen == 0 &#123; tmp = b[0:blen] length = blen break &#125;else if blen == 0 &#123; tmp = a[0:alen] length = alen break &#125; achar = string(a[alen-1]) bchar = string(b[blen-1]) if achar == \"1\" &amp;&amp; bchar == \"1\" &#123; if flag &#123; result = \"1\" + result flag = true &#125; else &#123; result = \"0\" + result flag = true &#125; &#125; else if achar == \"1\" || bchar == \"1\" &#123; if flag &#123; result = \"0\" + result flag = true &#125; else &#123; result = \"1\" + result flag = false &#125; &#125; else &#123; if flag &#123; result = \"1\" + result flag = false &#125; else &#123; result = \"0\" + result flag = false &#125; &#125; alen-- blen--&#125; 接續先前相同長度時的比較，接下來的迴圈就是先前的結果是否進位與多餘長度字串的處理，這次我們只要知道這個拆出去字串的字元是0還是1，接下來只要視之前結果有無進位來判斷即可，不過如果沒有進位的話就不需要再讓迴圈執行下去了，將拆出去而暫存字串依目前剩餘的長度，直接與先前結果相接即可，因為要比較的只有進位與剩下的字串，如果沒有進位理所當然就不同繼續，但如果是進位到底而超出了原本字串的長度時，好比99+1為100時，那麼最後就在開頭補上1結束 123456789101112131415161718192021222324252627for true &#123; if length == 0 &#123; if flag &#123; result = \"1\" + result &#125; break &#125; tchar = string(tmp[length-1]) if tchar == \"1\" &#123; if flag &#123; result = \"0\" + result flag = true &#125; else &#123; result = tmp[0:length] + result break &#125; &#125; else &#123; if flag &#123; result = \"1\" + result flag = false &#125; else &#123; result = tmp[0:length] + result break &#125; &#125; length--&#125; 完整程式碼:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879func addBinary(a string, b string) string &#123; var tmp string var length int var result string var achar string var bchar string var tchar string alen := len(a) blen := len(b) flag := false for true &#123; if alen == 0 &#123; tmp = b[0:blen] length = blen break &#125;else if blen == 0 &#123; tmp = a[0:alen] length = alen break &#125; achar = string(a[alen-1]) bchar = string(b[blen-1]) if achar == \"1\" &amp;&amp; bchar == \"1\" &#123; if flag &#123; result = \"1\" + result flag = true &#125; else &#123; result = \"0\" + result flag = true &#125; &#125; else if achar == \"1\" || bchar == \"1\" &#123; if flag &#123; result = \"0\" + result flag = true &#125; else &#123; result = \"1\" + result flag = false &#125; &#125; else &#123; if flag &#123; result = \"1\" + result flag = false &#125; else &#123; result = \"0\" + result flag = false &#125; &#125; alen-- blen-- &#125; for true &#123; if length == 0 &#123; if flag &#123; result = \"1\" + result &#125; break &#125; tchar = string(tmp[length-1]) if tchar == \"1\" &#123; if flag &#123; result = \"0\" + result flag = true &#125; else &#123; result = tmp[0:length] + result break &#125; &#125; else &#123; if flag &#123; result = \"1\" + result flag = false &#125; else &#123; result = tmp[0:length] + result break &#125; &#125; length-- &#125; return result&#125; 總結:二進位的相加不能轉成數字相加再處理，因為有可能給的參數過大而導致溢位，所以一定要以字串來判斷處理，當遇上長度不一的二進位做相加時，可以以補0或是將較長多餘的部分拆開做第二次處理，若為後者再最後處理時僅為進位與多餘部分字串的判斷。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"Plus One","slug":"plus-one","date":"2016-11-27T16:00:00.000Z","updated":"2017-04-05T15:06:18.000Z","comments":true,"path":"2016/11/28/plus-one/","link":"","permalink":"https://blog.yunchen.tw/2016/11/28/plus-one/","excerpt":"","text":"Plus OneGiven a non-negative number represented as an array of digits, plus one to the number. The digits are stored such that the most significant digit is at the head of the list. 提示 解題應用 Array Array/Slice Math 觀查規律 Default:123func plusOne(digits []int) []int &#123;&#125; 解答思路:有點像是在做電子顯示器的邏輯，只是這次不必理會數字怎麼顯示，基本上和預想的差不多，小於9的數字就直接+1做回傳，稍為麻煩的在於進位的處理，如果是一段數字中尾數幾個數字的進位而不影響整體的長度就不需要重新創一個array，直接將進度的位數歸0往前一位+1就好，但如果最後像是99+1的話，就需要擴增array的長度，此時新加長度的開頭一定是1，而在Golang中與其要一個個移動array值，倒不如就直接新增一個slice合併即可。 程式碼解說:因為+1的值要重最尾巴的數字開始判斷起，所以取得長度後就開始從Array的最後一個值慢慢往前 1234length := len(digits)for true &#123; length--&#125; 接下來就分成三種情況，如果+1時該位數小於9也就是沒有再進位的狀況就直接把數字+1然後就可以回傳結果了，但如果該值等於9而且長度大於0(表示進位時還在數字長度之中，不需要擴增array)，就先將該位數的值設為0等然後回圈就往下取下一個值做判斷，等同於進位後再往下+1，最後一個else當然就是先前所說的超過數字長度的最大值，也就是進位後開頭為1，這時就是一樣先將該位設為0後，用slice把第一個值賦予1接著就可以與順利的把整個array展開合併回傳結果 1234567891011if digits[length-1] &lt; 9 &#123; digits[length-1] = digits[length-1] + 1 break&#125; else if length-1 &gt; 0 &#123; digits[length-1] = 0&#125; else &#123; digits[length-1] = 0 result := []int&#123;1&#125; result = append(result, digits...) return result&#125; 完整程式碼:123456789101112131415161718func plusOne(digits []int) []int &#123; length := len(digits) for true &#123; if digits[length-1] &lt; 9 &#123; digits[length-1] = digits[length-1] + 1 break &#125; else if length-1 &gt; 0 &#123; digits[length-1] = 0 &#125; else &#123; digits[length-1] = 0 result := []int&#123;1&#125; result = append(result, digits...) return result &#125; length-- &#125; return digits&#125; 總結:將數字每一位數分別儲存至array中時，最需要注意的就是進位後是否超出該數字的長度，共分三種情況: 增加的該位數小於9直接回傳 進位後該位數歸0後繼續做判斷 進位後超出整體數字的出度，新增一個array且第一格放1後與原本的array在後頭做合併","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"Length of Last Word","slug":"length-of-last-word","date":"2016-11-25T16:00:00.000Z","updated":"2017-04-05T15:06:02.000Z","comments":true,"path":"2016/11/26/length-of-last-word/","link":"","permalink":"https://blog.yunchen.tw/2016/11/26/length-of-last-word/","excerpt":"","text":"Length of Last WordGiven a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. For example:*12Given s = &quot;Hello World&quot;,return 5. Note: The sequence of integers will be represented as a string. 提示 解題應用 String 切割或反轉字串 Default:123func lengthOfLastWord(s string) int &#123;&#125; 解答思路:這題算是相當單純的字串處理，不是要從字串找字那樣的麻煩，僅僅要找字串中的最後一個字，這邊或許可以用字串中的切割，回傳拿到所有空白分割後每個字的陣列之後，將陣列的最後一個值的長度傳回即可，不過似乎不需要做到這樣，因為只要最後一個字，所以從字串的最後一個字元開始來算，最後碰上空白字元跳開就好，這邊只有一點要注意的是這個字串最後可能會有空白字元，你可以把前後字串的空白字元切掉(trim)在開始做，或者用判斷在後頭讀取時，一開碰上空白字元就略過也是一種方式。 程式碼解說:這裡單純是利用迴圈將字串中的所有字元從尾端一一取出，直到最後取完長度為0才跳開，多加這個條件是除了防止給予的為空字串或取字串index值為-1之外，也有可能這個字串根本就只有一個字而沒有空格 123456789var char stringlength := len(s)for true &#123; if length == 0 &#123; break &#125; char = string(s[length-1]) length--&#125; 再來我這邊是判斷尾巴一開始是否有多餘的空格，沒有的話才開始計算最後的單字長度有多長，直到再次碰上空格就可以知道這個單字已經到底，所以就可以跳出整個迴圈了 123456if char != \" \" &#123; flag = true result++&#125; else if flag &#123; break&#125; 完整程式碼:1234567891011121314151617181920func lengthOfLastWord(s string) int &#123; var char string length := len(s) result := 0 flag := false for true &#123; if length == 0 &#123; break &#125; char = string(s[length-1]) if char != \" \" &#123; flag = true result++ &#125; else if flag &#123; break &#125; length-- &#125; return result&#125; 總結:難度不高的題目，要注意的只有給予的值可能只有一個單字或字串的尾巴有多餘的空格。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"}]},{"title":"Count and Say","slug":"count-and-say","date":"2016-11-07T16:00:00.000Z","updated":"2017-04-05T15:05:48.000Z","comments":true,"path":"2016/11/08/count-and-say/","link":"","permalink":"https://blog.yunchen.tw/2016/11/08/count-and-say/","excerpt":"","text":"Count and SayThe count-and-say sequence is the sequence of integers beginning as follows:1, 11, 21, 1211, 111221, … 1 is read off as “one 1” or 11. 11 is read off as “two 1s” or 21. 21 is read off as “one 2, then one 1” or 1211. Given an integer n, generate the nth sequence. Note: The sequence of integers will be represented as a string. 提示 解題應用 額外的package String 規律觀察 strconv Default:123func countAndSay(n int) string &#123;&#125; 解答思路:這題最大的難度應該在於看懂題目，看懂了就會覺得沒什麼了，這裡需要你回傳一個序列第n個值，至於這個序列的開頭初始為1，細節規則如下: 1: 表示 1 個 1 故結果為 11 (將此值往下帶入，後續以此類推) 11: 表示 2 個 1 故結果為 21 21: 表示 2 個 1 及 1 個 1 故結果為 1211 一開始沒看清楚要的是第n個值，所以在網站上直接將序列的結果丟到網站上跑測試資料來推估這題的意思，一連又丟了好幾個，等到發現時網站就一口氣吐了包含先送的測資結果，變成好幾個天文數字合在一起連著瀏覽器也當掉了。 程式碼解說:因為這個序列的初始為”1”，一開始便以”1”為結果來做起始，因為要回傳的結果為字串，同時字串也方便我們去將數量與該數字做合併，所以就”1”就以字串來表示，不過這邊要注意的是因為序列第n個值也包含了”1”，所以在一開始的時候就要減1，接著進一個迴圈來判斷拿到的結果要往回帶入幾次，同時將存結果的值丟給另一變數後清空，因為接下來要存新的結果，而這個變數就先取出第一個值判斷是否與下一個值相同以方便計算此數的總量 12345678910var str stringresult := \"1\"n--for n &gt; 0 &#123; n-- str = result result = \"\" tmp := string(str[0]) count := 1&#125; 存取變數第一個值後，便能開始一一比對是否和下個值的數字相同，不一樣才把數量與該數字加入結果，count要用strconv的package去處理，不然會變成ascii的轉換，接著才重新計算數量與該數字，最後要注意如果到最後一個數字時，才剛重新計算就跳開回圈了，所以要再最後再處理一次結果 1234567891011var vs stringfor _, v := range str[1:] &#123; vs = string(v) if tmp != vs &#123; result = result + strconv.Itoa(count) + tmp count = 0 tmp = vs &#125; count++&#125;result = result + strconv.Itoa(count) + tmp 完整程式碼:123456789101112131415161718192021222324func countAndSay(n int) string &#123; var vs string var str string result := \"1\" n-- for n &gt; 0 &#123; n-- str = result result = \"\" tmp := string(str[0]) count := 1 for _, v := range str[1:] &#123; vs = string(v) if tmp != vs &#123; result = result + strconv.Itoa(count) + tmp count = 0 tmp = vs &#125; count++ &#125; result = result + strconv.Itoa(count) + tmp &#125; return result&#125; 總結:Count and Say為從1開始的序列，序列第n項以上一個的結果值的 “數量” + “該數字” 合併並往下重覆執行上述規則。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"}]},{"title":"Valid Sudoku","slug":"valid-sudoku","date":"2016-11-06T16:00:00.000Z","updated":"2017-04-05T15:05:37.000Z","comments":true,"path":"2016/11/07/valid-sudoku/","link":"","permalink":"https://blog.yunchen.tw/2016/11/07/valid-sudoku/","excerpt":"","text":"Valid SudokuThe Sudoku board could be partially filled, where empty cells are filled with the character ‘.’. Note: A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated. 提示 解題應用 Hash Table Hash Map Default:123func isValidSudoku(board [][]byte) bool &#123;&#125; 解答思路:參數範例: 1[&quot;..4...63.&quot;,&quot;.........&quot;,&quot;5......9.&quot;,&quot;...56....&quot;,&quot;4.3.....1&quot;,&quot;...7.....&quot;,&quot;...5.....&quot;,&quot;.........&quot;,&quot;.........&quot;] 數讀有玩過的話規則應該都能理解，水平線與垂直線及九宮格間的數字填入1~9皆不可重覆，不過因為給的參數是二元陣列，所以就算是行與列兩者的處理方式也不太一樣，以水平列來說算是最為單純，以上述範例來說，水平的話就跟處理一維陣列資料差不多，只要遍歷每個元素是否重覆即可，不過垂直就沒那麼簡單了，因為以第一個垂直線來說，它需要獲得每個陣列中的第一個，這意味著你需要將全數二元陣列遍歷完才有辦法判斷，而九宮格則是要每爬完三條水平線才能處理，至於要怎麼知道這些數字重覆，你可以產生一個陣列如果不在陣列裡頭就儲存直到發現重覆，不過這邊我們用Hash Map的方式來做似乎比較明智些，如此一來就不用在去寫一個回圈來遍歷陣列的值是否重覆。 程式碼解說:這邊我拆成了三個部分來說水平、垂直與九宮格的處理方式，水平相對單純許多，只要記錄一水平線中的每個值是否存在，不存在的話就塞入，這邊與接下來另外垂直與九宮格所儲存的方式一樣，主要是檢查map的key值，而不用在乎真正存入的值是什麼，這邊我姑且先和key的值一樣都是放該數字的值，而再每一水平線檢查完後就將水平的hash map清空，事實上只是重新指派新的空間，釋放記憶體的動作就交給golang的garbage collection 12345678910111213141516var str stringhori := make(map[string]string)for i, v := range board &#123; for j, vv := range v &#123; str = string(vv) if str != \".\" &#123; _, okj := hori[str] if okj &#123; return false &#125; else &#123; hori[str] = str &#125; &#125; &#125; hori = make(map[string]string)&#125; 垂直的部分就稍嫌麻煩許多，因為要記錄全部二元陣列的值才有辦法判斷，所以這邊hash map的key與value的值就是該垂直線的第n列+數字以此來區隔各列的數字，不過可能有人會問index的值是直接由j轉成字串，不就會變成ascii的轉換了嗎?確實是如此，因為golang要賦予key值一定要同型別所以就直接這樣轉，不過值是ascii這倒無所謂，因為主要是來區別各列不同就可以了 1234567891011121314151617var str stringvar index stringvert := make(map[string]string)for i, v := range board &#123; for j, vv := range v &#123; index = string(j) str = string(vv) if str != \".\" &#123; _, oki := vert[index+str] if oki &#123; return false &#125; else &#123; vert[index+str] = index + str &#125; &#125; &#125;&#125; 九宮格的操作與水平、垂直線不同，要區分的是要存在哪一格的九宮格，因為總共分成上、中、下各三個共計九個，所以這邊我們就把i與j的值除以3即可，0,1,2除以3為0 3,4,5除以3為1 6,7,8除以3為2 並以此為座標來區分，如此以來便能很容易的將數字分配到這九個九宮格做判斷並儲存 12345678910111213141516171819var str stringvar x stringvar y stringnine := make(map[string]string)for i, v := range board &#123; for j, vv := range v &#123; str = string(vv) if str != \".\" &#123; x = string(i / 3) y = string(j / 3) _, okk := nine[x+y+str] if okk &#123; return false &#125; else &#123; nine[x+y+str] = x + y + str &#125; &#125; &#125;&#125; 完整程式碼:12345678910111213141516171819202122232425262728293031func isValidSudoku(board [][]byte) bool &#123; var str string var index string var x string var y string hori := make(map[string]string) vert := make(map[string]string) nine := make(map[string]string) for i, v := range board &#123; for j, vv := range v &#123; index = string(j) str = string(vv) if str != \".\" &#123; _, oki := vert[index+str] _, okj := hori[str] x = string(i / 3) y = string(j / 3) _, okk := nine[x+y+str] if oki || okj || okk &#123; return false &#125; else &#123; vert[index+str] = index + str hori[str] = str nine[x+y+str] = x + y + str &#125; &#125; &#125; hori = make(map[string]string) &#125; return true&#125; 總結:數讀的檢查分為水平、垂直與九宮格，因需判斷該數字是否重覆再加上垂直與九宮格皆需分類為第n列的數字與哪一格的九宮格，故hash map儲存為最佳儲存方式。 水平線: 最為單純，和處理一維陣列資料差不多 垂直線: 需增加第n列為條件來做儲存與判斷 九宮格: 將水平線的第x行與垂直線的第y列分別除以3為判別九宮格座標來儲存","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"}]},{"title":"Remove Element","slug":"remove-element","date":"2016-11-05T16:00:00.000Z","updated":"2017-04-05T15:05:23.000Z","comments":true,"path":"2016/11/06/remove-element/","link":"","permalink":"https://blog.yunchen.tw/2016/11/06/remove-element/","excerpt":"","text":"Remove ElementGiven an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example:123Given input array nums = [3,2,2,3], val = 3Your function should return length = 2, with the first two elements of nums being 2. 提示 解題應用 Array Merge/Move Elements Default:123func removeElement(nums []int, val int) int &#123;&#125; 解答思路:此題和先前文章的Remove Duplicates from Sorted Array思路太過類似所以內容就大部分照貼。 這題不但要回傳不重覆數組的長度之外，你也需要將所給予值相同的數字從數組中移除，不過這個數組就不需要回傳，這邊長度還滿容易想到的，只要比對是不是和所給予的值相同就可以算出剩餘不同的數字共有多少個，問題是需要將所給予值相同的數字移除，這邊的移除是要將空下來的位置一一遞補，所以會有可觀的操作在這邊，看是將array拆解去掉不要的部分後合併成新的array，或者用選擇的方式把後面有存數字的位置直接與空的部分做交換，至少我想到的來說，最後者比較妥當些。 程式碼解說:這邊我拆成兩部分來解答，一開始先走訪整個array，對比前後數字是否和所給予的值相同來算出整個array剩餘不同的數字共有多少個，同時將那些重覆的值塞入一個極大值，這邊也可以放極小值，總之就是需要一個標示來告知這些在array之中是不需要的空間 12345678var count intfor i, v := range nums &#123; if v != val &#123; count++ &#125; else &#123; nums[i] = math.MaxInt32 &#125;&#125; 再來就是處理重覆的數字，這邊我先以一個回圈做檢查，如果發現到是極大值的話就再進一個回圈並從該處開始遍歷在其之後所有的值，直到發現有非極大值也就是我們的目標後，與外層回圈找到的極大值兩個位置的值做交換，雖然是說交換不過我就直接把原本目標位置的值再塞一個極大值進去而已，之後再回到外層的回圈繼續檢查，最後因為我們已經知道有多少個剩餘不同的數字，所以只要檢查到索引值+1就可以停了 1234567891011121314for i, v := range nums &#123; if v == math.MaxInt32 &#123; for j, vv := range nums[i+1:] &#123; if vv != math.MaxInt32 &#123; nums[i] = vv nums[i+j+1] = math.MaxInt32 break &#125; &#125; &#125; if i+1 == count &#123; break &#125;&#125; 完整程式碼:1234567891011121314151617181920212223242526func removeElement(nums []int, val int) int &#123; var count int for i, v := range nums &#123; if v != val &#123; count++ &#125; else &#123; nums[i] = math.MaxInt32 &#125; &#125; for i, v := range nums &#123; if v == math.MaxInt32 &#123; for j, vv := range nums[i+1:] &#123; if vv != math.MaxInt32 &#123; nums[i] = vv nums[i+j+1] = math.MaxInt32 break &#125; &#125; &#125; if i+1 == count &#123; break &#125; &#125; return count&#125; 總結:欲刪除一陣列中重覆的值可先遍歷一次對照前後是否相同算出彼此相異的數字有多少個，同時將相同的值賦予標示，例如特定值後做簡易選擇交換，端看出題方式甚至能重組陣列來達成目標。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"}]},{"title":"Swap Nodes in Pairs","slug":"swap-nodes-in-pairs","date":"2016-11-04T16:00:00.000Z","updated":"2017-04-05T15:05:10.000Z","comments":true,"path":"2016/11/05/swap-nodes-in-pairs/","link":"","permalink":"https://blog.yunchen.tw/2016/11/05/swap-nodes-in-pairs/","excerpt":"","text":"Swap Nodes in PairsGiven a linked list, swap every two adjacent nodes and return its head. For example: 1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 提示 解題應用 LinkedList Pointer Default:123456789/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func swapPairs(head *ListNode) *ListNode &#123;&#125; 解答思路:由於不會太複雜，所以很快就想好了大概，在這邊會發現到一定是前後兩個一組湊一組交換，那麼其實只要設一個計數器只要是偶數就只與前交換，或者是只要是基數就只與後交換，如此一來就搞定了，不過這邊有一點要注意到就是每組之間的聯繫，如果下一組只有一個那當然只要接上就好，但如果是兩個勢必會做交換，這時前一組要接續的下一個節點就會是交換前原本在後面的節點，只要有注意到這回事應該沒有什麼大問題。 程式碼解說:一開始簡單的判斷一下是不是有兩個以上，如果只有一個就只要回傳第一個位置就好，但如果有兩個以上就要傳第二個的位置，畢竟會交換跑至開頭的位置，這邊會發現這次沒有做頭節點，因為不會在第一個節點做刪除或在其之前做插入，所以就不須理會一致性的操作。 123456var top *ListNodeif head != nil &amp;&amp; head.Next != nil &#123; top = head.Next&#125; else &#123; top = head&#125; 再來只要依續存取節點，同時用一變數來記錄前一節點的位置以方便後續操作，這邊我把計數除以2取餘數來取得為奇數的索引，接著便是前後節點交換，這邊要注意head因為要繼續往下走其它節點，所以交換完之後記得要把head指向交換前原本在前面的節點，如此一來交換後節點到了後頭便能繼續再往下走，才不會發生同一點重覆操作的狀況，最後只要知道下一組也就是下一個節點與下下個節點存不存在，便能知道下一組會不會交換，來判斷前一組的節點要不要指向下一組交換前後頭的節點。 1234567891011121314var tmp *ListNodevar count intfor head != nil &#123; count++ tmp = head head = head.Next if head != nil &amp;&amp; count%2 != 0 &#123; tmp.Next = head.Next head.Next = tmp head = tmp &#125; else if head != nil &amp;&amp; head.Next != nil &#123; tmp.Next = head.Next &#125;&#125; 完整程式碼:1234567891011121314151617181920212223func swapPairs(head *ListNode) *ListNode &#123; var top *ListNode var tmp *ListNode var count int if head != nil &amp;&amp; head.Next != nil &#123; top = head.Next &#125; else &#123; top = head &#125; for head != nil &#123; count++ tmp = head head = head.Next if head != nil &amp;&amp; count%2 != 0 &#123; tmp.Next = head.Next head.Next = tmp head = tmp &#125; else if head != nil &amp;&amp; head.Next != nil &#123; tmp.Next = head.Next &#125; &#125; return top&#125; 總結:LinkedList做前後兩個為一組交換可以簡易的用計數來分組並操作，若下一個接續的組中只剩一個便直接接上即可，但若是兩個便要注意前一組所接續的下一個節點便是在交換前原本在後面的節點。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://blog.yunchen.tw/tags/LinkedList/"}]},{"title":"Remove Duplicates from Sorted Array","slug":"remove-duplicates-from-sorted-array","date":"2016-11-04T16:00:00.000Z","updated":"2017-04-05T15:05:00.000Z","comments":true,"path":"2016/11/05/remove-duplicates-from-sorted-array/","link":"","permalink":"https://blog.yunchen.tw/2016/11/05/remove-duplicates-from-sorted-array/","excerpt":"","text":"Remove Duplicates from Sorted ArrayGiven a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. Example:123Given input array nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn&apos;t matter what you leave beyond the new length. 提示 解題應用 Array Sort/Merge/Move Elements Default:123func removeDuplicates(nums []int) int &#123;&#125; 解答思路:這題不但要回傳不重覆數組的長度之外，你也需要將這些重覆的數字從數組中移除，不過這個數組就不需要回傳，這邊長度還滿容易想到的，因為數組已經是排序好的，所以只要比對是不是和下一個相同就可以算出總共有多少個相異的數字，問題是需要將重覆的數字移除，這邊的移除是要將空下來的位置一一遞補，所以會有可觀的操作在這邊，看是要塞極大值後做排序，還是將array拆解去掉不要的部分後合併成新的array或者用選擇的方式把後面有存數字的位置直接與空的部分做交換，至少我想到的來說，最後者比較妥當些。 程式碼解說:這邊我拆成兩部分來解答，一開始先走訪整個array，對比前後數字是否重覆來算出整個array有多少個相異的數字，同時將那些重覆的值塞入一個極大值，這邊也可以放極小值，總之就是需要一個標示來告知這些在array之中是不需要的空間 12345678910var count inttmp := math.MaxInt32for i, v := range nums &#123; if tmp != v &#123; tmp = v count++ &#125; else &#123; nums[i] = math.MaxInt32 &#125;&#125; 再來就是處理重覆的數字，這邊我先以一個回圈做檢查，如果發現到是極大值的話就再進一個回圈並從該處開始遍歷在其之後所有的值，直到發現有非極大值也就是我們的目標後，與外層回圈找到的極大值兩個位置的值做交換，雖然是說交換不過我就直接把原本目標位置的值再塞一個極大值進去而已，之後再回到外層的回圈繼續檢查，最後因為我們已經知道有多少個彼此相異的數字，所以只要檢查到索引值+1就可以停了 1234567891011121314for i, v := range nums &#123; if v == math.MaxInt32 &#123; for j, vv := range nums[i+1:] &#123; if vv != math.MaxInt32 &#123; nums[i] = vv nums[i+j+1] = math.MaxInt32 break &#125; &#125; &#125; if i+1 == count &#123; break &#125;&#125; 完整程式碼:123456789101112131415161718192021222324252627func removeDuplicates(nums []int) int &#123; var count int tmp := math.MaxInt32 for i, v := range nums &#123; if tmp != v &#123; tmp = v count++ &#125; else &#123; nums[i] = math.MaxInt32 &#125; &#125; for i, v := range nums &#123; if v == math.MaxInt32 &#123; for j, vv := range nums[i+1:] &#123; if vv != math.MaxInt32 &#123; nums[i] = vv nums[i+j+1] = math.MaxInt32 break &#125; &#125; &#125; if i+1 == count &#123; break &#125; &#125; return count&#125; 總結:欲刪除一陣列中重覆的值可先遍歷一次對照前後是否相同算出彼此相異的數字有多少個，同時將相同的值賦予標示，例如極大值後排序或者特定值後做簡易選擇交換，端看出題方式甚至能重組陣列來達成目標。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"https://blog.yunchen.tw/tags/TwoPointers/"}]},{"title":"Merge Two Sorted Lists","slug":"merge-two-sorted-lists","date":"2016-11-01T16:00:00.000Z","updated":"2017-06-21T15:45:24.000Z","comments":true,"path":"2016/11/02/merge-two-sorted-lists/","link":"","permalink":"https://blog.yunchen.tw/2016/11/02/merge-two-sorted-lists/","excerpt":"","text":"Merge Two Sorted ListsMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 提示 解題應用 LinkedList Pointer Default:123456789/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123;&#125; 解答思路:(此題思路有修正，建議看完直接拉到最底下參考修正的部分) 一開始想的是以第一個LinkedList為主(主)，另一個LinkedList(副)就只要將節點依照大小插入主要的LinkedList之中，不過這邊的插入和原先有些出入，原先是真的打算將LinkedList(副)的節點一個一個插入，這樣一來每一個插入LinkedList(主)之後，原先在節點(主)後續銜接的節點又要重新接到新插入節點的後面，而萬一在LinkedList(副)剛好有一長串的節點是要插入同一個節點(主)的後面，就變的相當不自然，因為明明只要將該串(副)的頭、尾節點位置插入節點(主)的前後就可以一口氣塞入整串節點，所以原先的思路上就要以串來想而非單一點。 程式碼解說:這邊我們主要操作的是第一個LinkedList(主)所以只有這個需要一個頭節點來確保操作上的一致性，另外空節點的情況下預設值是0，因為我們要擺最前面當頭節點要最小，所以要考量到有負數的情況，雖然題目所給的參數不會那麼刁專，其實設個-99就足夠了，不過我這邊還是加了math的package來取得32位元整數的最小值。 1234top := &amp;ListNode&#123;&#125;top.Val = math.MinInt32top.Next = l1l1 = top 首先我以巢狀迴圈來分別讀兩個LinkedList，最外層的迴圈是讀我們主要要操作的LinkedList，所以只有該LinkedList需要記錄前一個節點的位置以方便插入，也因為我們有設頭節頭在前面，所以如果有值要插入原本第一個節點的前面，操作上就和後續的節點一致。內層的迴圈自然就是我們決定要將哪些節點插入至LinkedList(主)中，這邊我是以內層與外層(主LinkedList)比較值的大小，如果內層比外層大就回到外層找下一個節點的值，一直到內層小於外層才插入前一個節點，由此可知插入的判斷是介於 大於目前節點的值 與 小於下一個節 之間，先前提到思路上要以整串節點來插入LinkedList(主)而非以單一節點來一個個插入，這邊我設了一個flag來記錄整串節點的尾巴，同時將符合條件的第一個節點接到LinkedList(主)之後，直到內層比外層的值大才將尾巴也接回LinkedList(主)，而else就是外層主要操作的LinkedList已經到底了，內層卻還有剩的節點，表示其餘的節點都比外層最後且值最小的節點都要來的小，那麼就直接將剩餘的節點直接接上即可，最後有一個例外的狀況是將符合條件的第一個節點接到LinkedList(主)之後，在還沒有出現內層比外層值大的狀況，內層節點就已見底導致flag最後沒有將尾巴接回LinkedList(主)之中，所以在內層迴圈結束之後還要再判斷flag的值是否存在並處理。 12345678910111213141516171819202122232425262728var tmp *ListNodevar flag *ListNodefor l1 != nil &#123; tmp = l1 l1 = l1.Next for l2 != nil &#123; if l1 != nil &amp;&amp; l1.Val &lt; l2.Val &#123; if flag != nil &#123; flag.Next = l1 flag = nil &#125; break &#125; else if l1 != nil &amp;&amp; tmp.Val &lt;= l2.Val &amp;&amp; l1.Val &gt;= l2.Val &#123; if flag == nil &#123; tmp.Next = l2 &#125; flag = l2 &#125; else &#123; tmp.Next = l2 break &#125; l2 = l2.Next &#125; if flag != nil &#123; flag.Next = l1 flag = nil &#125;&#125; 完整程式碼:1234567891011121314151617181920212223242526272829303132333435func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; top := &amp;ListNode&#123;&#125; top.Val = math.MinInt32 top.Next = l1 l1 = top var tmp *ListNode var flag *ListNode for l1 != nil &#123; tmp = l1 l1 = l1.Next for l2 != nil &#123; if l1 != nil &amp;&amp; l1.Val &lt; l2.Val &#123; if flag != nil &#123; flag.Next = l1 flag = nil &#125; break &#125; else if l1 != nil &amp;&amp; tmp.Val &lt;= l2.Val &amp;&amp; l1.Val &gt;= l2.Val &#123; if flag == nil &#123; tmp.Next = l2 &#125; flag = l2 &#125; else &#123; tmp.Next = l2 break &#125; l2 = l2.Next &#125; if flag != nil &#123; flag.Next = l1 flag = nil &#125; &#125; return top.Next&#125; 總結:兩排序LinkedList合併成單一LinkedList時，其中做為主來操作，另一則作為輔來當插入點，思路上要以整串節點來插入LinkedList(主)而非以單一節點來一個個插入。 修正:可以自製一個頭節點來確保開頭節點與其它節點操作上的一致性，並且可以在最後才判斷哪一條的LinkedList已經為nil，最後才將另一條直接接到結果LinkedList的後頭即可 123456789101112131415161718192021func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; header := &amp;ListNode&#123;0, nil&#125; pre := header for l1 != nil &amp;&amp; l2 != nil &#123; if l1.Val &lt; l2.Val &#123; pre.Next = l1 pre = l1 l1 = l1.Next &#125; else &#123; pre.Next = l2 pre = l2 l2 = l2.Next &#125; &#125; if l1 == nil &#123; pre.Next = l2 &#125; else &#123; pre.Next = l1 &#125; return header.Next&#125;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://blog.yunchen.tw/tags/LinkedList/"},{"name":"Modify","slug":"Modify","permalink":"https://blog.yunchen.tw/tags/Modify/"}]},{"title":"Valid Parentheses","slug":"valid-parentheses","date":"2016-10-28T16:00:00.000Z","updated":"2017-04-05T15:04:35.000Z","comments":true,"path":"2016/10/29/valid-parentheses/","link":"","permalink":"https://blog.yunchen.tw/2016/10/29/valid-parentheses/","excerpt":"","text":"Valid ParenthesesGiven a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not. 提示 解題應用 Stack LinkedList String 觀查規律 Default:123func isValid(s string) bool &#123;&#125; 解答思路:剛看到這題時就相當直覺的要用stack來做，如果曾經碰過用程式來跑四則運算的話，那一定會碰上先乘除後加減還有括號的問題，那時就是用stack來做括號及順序的匹配，果不其然和我們想的一模一樣，只是寫的時候才發現和一開始的稍有出入，原本是想先將所有字串的字元一一完全塞入stack之後再來判斷，不過這麼一來就要一一拿出再考慮似乎繞圈子，倒不如邊塞的時候就要邊做判斷，只是記得要記錄前一個你塞入的字元是什麼，才有辦法在下一個來時做判斷是否匹配。因為不曉得stack究竟會多長，所以就用LinkedList來實做，不然其實array會更簡單。 程式碼解說:因為不曉得長度，所以用節點的方式來實做，不過因為stack的操作都是在第一個節頭，所以就不用像一般的LinkedList一樣需要創一個頭、尾節點來達到對每一節點操作的一致性 1234type stackNode struct &#123; s string next *stackNode&#125; 在一一的將字串中的字元製成節點時，一邊要用tmp來儲存上一個節點中的字元以方便與下一字元做比較，如果不相同就將其做成節點塞入LinkedList並將top重新指向新節點，而上一個與目前字元的括號匹配的話就將stack中上一個字元所做的節點拿出來，同樣的這邊我並沒有去將該點的記憶體空間給釋放掉，所以也可以再加一行去處理，記得再將節點拿出來之後，因為tmp已經與目前的字元匹配了，所以要賦予tmp新的值，也就是在stack中再上一節點的字元 12345678910111213141516171819202122232425262728var top *stackNodevar tmp stringvar str stringfor _, v := range s &#123; str = string(v) if tmp == \"(\" &amp;&amp; str == \")\" &#123; top = top.next if top != nil &#123; tmp = top.s &#125; &#125; else if tmp == \"[\" &amp;&amp; str == \"]\" &#123; top = top.next if top != nil &#123; tmp = top.s &#125; &#125; else if tmp == \"&#123;\" &amp;&amp; str == \"&#125;\" &#123; top = top.next if top != nil &#123; tmp = top.s &#125; &#125; else &#123; tmp = str node := &amp;stackNode&#123;&#125; node.s = str node.next = top top = node &#125;&#125; 最後只要判斷這個stack也就是top所指向的第一個節點，如果全數匹配的話那麼應該會被一一拿出LinkedList之外，而top就會是空的，有剩餘的點就表示括號的匹配不符回傳false 1234if top != nil &#123; return false&#125;return true 完整程式碼:1234567891011121314151617181920212223242526272829303132333435363738type stackNode struct &#123; s string next *stackNode&#125;func isValid(s string) bool &#123; var top *stackNode var tmp string var str string for _, v := range s &#123; str = string(v) if tmp == \"(\" &amp;&amp; str == \")\" &#123; top = top.next if top != nil &#123; tmp = top.s &#125; &#125; else if tmp == \"[\" &amp;&amp; str == \"]\" &#123; top = top.next if top != nil &#123; tmp = top.s &#125; &#125; else if tmp == \"&#123;\" &amp;&amp; str == \"&#125;\" &#123; top = top.next if top != nil &#123; tmp = top.s &#125; &#125; else &#123; tmp = str node := &amp;stackNode&#123;&#125; node.s = str node.next = top top = node &#125; &#125; if top != nil &#123; return false &#125; return true&#125; 總結:字串中若字元與字元有兩兩相互匹配，且存在著先進後出的關係(例: {[()]} , 四則運算的前、中、後綴表達式)就用Stack來做儲存。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"https://blog.yunchen.tw/tags/Stack/"}]},{"title":"Remove Nth Node From End of List","slug":"remove-nth-node-from-end-of-list","date":"2016-10-24T16:00:00.000Z","updated":"2017-04-05T15:04:21.000Z","comments":true,"path":"2016/10/25/remove-nth-node-from-end-of-list/","link":"","permalink":"https://blog.yunchen.tw/2016/10/25/remove-nth-node-from-end-of-list/","excerpt":"","text":"Remove Nth Node From End of ListGiven a linked list, remove the nth node from the end of list and return its head. Example: 123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. 提示 解題應用 LinkedList Pointer Note: Given n will always be valid.Try to do this in one pass. Default:1234567891011121314151617/** * Definition for singly-linked list. * type ListNode struct &#123; * Val int * Next *ListNode * &#125; */func removeNthFromEnd(head *ListNode, n int) *ListNode &#123;&#125; 解答思路:非常典型的LinkedList題目，如果以前有碰過指標的話，那麼一定會接觸到這類題型，而這邊要你移除倒數第n個的節點，以 A B C D E 為例，如果給的 n=2 那我們要移除D的點，可惜此LinkedList僅是由頭往下做銜接，所以沒有辦法從尾走回頭，倒不如去想由頭來算是第幾個，以上述來說 5(總數)-2(從尾算)+1=4(從頭算) 不過我們一開始並不知道總數是多數，所以這邊我先遍歷一次整個List之後才真正去移除我們想要的節點。 程式碼解說:有寫過LinkedList的應該都知道，一開始我們先在原本的List開頭插入一個自己建立的頭節點，主要是為了確保開頭節點能與後續節點操作能一致，插好新的頭節點之後塞回原本的head變數中 12345preHead := &amp;ListNode&#123;&#125;preHead.Next = headhead = preHead 接下來就能先遍歷一次取得總數之後，就可以順便拿到從頭開始算是第幾個，這邊要記得讓head指回開頭，因為這一次的遍歷讓head走到最後頭了(all需要減1因為開頭多了一個我們自訂的節點) 12345678910111213var count intall := -1for head != nil &#123; all++ head = head.Next&#125;count = all - n + 1head = preHead 終於能移除掉目標節點，不過我只有嫁接目標節點的頭與尾，實際上並沒有真正移除掉該節點，你也可以加一行去釋放該點的記憶體，因為要嫁接前一個與後一個節點，現有的List沒辦法讓你往回跑，所以只好新增一個變數來暫存前一個節點，將 上一個節點的Next 嫁接到 目標節點的Next 跳出迴圈就可以收工了，最後回傳原本整串List的開頭，也就是一開始我們在開頭偷塞節點的下一個。 123456789101112131415161718var tmp *ListNodefor head != nil &#123; count-- tmp = head head = head.Next if count == 0 &#123; tmp.Next = head.Next break &#125;&#125;return preHead.Next 完整程式碼:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647func removeNthFromEnd(head *ListNode, n int) *ListNode &#123; var count int var tmp *ListNode preHead := &amp;ListNode&#123;&#125; preHead.Next = head head = preHead all := -1 for head != nil &#123; all++ head = head.Next &#125; count = all - n + 1 head = preHead for head != nil &#123; count-- tmp = head head = head.Next if count == 0 &#123; tmp.Next = head.Next break &#125; &#125; return preHead.Next&#125; 總結:對於一個從頭單向的LinkedList來說，如果要移除從尾來算的節點，倒不如先遍歷取總數後來算出從頭算為第幾個: (總數)-(從尾算)+1=(從頭算) 對於LinkedList來說，可以在頭或尾插入一個自訂的節點來確保頭或尾節點的操作能和其它節點一致。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://blog.yunchen.tw/tags/LinkedList/"},{"name":"Pointer","slug":"Pointer","permalink":"https://blog.yunchen.tw/tags/Pointer/"}]},{"title":"Longest Common Prefix","slug":"longest-common-prefix","date":"2016-10-22T16:00:00.000Z","updated":"2017-04-05T15:04:12.000Z","comments":true,"path":"2016/10/23/longest-common-prefix/","link":"","permalink":"https://blog.yunchen.tw/2016/10/23/longest-common-prefix/","excerpt":"","text":"Longest Common PrefixWrite a function to find the longest common prefix string amongst an array of strings. 提示 解題應用 String Prefix String Default:123func longestCommonPrefix(strs []string) string &#123; &#125; 解答思路:原本以為是要實作類似KMP這種字串比較來解答，結果題目不是找單一字串中前後綴最長的字串，而是更加單純，在字串陣列中找相同且最長的前綴字串，既然點出了前綴就表示要找相同的字串一定位置、順序在開頭都一模一樣，所以就一個一個位置檢查該字是否相同。 Example: 12strs: [&quot;ababa&quot;,&quot;aba&quot;,&quot;abc&quot;]return: &quot;ab&quot; 程式碼解說:去掉題目所給預想狀況外的參數，像是空字串 123if len(strs) == 0 &#123; return \"\"&#125; 剩餘的就相當單純的一字一字比較，先抽出第一個字串並以其一字一字與其它字串做比較，這邊比較要注意的是第一個字串有可能比其它字串來的長，要判斷index的值不能比其它字串長度長，然後只要發現字元不相同就可以跳出迴圈了，因為迴圈有兩層所以在外面的迴圈才加上了一個flag來判斷，最後把 index+1 拿到前綴的長度就可以知道結果了。 1234567891011121314151617181920var result intfirst := strs[0]flag := falsefor index, s := range first &#123; for _, str := range strs[1:] &#123; if index &lt; len(str) &#123; if string(s) != string(str[index]) &#123; flag = true break &#125; &#125; else &#123; flag = true break &#125; &#125; if flag &#123; break &#125; result = index + 1&#125; 完整程式碼:1234567891011121314151617181920212223242526func longestCommonPrefix(strs []string) string &#123; if len(strs) == 0 &#123; return \"\" &#125; var result int first := strs[0] flag := false for index, s := range first &#123; for _, str := range strs[1:] &#123; if index &lt; len(str) &#123; if string(s) != string(str[index]) &#123; flag = true break &#125; &#125; else &#123; flag = true break &#125; &#125; if flag &#123; break &#125; result = index + 1 &#125; return first[:result]&#125; 總結:Prefix為字串中的開頭，同樣要在其它字串找一樣且最長的話，直接從位置一個個對照確認，因為要的只是開頭一樣。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"}]},{"title":"Roman to Integer","slug":"roman-to-integer","date":"2016-09-14T16:00:00.000Z","updated":"2017-04-05T15:04:01.000Z","comments":true,"path":"2016/09/15/roman-to-integer/","link":"","permalink":"https://blog.yunchen.tw/2016/09/15/roman-to-integer/","excerpt":"","text":"Roman to IntegerGiven a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 提示 解題應用 Math 規律觀察 String 規律觀察 Default:12func romanToInt(s string) int &#123;&#125; 解答思路:對於沒碰過羅馬數字的人來說，可能要先去查查羅馬數字的規則才有辦法將問題給寫出來，所以第一件要做的事便事去搜尋羅馬數字並觀查其規律，不過所幸給予的數字並非無限大，所以只需觀查1~3999的範圍即可，而我們可以得知: 個位數字母規律1: I 2: II 3: III 而到5的倍數前一個數字便是以 (5n - 1) 的方式做表達(要相減的數字放置於前面) 4: IV (5n - 1) 5: V 5的倍數之後到下一個倍數之前便是以 (5n + 1) 的方式做表達(要相加的數字放置於後面) 6: VI 7: VII 8: VIII 9: IX (5n - 1) 10: X 10的倍數字母規律10: X 20: XX 30: XXX 而到10的倍數前一個數字便是以 (10n - 10) 的方式做表達(要相減的數字放置於前面) 40: XL 50: L 10的倍數之後到下一個倍數之前便是以 (10n + 10) 的方式做表達(要相加的數字放置於後面) 60: LX 70: LXX 80: LXXX 90: XC (10n - 10) 100: C 以此類推 最後只要曉得500與1000的字母便已經有寫出羅馬數字1~9999的能力了 500: D 1000: M 整理一下全部羅馬字母大小順序的話會得到: M → D → C → L → X → V → I 到這邊我想到的作法便是將問題所給予的羅馬數字從頭開始分拆來看，我們可以發現到與千位數有關的就是M，因為數字不會到5000，所以基本上不用擔心千位數的變化，百位數有關的就是D與C了，如果在讀百位數的羅馬數字DC時若是先C再往下卻又是比較大的D時，此時就要相減 CD: (500-100) ，繼續往下走碰到十位數的LX時，就可以曉得百位數字合就到此為止了，而如果是X再往下卻又是百位數字的C，便可以曉得此時為 XC: (100-10) 以此類推。 此時再稍思考一下便可知道: 如果下一個字母小於當前字母就與總合相加，否則就要與總合相減。 程式碼解說:首先我們至少需要先把每個羅馬符號對應哪個數字記錄下來，你可以用常數定義好再用switch去取出值，或是像有些語言有enum(列舉)再去用switch取出，而這邊我就直接用map來存取比較方便。 12345678roman := make(map[string]int)roman[\"I\"] = 1roman[\"V\"] = 5roman[\"X\"] = 10roman[\"L\"] = 50roman[\"C\"] = 100roman[\"D\"] = 500roman[\"M\"] = 1000 關鍵就在於這段，只是將上述得到的結論實作出來，如果下一個字母小於當前字母就與總合相加，否則就要與總合相減，這邊要注意一下當到最後一個羅馬符號的時候就沒辦法在拿下一個符號了，這時就直接將結果與總合相加即可。 12345678910111213for key, value := range s &#123; r = roman[string(value)] if key+1 &lt; slen &#123; nr = roman[string(s[key+1])] if r &gt;= nr &#123; sum += r &#125; else &#123; sum -= r &#125; &#125; else &#123; sum += r &#125;&#125; 完整程式碼:12345678910111213141516171819202122232425262728func romanToInt(s string) int &#123; roman := make(map[string]int) roman[\"I\"] = 1 roman[\"V\"] = 5 roman[\"X\"] = 10 roman[\"L\"] = 50 roman[\"C\"] = 100 roman[\"D\"] = 500 roman[\"M\"] = 1000 sum := 0 slen := len(s) var r int var nr int for key, value := range s &#123; r = roman[string(value)] if key+1 &lt; slen &#123; nr = roman[string(s[key+1])] if r &gt;= nr &#123; sum += r &#125; else &#123; sum -= r &#125; &#125; else &#123; sum += r &#125; &#125; return sum&#125; 總結:羅馬符號轉數字: 從字串開頭一一取出字元，如果當前字母大於下一個字母就與總合相加，否則與總合相減。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"Palindrome Number","slug":"palindrome-number","date":"2016-09-09T16:00:00.000Z","updated":"2017-04-05T15:03:34.000Z","comments":true,"path":"2016/09/10/palindrome-number/","link":"","permalink":"https://blog.yunchen.tw/2016/09/10/palindrome-number/","excerpt":"","text":"Palindrome NumberDetermine whether an integer is a palindrome. Do this without extra space. Some hints: Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. 提示 解題應用 額外的Package Math 字串、型別 strconv Default:12func isPalindrome(x int) bool &#123;&#125; 解答思路:回文，從文本前面讀起或從後面往回看兩者的結果都會一樣，例如:abcba，此題是以數字來做回文，所以我們馬上就可以知道如果收到的值為負數，則必不可能回文，總不可能丟進來的值是-12321-這種搞笑值吧!而檢查方式我想很容易就可以想到，只要以對稱的方式來做檢查，即頭對尾以此類推便可以很容易搞定。 程式碼解說:將數字轉換成字串之後，從頭一一取值去與尾數(index: 長度-(index+1)) )做比較，若發現不一樣就直接回傳false直到整個流程沒有問題才回傳true。 12345678str := strconv.Itoa(x)slen := len(str)for key, value := range str &#123; if value != rune(str[slen-(key+1)]) &#123; return false &#125;&#125;return true 完整程式碼:1234567891011121314func isPalindrome(x int) bool &#123; if x &lt; 0 &#123; return false &#125; else &#123; str := strconv.Itoa(x) slen := len(str) for key, value := range str &#123; if value != rune(str[slen-(key+1)]) &#123; return false &#125; &#125; return true &#125;&#125; 總結:回文，以前、後對稱的方式做檢查即可。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"Reverse Integer","slug":"reverse-integer","date":"2016-09-09T16:00:00.000Z","updated":"2017-04-05T15:03:49.000Z","comments":true,"path":"2016/09/10/reverse-integer/","link":"","permalink":"https://blog.yunchen.tw/2016/09/10/reverse-integer/","excerpt":"","text":"Reverse IntegerReverse digits of an integer. Exmaple1:1x = 123, return 321 Exmaple2:1x = -123, return -321 Have you thought about this? Here are some good questions to ask before coding. Bonus points for you if you have already thought through this! If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100. Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases? For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 提示 解題應用 額外的Package Math 字串、型別 math、strconv Default:12func reverse(x int) int &#123;&#125; 解答思路:這次很單純我直接採用字串的方式來做處理，不過因為go會幫你將輸出的int轉成是int64，所以他給的測試值不會overflow，所以我才再載入math的package去取得int32的最大與最小值來判斷是否溢位，有點像是用大炮打小鳥的概念，另外這邊之所以還用上另一個strconv是因為如果直接將數字轉字串，我想結果大家應該都曉得會拿到ascii轉出來的字串，當然如果你不想要使用上述兩個package，另外一種解法就是將數字%10取餘數(尾數)，接著再將原數/10後再重覆上述行為直到將每一位數取出，只不過這邊就還要再一組回圈將每一位數一一*10^n加回成總數，照自己喜歡的方式處理，不過如果是負數的話記得要在index為0的時候做判斷取出。 程式碼解說:go的strconv提供我們能直接將數字轉字串與字串轉回數字的方法，前者能直接拿到結果，後者會多回傳一個error以此來判斷字串能否順利轉成數字。 12str := strconv.Itoa(x)i, err := strconv.Atoi(string(result)) 因為go將字串轉成數字是所儲存的型別為int64，而問題所要的溢位情況是int32，所以我們載入math藉以取出該儲存單位的上界與下界值來判斷經轉換後能否存入int32，若是直接以int32(int64)強制轉化的話，超出的位元數會直接被捨棄掉只取前面32位元。 123if err != nil || i &gt; math.MaxInt32 || i &lt; math.MinInt32 &#123; return 0&#125; 完整程式碼:12345678910111213141516171819func reverse(x int) int &#123; str := strconv.Itoa(x) slen := len(str) result := make([]rune, slen) for key, value := range str &#123; str = string(value) if key == 0 &amp;&amp; str == \"-\" &#123; result[key] = rune(value) &#125; else &#123; result[slen-1] = rune(value) slen-- &#125; &#125; i, err := strconv.Atoi(string(result)) if err != nil || i &gt; math.MaxInt32 || i &lt; math.MinInt32 &#123; return 0 &#125; return i&#125; 總結:倒數想到的做法有兩種: 數字轉字串方式處理 數字取餘數做倒數後，一一乘上十的倍數做總合","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"Math","slug":"Math","permalink":"https://blog.yunchen.tw/tags/Math/"}]},{"title":"ZigZag Conversion","slug":"zigzag-conversion","date":"2016-09-07T16:00:00.000Z","updated":"2017-04-05T15:03:22.000Z","comments":true,"path":"2016/09/08/zigzag-conversion/","link":"","permalink":"https://blog.yunchen.tw/2016/09/08/zigzag-conversion/","excerpt":"","text":"ZigZag ConversionThe string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) Exmaple:123P A H NA P L S I I GY I R And then read line by line: “PAHNAPLSIIGYIR”Write the code that will take a string and make this conversion given a number of rows: 1string convert(string text, int nRows); convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”. 提示 解題應用 String 觀查規律 Default:12func convert(s string, numRows int) string &#123;&#125; 解答思路:numRows = 3最初的想法是拆成三大塊分上、中、下，第一列PAHN就是利用 nRows+1(4) 為index的倍數放到array開頭，接著到第三列YIR同上 nRows-1(2) 的倍數放到array尾端，中間就只要將上述剩餘的依序放入，因為就算經過convert，如果仔細觀查橫的輸出好比YIR，這三個字元在原本的PAYPALISHIRING字串出現的順序不變，所以不用擔心，至於這三大塊該如何塞入同一array的位置，從上塊來說只要符合倍數就原本 array[index/(numRows+1)] 放入，而下塊也是符合倍數就 array[len(s)-len(s)/(numRows+1)] 中間的只要知道上塊的index到哪從後頭接著放入就對了。 顯然我完全搞錯了ZigZag的重點… 所以最初想法不看也沒差。 這裡給的範例實在太少，很可能會因為沒接觸過導致不清楚什麼是ZigZag而寫的方向錯誤，所以再附上一些結果來讓人了解。 Example: 12345numRows = 4P I NA L S I GY A H RP I 123456numRows = 5P HA S IY I RP L I GA N 花點時間應該可以看出有特殊規律，不過看討論這類的題目在面試上沒什麼太大意義，所以通常不會出現的樣子。從最初的想到的來看我也許能夠拆成上、中、下塊，只是這次的中塊大了點，不過似乎有更好的做法，拆成直線↓一組與斜線↗一組，以 numRows=4 來說，PIN ASG YH PI為直線↓，LI AR為斜線↗ (直線規律)第一排的PIN為例，P與I的indx變化(經過點)可以發現: 原點 直線↓剩餘數 斜線↗數 直線↓剩餘數 P AYP AL I index numRows - (index + 1)%(numRows + (numRows - 2)) numRows - 2 (index + 1)%(numRows + (numRows - 2)) 合併之後下一點的index index = index + numRows - (index + 1)%(numRows + (numRows - 2)) + numRows - 2 + (index + 1)%(numRows + (numRows - 2)) = index + 2*(numRows - 1) 另外也可以發現到只有 numRows=2 時，沒有任何的斜點，因為斜線數 (numRows-2=0) 。 123numRows = 2P Y A I H R NA P L S I I G 至於 numRows=1 根本跟問題給的字串一樣，所以在最一開始就要篩掉。 12numRows = 1P A Y P A L I S H I R I N G (斜線規律)看來沒辦法像直線一樣直接得到絕對位置簡單，只好從直線的相對位置找起(numRows=4為例): 在上一個直線規律中我們從 P→I 找關係，而這次我們則要找直線與斜線的相對關係，所以就找 A→L ，不過後來反而發現 A→S→L ，是有脈絡可尋的，而且 S→L 之間的關係與該兩點所在的行數(第幾橫排)有密切關係。 row為該兩點所在的行數 原點 中點 斜點 A S L index 2*(numRows - 1) -2(row - 1) 其中原點到中間我們可以由先前直線規律求得，合併之後斜點的index: index = index + 2*(numRows - 1) - 2(row - 1) 程式碼解說:在go中，從字串提出的字元型別都是rune，你可以想成是直接轉成ascii，最大的好處在於最後將這些rune陣列轉成string回傳時，你不需要一個個去join到空字串裡頭，而是將整個rune陣列直接轉成string，非常的方便且快速。 1result := make([]rune, slen) 這邊我用index的0~numRows來取出每一橫排的第一個值，而next就是套前述所提的直線與斜線規律所整理出的結論，因為我是從0開始算橫排，所以就不需 (row-1) ，透過觀察例子我們可以發現斜點不會與第一橫排 (index=0) 和最後一排 (index=numRows) 同一排，在找斜點的相對位置時也有可能是中點不存在而斜點存在，這些都要在最後的判斷式過慮。 123456789101112for i := 0; i &lt; numRows; i++ &#123; next = i for next &lt; slen &#123; result[j] = rune(s[next]) j++ next = next + 2*(numRows-1) if i &gt; 0 &amp;&amp; i &lt; numRows-1 &amp;&amp; next-2*i &lt; slen &#123; result[j] = rune(s[next-2*i]) j++ &#125; &#125;&#125; 完整程式碼:12345678910111213141516171819202122func convert(s string, numRows int) string &#123; if numRows == 1 &#123; return s &#125; slen := len(s) result := make([]rune, slen) next := 0 j := 0 for i := 0; i &lt; numRows; i++ &#123; next = i for next &lt; slen &#123; result[j] = rune(s[next]) j++ next = next + 2*(numRows-1) if i &gt; 0 &amp;&amp; i &lt; numRows-1 &amp;&amp; next-2*i &lt; slen &#123; result[j] = rune(s[next-2*i]) j++ &#125; &#125; &#125; return string(result)&#125; 總結:ZigZag就是將一字串做鋸齒狀排列來讓你找出規律。 (直線規律)絕對位置 index = index + 2(numRows - 1) (斜線規律)相對位置 index = index + 2(numRows - 1) - 2(row - 1)","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"String","slug":"String","permalink":"https://blog.yunchen.tw/tags/String/"}]},{"title":"Two Sum","slug":"twosum","date":"2016-09-04T16:00:00.000Z","updated":"2017-04-05T15:03:11.000Z","comments":true,"path":"2016/09/05/twosum/","link":"","permalink":"https://blog.yunchen.tw/2016/09/05/twosum/","excerpt":"","text":"Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution. Exmaple:1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 提示 解題應用 Hash Table Hash Map Array Array/Slice Default:12func twoSum(nums []int, target int) []int &#123;&#125; 解答思路:剛開始看到題目的時候因為沒有\b細想，單純從提示來看的話我馬上就往錯誤的方向解答，使得一開始寫的很糟最初的想法是例用 nums[key]%target 取餘數的方式來為hashtable做分類，整除就放進Array[index]為0的位置，餘1就放進index為1以此類推，當然這樣做也是個方式但是target有可能是0，也就產生了分母為0而error的情況，此外就算是前述解決還有負數的情況要考量， 1%8=1 但是 1%-8=-7 為了要解上述問題只會讓無關的code越做越糟，所以倒不如用減的，將 target-nums[key] 不過這麼一來就沒辦法用index來做為分類(bucket)的依據，因為數字會很大所以就改用Map的方式來實現。 程式碼解說:這邊我特別用struct來將當前nums的資料做儲存，不這麼做的話經由array分類之後就算已經知道了哪組數字合可以得到結果，但是結果需要的是你回傳該值於nums的index，總不能再將這組數字再拿到nums做搜尋也太浪費時間。 1234type hash struct &#123; index int value int&#125; 這邊要注的是在Go語言中，如果初始化資料有巢狀的情況，好比map裡頭又有map或是map裡頭有array等等的話，在Go只初始化了最外層，也就是說你必需要在當需要使用內層的時候，寫一個判斷式來確定裡頭是不是分配了空間，沒有的話就要再對裡頭make一次。 12345hashTable := make(map[int][]hash)_, ok := hashTable[k]if !ok &#123; hashTable[k] = make([]hash, 0)&#125; 最後可能會遇到一種狀況是進來的資料有重覆，好比target是0有可能nums裡面有兩個0，所以在上一點我初始化資料時每個map裡頭才又包了array，不過因為題目有明確的說明只有一組結果的關係，所以這種重覆的值如果剛好又是結果的話，在array裡頭肯定長度是2，雖然我還是用 len(value) 來判斷，不過敘述就直接指明該index了 123456789if ok &amp;&amp; key != target-key &#123; result[0] = value[0].index result[1] = v[0].index break&#125; else if ok &amp;&amp; len(value) &gt; 1 &#123; result[0] = value[0].index result[1] = value[1].index break&#125; 完整程式碼:1234567891011121314151617181920212223242526272829func twoSum(nums []int, target int) []int &#123; type hash struct &#123; index int value int &#125; hashTable := make(map[int][]hash) result := make([]int, 2) for key, value := range nums &#123; k := target - value _, ok := hashTable[k] if !ok &#123; hashTable[k] = make([]hash, 0) &#125; hashTable[k] = append(hashTable[k], hash&#123;key, value&#125;) &#125; for key, value := range hashTable &#123; v, ok := hashTable[target-key] if ok &amp;&amp; key != target-key &#123; result[0] = value[0].index result[1] = v[0].index break &#125; else if ok &amp;&amp; len(value) &gt; 1 &#123; result[0] = value[0].index result[1] = value[1].index break &#125; &#125; return result&#125; 總結:若在一串無序數字中需要找一組數字，且此組數字有一定的1對1關係用HashTable來分類實作。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://blog.yunchen.tw/tags/LeetCode/"},{"name":"Go","slug":"Go","permalink":"https://blog.yunchen.tw/tags/Go/"},{"name":"HashTable","slug":"HashTable","permalink":"https://blog.yunchen.tw/tags/HashTable/"},{"name":"Array","slug":"Array","permalink":"https://blog.yunchen.tw/tags/Array/"}]},{"title":"JSDC2015 學生獎勵計畫心得","slug":"jsdc2015-student-awards-experience","date":"2015-10-05T16:00:00.000Z","updated":"2017-04-05T15:02:48.000Z","comments":true,"path":"2015/10/06/jsdc2015-student-awards-experience/","link":"","permalink":"https://blog.yunchen.tw/2015/10/06/jsdc2015-student-awards-experience/","excerpt":"","text":"若有錯誤歡迎大家指教&lt;( )&gt; 本篇為學生獎勵計畫給JSDC的心得報告 這次很榮幸可以通過JSDC學生獎勵計畫 自從Modern Web Conf之後越來越多都有設定鼓勵學生的方案 不然一張票可能就是一個學生一個月的國科會或助教的薪水了 藉由這次的機會讓我終於第一次參加JSDC 如果要跟Modern Web Conf收獲相比 JSDC參加完之後會讓手很癢…什麼技術都想玩一下 所以可以算是推坑React,Native,Electron,IOT等等的大坑阿… 以下是我這次的心得 若有錯誤歡迎大家指教&lt;( )&gt; 今年辦的活動從拿到紀念品的小提袋就有一種很超值的感覺 不過當我在前一天想要安排該跑哪些議程的時候 卻發現官網都沒有簡介 現場拿到的手冊，以為裡面會有議程簡介及贊助商資訊等等 不過一打開發現全白的讓我有些小錯愕XD 原來這是本筆記本阿~ 一早大會螢幕上有放簡介 不過因為光亮+螢幕模糊 後來經宣傳才在hackfolder上找到資訊 另外還是相當不習慣議程大多數的門只出不進的規畫 上個廁所可能都要跑一大圈(汗) 最後一定要提一下 JSDC的食物真的都超級好吃阿阿阿阿阿阿!! 我是沒有任何的狀況 點心和午餐都吃的相當的滿足(覺得幸福) JSDC議程內容、共筆及投影片: JSDC [R0+R2] React Navigation System大家在寫SPA的網頁都會碰到一個問題 就是route的問題 雖然一切頁面、元件動態載入看起來很美好，可是這也有個問題 當使用者切換頁面、標籤等等時，route的path仍然是一樣的 這也意味著當使用者 將你的application點到相當深的UI介面的時候，一個不小心重新整理或上一頁 將一切重新來過，他可能又要重新去一個個點開才能到達他所要的地方 所以我們在寫網頁時可以透過history來抓取這些曾造訪的歷史資訊 但如果是元件的變動你就要自行去做這個所謂的”導航”系統 而網頁上的url通常 是線性在變動，但如果是原生的APP就是巢狀再做改變 因此就更加複雜 寫Native的APP就更需要去刻一個導航系統來處理返回鍵等動作 這也是Facebook React Native對未來規畫可能會要做的事情 [R2] JavaScript 開發流程自動化懶人包平常我們使用Git都只有做版本控制，而git hooks例如:pre-commit 你可以在commit前跑一隻程式來檢查這次的程式碼是不是符合團隊的規範或風格 如果在搭配Jenkins-CI跟mocha會讓這一切看起來更加流暢 不過可能會有人覺得這是在浪費時間，但以一個大型專案或長遠來看，這是一個相當值得的投資 不過我們在學校通常沒什麼機會會碰到，我也是出來參與專案才首次接觸，測試全過的感覺真的潮爽der! 另外也介紹了一些實用的小工具 像usersnap、nightwatch等等相當的方便 [R2] 用JavaScript實現微電腦自動控制不是夢！這場講者有木工的背景，再加上Arduino的低門檻，讓他可以很容易的結合自己的專長 成為Maker的一份子，整份投影片相當的入門，對於完全對Arduino陌生的人來說是不錯的入門 不過可惜的是沒有分享很深入細節，好比自己專長的木工其實可以多介紹一些 因為底下相信絕大多數至少都玩過LED燈炮閃爍及馬達等等，反而讓後面的部面沒時間細談到 不然機器人手臂的例子真的相當的有意思 [R0+R2] Building Single Page Apps with Aurelia講師怕大家不曉得Aurelia，前面的時間大多在做介紹 大家都超擔心最後沒時間做demo Aurelia是由前Angular.js開發者出來打造 所以你可以在Aurelia看到相當多熟悉的影子 不過看到又有一個感覺… 怎麼前端又有新的framework了T_T two-way binding 和 {markup injection}等等保留一些在開發上有彈性的部分 至於我們可能會懷疑會不會有效能上的問題 據本人說沒問題就是XD 不過因為投影相當的模糊 所以DEMO的部分大多數都沒看清楚 只能自己親自試著去跳坑來體驗了 [R2] 技術演進的大亂鬥因為slidenow也有參與開發 這之間有太多血淚T_T 剛用Angular.js寫好後 最後還是敗給了Animation在手機上顯示相當的糟糕而轉向了React.js 結果React.js也有不少問題，SVG的attribute不支援、CSSTransitionGroup的bug 當初大家所推薦的isomorphic framework二個月後又就不一樣了 雖然將產品投到新技術需要相當大的勇氣跟心臟 但就一個資訊人來說這也算是他們對技術的熱情XD 所以就一邊抱怨一邊像拿到新玩具的心情開發 相當的矛盾XD [R0] Transducer原來今天是講數學而不是JSDC XD 因為完全沒碰過相關的運算研究? 對我來說這場算是最痛苦的一場 提到了非常多的數學式範例和分享，我想對做相關研究的人可能會眼睛一亮吧 不過因為完全聽不懂(嘆) 果然自己還是太嫩了 [R0] TDD 的開發哲學，以 nodejs 為例分享一些職場上開發的測試分工與合作，測試這件事不是只是QA的事，開發者也要共同參與 才能更快的找出問題，而不是讓這些時間卡在問題的轉述與推託上 即然是node.js 當然會提到mocha及假資料登入的處理 還是不能不提的Jenkins CI 講師認為完美的專案就是容易改善才能夠長期持續下去 [R0] Web Components &amp; the next generation ADs第一天的最後一場當然要聽老木大師的演講，錯過就真的太可惜了 自從在Modern Web Conf第一次聽了之後 明明是平淡無奇的測試也可以被講的相當的精彩 比起介紹的內容，更想知道國文老師是誰(誤） 這場介紹了Web Components的特性，如果已經有在摸React.js想必相當有感 所有元件環環相扣而且可重覆使用 我想這就是元件化之後最迷人的地方 而元件當然也可以測試，同時藉機酸了一下「X關閉廣告」是可以被關掉的 哈 [R0] Three.js, WebGL &amp; Tooling講師是Three.js開源貢獻者之一，現今也有遊戲公司採用Three.js做網頁遊戲的開發 開場也demo了幾款遊戲，很順60fps沒問題不會lag不會讓人被暴力~ 也用簡單的比喻解釋投影的四步驟讓大家盡可能的了解實作的方式 [R0+R2] Build Anything with JavaScript這場在先前的Modern Web就已經有介紹過一次了，而講師這次帶來更多實作的成果來展示 以馬克一號來製做遙控氣球及遙控車，最主要是希望能夠讓前端工程師能夠更簡單的進入 Arduino來開發，不過就我認為而言，如果我有基本寫程式的經歷和底子，最後還是會選擇c/c++來開發， 畢竟Arduino的門檻已經降至相當低了，雖然我喜歡寫Js不過也不至於一定都要以Js來開發 這終究還是要看每個人寫程式與學習的習慣吧~ [R0] React Native 實戰! 融入現有 iOS App講者原本以React Native來整合至現有的iOS專案，沒想到在JSDC前居然連Android版都公佈了， 於是就幫大家先跳坑做嘗試並分享心得，提到了傳統WebView有效能不佳及相容性的問題，現有專案 因為UI變化很快及debug後上架時間過長，因而決定採用React-Native 分享一些自己所觀查到的React-Native的實作方式，其實就像是翻譯米糕(JsBridge)一樣，透過翻譯米糕 由js與原生api做溝通，而只要能在不同平台打造這個翻譯米糕就能夠用js寫出原生的app 最後展示趨勢所使用的app來整合Android與iOS並公開兩者之間的code，兩邊的code看起來幾乎一模一樣 聽到這邊讓人感到超心動的，所以就被推坑想寫了XD 不過現階段的挑戰在於低階機型會有效能上的問題 這個只能藉由時間來改善，另外Apple Store的審核尚未對這類的APP有任何限制，但不代表未來不會有動作 就算是這樣React Native潛力還是相當另人感到心動 [R0+R2] Workshop on Control Flow ES2015 and beyond講師分享一些非同步請求的function在未來會被整合到ES7中，並分享一些解決現況Promise的作法 因為講師的時間是workshop很長，偏偏講完時間還剩很多，這倒是讓大家抓到一個機會 問了非常多開發上好用的套件，光是這場Github按的star可能就多了十個左右 連console.log來debug都有專門的套件叫DEBUG處理，相當的有意思 讓我聽到很多實用的套件 算是在聽這場演講之前完全沒想到的收獲吧 [R0] Building Hybrid Mobile Apps with Ionic Framework and AngularJS大多的著墨在於AngularJS 1.X的部分，本來還以為會談Angular2 不過畢竟2也還不成熟 或許剛好完全略過或沒摸過1的人可以回首看看這段血淚史? 不過如果能夠提到更多Ionic整合 的部分會更好XD [R2] 使用 Electron 跨平台建構 JavaScript 桌面程式第二天最後一場一直滿期待聽到這場，之前一直有耳聞Electron，甚至在Dcard上相當有名 寫給女朋友的音樂播放程式也是用這套完成，如果想要寫一個小工具的視窗程式，用Electron來實作 非常的酷XD 算是在React-Native整合分享之後又心動手癢想嘗試的東西之一 講師很仔細的回答browser process&amp;ipc&amp;render process，聽完馬上有種頭骨蓋靈光乍現的感覺 而在Lighting Talk之後也有人發表Electron+React+Webpack整合的環境 都有人做到這樣了那就趕快動做~ 今年的JSDC整體來說還不錯，除了只出不進有點小麻煩之外，部分的休息時間其實也可以縮短 畢竟20分鐘真的有點長，另外可以考慮有跑攤位的活動，這樣可能會更有意願去與贊助商互動 微軟的實習生就不用那麼可憐整天都要到處問XD 明年這個時間就不是學生了，可能要當兵也沒機會參加 總而言之希望明年也可以越辦越好，讓更多人知道Js的坑有多大(笑","categories":[],"tags":[{"name":"jsdc","slug":"jsdc","permalink":"https://blog.yunchen.tw/tags/jsdc/"}]},{"title":"Linkit One 開發心得","slug":"linkit-one-development-experience","date":"2015-08-04T16:00:00.000Z","updated":"2017-04-05T15:02:38.000Z","comments":true,"path":"2015/08/05/linkit-one-development-experience/","link":"","permalink":"https://blog.yunchen.tw/2015/08/05/linkit-one-development-experience/","excerpt":"","text":"前言感謝MTK聯發科提供機會讓我有幸能參予Linkit One的測試 這是我在這一段時間的體驗，其中包含了很多我自己的看法，若有不足之處還請多包涵~ 因為已經有相當多的開箱文及介紹 所以我大多只紀錄一些比較印象深刻的地方囉! 希望能藉由這篇心得快速的來帶大家認識Linkit One及上手開發~ 如果有任何問題或指教歡迎來信: yunchen@nisra.net 本篇心得 優點 定位 問題 LinkitOne &amp; Socket 總結 &gt; Linkit One 過去有玩過Arduino Uno所以當發現Linkit One時，有種很親切的感覺 可以說是衝著廣大Arduino族群來的，能否獲得青睞還有待觀查 絕大多數能在Arduino執行的範例都能相容到Linkit One執行 少數專案只需要小量修改(部分library)便可以無痛轉移~ 甚至連IDE都可以相容~ Code可能只微調25%左右 然而底層的實作可能大不相同 (這句話最近有點耳熟…? 錯覺吧?) 不過Linkit One核心因為涉及商業機密所以沒辦法完全 Open Source 這點要知道一下~ 優點上述提到大多數的code與IDE相容之外 Linkit One有的還提供一些進階lib讓你可以做更細膩的操作 以呼吸燈會用到的analogWrite為例: analogWrite 只提供 0~255的調整 **analogWriteAdvance** 可以 0~1023 目前正式支援了Windows &amp; OSX已有人實際hack出Linux的開發環境(非官方) 不過相信不需要太長的時間三大平台就都能夠加入Linkit One的開發 &gt; Linkit One 支援OSX開發環境 使用Linkit One的好處之一就是，大部分在開發的情況下我可能會使用到的模組 已經在開發版上，所以開發版一到手上，接上感測元件就可以進行資料傳輸~ 這相當方便 有點像是All in One的感覺，列出一些玩過後比較有印象的部分~ - GSM: 發簡訊、行動上網、打電話 - Wifi上網 - 藍芽傳輸 - GPS - SD卡 上述提到的部分都是已經附帶在Linkit One之中(附贈模組要接上) &gt; 背面: 可供SIM卡、SD卡插入 另外也是MTK一直想強調的點XD 就是記憶體比較大，連SSL加密傳輸都可以支援! 定位開發者們往往容易忽略了硬體實際產品化的問題及難度，所以MTK推廣Linkit One最主要的目的 並不是要打造MTKLab的自我品牌，而是希望能夠透過聯發科的資源協助開發者們尋找廠商， 能夠做到小量的產品化並進行創業，讓實際問題的解決方案變的可行 這也是為什麼在Linkit One上，像是把電流壓低至手環能接受的程度等等的做法 可是對開發者來說呢? Linkit One的一些設計可能不見得是部分開發人員想要的 就像有人會覺得電流太小 需要外接電源，而非是以手環為準，可能是其它物聯網裝置 通訊功能是MTK的強力主打，雖然人手一機，但現階段需要有多的SIM卡來插在物聯網裝置上，可能不是使用者樂見 不過能藉機把玩一下通訊功能也是一個不錯的經驗啦XD 說到這個倒讓我想到大二曾經在Server端或APP上用Python玩過發送電話及簡訊 Python-Kivy-Nexmo 下面有兩家比較有名的服務商: Nexmo: https://www.nexmo.com/pricing/ Twilio: https://www.twilio.com 申請後可以拿到約200封免費的簡訊扣打，不過一封頂多換算約台幣0.3~0.5 所以也不太痛～ 這頂多算是我預想得到要用上通訊的硬幹玩法XD 應該不太可能真的這樣搞… Linkit One可能被擺在天邊某一角又沒網路不過電信服務剛好有訊號 需要透過Server跟它溝通去觸發某件事 或許最終手段就是發簡訊來讓它收到XD 當然是少量間隔長適用…不然簡訊送太多心會痛 期待也許有人有其它惡趣味的玩法也說不定 哈 Linkit One的CP值很高，主打Arduino相容，但對於廣大的Arduino族群或不少Maker來說 目前Linkit One許多的功能要在Arduino上做到也不算太難，再加上價格相對高些， 反而使得Linkit One處在一個相當尷尬的狀況下，這就得看未來MTK是否能讓Linkit One的定位有所區別 當然相容於Arduino也會伴隨著開發環境問題跟包袱存在，好不好就看人了 或許將Linkit One最小化到極致是個不錯的選擇，我妄想著開發可能超級麻煩，開發時什麼都要外接， 麻煩歸麻煩，開發者只要不是bug就不是問題，可能3D列印外殼然後直接將Linkit One包裏至其中 就直接當作成品來向大家穿戴展示，一般DEMO其實也都這麼做，也許可能與最終產品有所出入、看起來稍為大點， 但是至少在穿戴展示不會那麼大一塊，”看起來”似乎那麼可行，或許DEMO就更有說服力 不過這都只是癡人說夢XD 可能都有考量過跟其它難度在，總之MTK加油吧! 問題1一般接觸新的技術與事物我習慣直接去看Document與Tutorial 然而Linkit One的Developer Guide仍然停在相當舊的版本，這也使得我最初碰上相當多的問題…快更新啦T_T 我目前的環境是 OSX Yosemite 10.10 Arduino IDE 1.6.4 LinkIt SDK 1.1.09 Beta 下述狀況皆以OSX環境為例 那最初參照Developer Guide在OSX上裝Linkit SDK及驅動 都有狀況發生，後來才在MTK討論區找到可行解法 建議新加入的朋友對Linkit One有任何問題或者第一次使用，不如就直接到這裡去找最新的解決辦法 任何的最新進度或者還是測試階段的SDK都會在置頂文章 https://labs.mediatek.com/forums/posts/list/559.page 不過一段時間後其它OSX使用者在安裝上發生了 因為產生302跳轉導致讀不到而驅動裝不起來Orz 我相信之後會陸續修正這些狀況，希望MTK能夠盡處理及穏定開發環境 2 &gt; code:9600, console:19200 鮑率不管是設多少 第一次打開資源監控預設狀況下都看得到…就算不一樣也ok(好貼心XD) 除非監控去做切換才回復正常，不過如果記得沒錯，切換到當初的debug port就沒有這個問題 3 &gt; 最早有分 Debug &amp; USB Modem Port 現在只要選(Linkit One) 即可 不過既然不需要了 可以的話拿掉比較好…XD 應該也不會有點錯或混淆的問題(? Linkit One &amp; Socket不曉得Linkit One或Arduino資料傳輸上大家會選用何種方式、協議來實作 最基本的當然就是https、httpsS，也許你也有其它方式(Like:mqtt)，不過我在這邊選擇用socket的方式來處理~ 畢竟socket對我來說比較熟悉，而Websocket協定也已經趨近成熟~ 動手玩看看吧 這邊Casear Chu已經fork了原Arduino-Websocket的專案，並已經修改成LinkitOne-Websocket 可以讓我們直接使用! 以OSX為例，只要到 ~/Documents/Arduino/libraries 用git將專案複製下來就搞定 12git clone git@github.com:Casear/LinkitOne-Websocket.git 如果是Windows的用戶 直進點選右邊的Download ZIP 解壓縮到你的library資料夾就ok https://github.com/Casear/LinkitOne-Websocket 不過範例code還尚未修改，其實只要將WiFly的library換成Linkit One的就可以了 以下面簡單的範例來玩玩~ 這邊要注意的是Linkit One Wifi只支援2.4Ghz並不支援5Ghz 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;LWiFi.h&gt;#include &lt;LWiFiClient.h&gt;#include &lt;WebSocketClient.h&gt;#define Server_IP \"Host_OR_IP\" //Host or IP#define WIFI_AP \"AP_Name\" //所要連的名稱#define WIFI_PWD \"AP_Password\" // 密碼LWiFiClient client;WebSocketClient webSocketClient;void setup() &#123; Serial.begin(9600); LWiFi.begin(); Serial.println(); Serial.print(\"Connecting to AP...\"); if(LWiFi.connectWPA(WIFI_AP, WIFI_PWD) &lt; 0) &#123; Serial.println(\"FAIL!\"); return; &#125; Serial.println(\"ok\"); Serial.print(\"Connecting to websocket server...\"); if(!client.connect(Server_IP, 8124)) &#123; Serial.println(\"FAIL!\"); return; &#125; webSocketClient.path = \"/\"; webSocketClient.host = Server_IP; if (webSocketClient.handshake(client)) &#123; Serial.println(\"Handshake successful\"); &#125; else &#123; Serial.println(\"Handshake failed.\"); while(1)&#123; &#125; &#125;&#125;void loop() &#123; if (client.connected()) &#123; webSocketClient.sendData(String(random(1000))); &#125; else &#123; Serial.println(\"Client disconnected.\"); while (1) &#123; // Hang on disconnect. &#125; &#125;&#125; 你可以將隨機數替換成感測模組將所得的數據送出 不過如果剛好你的Linkit One與電腦是在同一個區網下，透過ipconfig,ifconfig查詢內網ip 就可以透過socket將資料送到你的電腦上~ 等到要正式發佈再丟到遠端Server就好 既然Linkit One的部分搞定了 再來你就可以使用自己喜愛的語言、framework來撰寫 Websocket Server的code對送來的資料做處理囉~~ 這邊我以Node.js為例 ws: https://github.com/websockets/ws WebSocket-Node: https://github.com/theturtle32/WebSocket-Node 上述兩種module或framework已經自帶websocket 就隨你處理囉 12345678910111213141516var WebSocketServer = require('ws').Server , wss = new WebSocketServer(&#123; port: 8124 &#125;);wss.on('connection', function connection(ws) &#123; ws.on('message', function incoming(message) &#123; console.log('received: %s', message); &#125;);&#125;); 結果大概會長的像這樣~ 而接收到的資料看是要存到mongodb，或像是rethinkdb這類的real time db也都是不錯的選擇 回到了平常開發網站或是寫原生APP的環境之後，再來就可以來大顯身手料理這些資料了 (所以我說那個醬油呢 逃~ 看是要透過圖表的方式，用Web或著APP來呈現還是資料處理分析，就看愛怎麼做就怎麼玩囉~ 總結物聯網、穿戴裝置其實給我的感覺一直相當的微妙 在人人都有智慧型手機的情況下，現階段我們真的需要有穿戴裝置嗎? 至於物聯網，家裡家電舉凡像冰箱、電燈、冷氣連上網又要做什麼呢? 還是這些東西會淪為駭客的跳台設備呢? 可以期待Maker們要如何去創造需求，並能在這過程中做見證的我們還真是幸福 MTK或許想再未來嘗試更多可能性，並希望從中掌握市場動向才誕生了Linkit One 早期MTK給人有種封閉的感覺，透過Lab的成立希望能跟社群與眾多Maker交流 雖然說目前還有許多需要加強的地方，不過既然踏出了第一步，除了給予肯定還希望他們能持續走下去 過去一年之中不僅只是在Maker的社群，連同開發者者忘年會或SITCON等等的學生社群 都有看見Linkit One的影子 就學習及懶人的角度而言，我認為Linkit One算是相當不錯的平台了 而MTK也希望能透過這個平台來幫助人們一圓創業夢，這或許就是去讓人使用它且後續問題處理的最大誘因 所以除了繼續推坑之外，做好穩定的開發環境讓人們能更容易接受，相信會有越來越多人願意使用 :)","categories":[],"tags":[{"name":"LinkitOne","slug":"LinkitOne","permalink":"https://blog.yunchen.tw/tags/LinkitOne/"}]},{"title":"Modern Web 2015 學生獎勵計畫心得","slug":"modernweb","date":"2015-05-19T16:00:00.000Z","updated":"2017-04-05T15:01:19.000Z","comments":true,"path":"2015/05/20/modernweb/","link":"","permalink":"https://blog.yunchen.tw/2015/05/20/modernweb/","excerpt":"","text":"若有錯誤歡迎大家指教&lt;( )&gt; 本篇為學生獎勵計畫給iThome的心得報告 今年運氣不錯 能通過學生獎勵計畫的審核真是太讓人興奮結果幫我寫推薦信的梅興老師投的slides也被列入議程之中XD算是一個明明人在中研院參加研討會卻感覺要上課的概念(? iThome辦的活動整體來說很棒，進來的第一個感覺就是品質吧!這點和我過去在參加的研討會有點不太一樣，感覺比較正式，而且工作人員大多比較能處理狀況以往學生志工的工作人員被會眾詢問很容易就手忙腳亂 因為事前訓綀比較少的原故而在報到和帶位這點真的效率極佳，連前幾排的位置都有，不用站著聽真的大感謝 然後有些部分我覺得應該要改善，第一天報到之後，既然都領了掛牌卻必須要在門外等約30~40分鐘直到九點才能開放進場，雖然藉機和贊助商攤位互動也不失一個好選擇但我看大多數的人都在原地發呆XD 攤位除了四樓的贊助商之外，四樓兩側的走道倒是可以規劃一下讓開源社群進駐，或是活用交誼廳的空間主持些交換名片之類的活動此外閉幕式有點冷清阿~~ 原來是少了Lighting Talk~QAQ最後我要說的是畢竟這次是iThome所主辦的活動，不需要刻意去模仿其它的研討會當然該改善和學習的部分還是要加油，走出一個你們辦活動的style最重要畢竟交朋友雖然重要，但來聽研討會重點果然還是要專注聽議程，這次真的學的相當的過癮! [R0+R1+R2] JavaScript at 20 Years這是JavaScript 之父 Brendan Eich來做演講10天開發出來被大家罵翻的語言 現在變成當紅炸子機，劣即是夯麻一開始就提到Js的相容性連在20年前的網站都還是可以運行看看以前沒有json xml等格式…資料都是new class的方式實做有趣的是這個class在ES6回歸JavaScript 這是把JavaScript打造成Java的樣子嗎(大笑)另外印象比較深的ES7會自帶async function 預計一年內完成之前我們都是用promise的套件或其它framework的async來實做這塊不過拜他的為JavaScript搭熱潮命名所賜 每年都要糾正學弟妹JavaScript不是Java的腳本語言囧~最後展示由Asm.js支援的Unreal遊戲引擎(有在關注電動的應該都曉得虛幻3)打造的3D遊戲當然講師就一直玩一直玩一直玩XD~ (表示羨慕) [R1] Redis, another step on the road - 曾義峰(Ant)之前就有玩玩Redis用來在多機器要儲存Session時相當的好用，不過這部分不是我處理一直都沒有機會深入使用剛好趁這次機會可以對它了解，重點是有人幫我們踩好雷分享點經驗講者介紹了一下Redis的歷史和特色，及各版本之間改進了哪些東西因為Redis是採用類似LRU方式實作，早期版本取樣3個，一直到3.0取樣5個把這5個之中最舊的session給丟掉，直到記憶體用量小於最大用量但如果這5個都是最新的，使用者才剛登入就被被出，而且要到他們抱怨才會曉得，這就很恐怖了並且比較了Redis、Aerospike和Memcached 果然還是得看服務需求及”$”來決定哪種適合自己原來Aerospike會掉資料…(抖) [R0] 雲端系統對爆量的測試與準備 ­ 以張惠妹秒殺售票為例 - 邱光宗咳 所以到底誰才是第一的售票系統哩…講了一些以前售票很趣的經驗，原來發號碼牌排隊用ibon結果店員下班脫掉背心~”嘿嘿我第一”售票決對不能在中午，因為這樣熱便當會來不及買票導致收到一堆客訴售票前的就要預先開好機器，因為自動擴展會來不及，這好像以前有聽過布丁演講過了O_0~最麻煩的果然還是金流，銀行的收單速度每秒只能到75筆 所以會開虛擬帳號來先收不過這也會有問題…到底預設要已收費沒繳再改成未收費，還是未收費有繳再改成已收費中間出了差錯下場就是使用者付費卻曉示未繳費，這又將有一場風風雨雨 [R1] 聽說 KKTIX 現在都是用 Go 寫的 - Poga這場在推坑GO語言~ Go基本上編譯後是獨立，不用依賴其它環境，原來叫人裝npm會有人發怒..XD簡單講了導入新的語言要怎麼和現有的CI整合，但目前大多數都還是用ruby on rails寫的~講著提到了一個點我覺得還不錯，只要是商業邏輯的部分全都用rails寫 其它運算則是用Go像活動選擇、登入授權這些當然還是用rails比較方便，至於訂票、選位置、自動劃位則是使用GO來加速至於兩種溝通的方式就是存取同一個資料庫，所以也可以說他們都是用db來溝通(可惡也想聽D3.js) [R0+R1+R2] 開源之道，Open Source Enlightenment 唐鳳這場真的精彩點太多了XD 好多都是阿宅梗(大笑)以後跟人說話都應該要遵守一個https Protocoll的概念 服務也一樣，400、500開頭的最好不要用人生碰到的問題就跟git版控一樣，有衝突一定要解決…不然不能commit聽完好像喝了一鍋心靈雞湯一樣…同時對現場大家都聽得懂梗感到溫馨 哈哈React.js 和 Angular.js 原來有做過溝通… [R2] SEO真的只要做這些事就好 - 邱煜庭(小黑)這邊要跟講者抗議 林東芳牛肉麵明明就比較好吃(大誤)要做好SEO 漂亮的架構就是唯一的救贖，然後減少div? 原來搜尋引擎看不懂空容器另外不要在meta放keywords了，現在google已經放棄了，下好一個標題比較重要3~5個關鍵字在標題最好，另外現在最仰賴的就是社群，瀏覽器沒以前強勢但事實是yahoo做的超差照樣贏你因為流量就決定一切有聽過十大最差牛肉麵嗎? 沒有吧!可是我沒有聽過桃源街牛肉麵比林東芳牛肉麵好吃誒(重點誤） [R2] Web + Arduino 實在有夠潮! - Marty Hsu身為一個死大學生…明明教授在隔壁廳講課，還敢翹課跑來這聽XD 根本超白木..至少結尾有趕上…就跟點名一樣^.&lt; 老師有錄影可以自行補課唷~~這場用HTML&amp;JS來寫Arduino 好比說這樣子我只要控制state就可以讓led亮 至於邏輯的部分則是藉由JS來做重點是他的版子不需要插線，可以藉由wifi來控制，只要插電就好!聽到這邊就讓人感到非常手養說XD~ 不過我還是覺得寫html在裡頭很怪如果html的部分可以用React.js Component的方式來做 led({state:true}) 等等從頭到尾我只要寫js 可能會更加吸引人~~~ [R0] The Speed &amp; The Enthusiasm (速度與激情) - Paul Li老木大師滿滿的激情，平淡無其的測試被他講的視窗都要從畫面彈出來聽說最近還去客串yahoo購物當模特兒~工程師好忙(大誤)Protractor提供了一個很直覺的語法讓我們去操作Selenium而且功能強大到好心動即便是非angular.js寫的也能夠做測試，雖然先前只有用mocha對node.js做邏輯測試不過果然使用者操作測試也很重要，因為可以從中得知UI的好壞，邊寫測試code就會邊罵了… [R0+R1+R2] Speeding up the Web with PHP 7 - Rasmus Lerdorf因為大家都想要一個基於c的後端可是沒人去做，所以就跳水了~結果反而Rasmus Lerdorf最原始寫用c給web的api都沒人關注XDDDDPHP7改善的效能並且使用更少的記憶體，不過Drupal8還未完全支援很多細節部分有點miss掉QQ 果然JavaScript比較吸引我然後希望大家可以參予測試PHP7 預計將和HHVM一樣使用”JIT” 在未使用前速度已經比HHVM還快預計導入JIT將會帶來更快的速度 [R0] 從失敗中學習打造技術團隊 - 戚務漢(Caesar)上一次聽caesar演講已經是去年他在實踐大學教node.js的時候了這邊分享了一些工程師從資淺到資深的心路歷程 然後安排實習生輪流監控CI和程式碼從一個人到一群人成長這樣的故事 不過身為一隻魯蛇學生還沒辦法體會這樣的事情或許比較適合現場已經在職場打滾一段時間的人吧~ [R0] 用 Vagrant 與 Docker 拯救世界 - 林嘉軒(GSLin)講者因為有自己對網路環境的需求而採用Vagrant來管理Docker不過我還是想不透~ 他提到的很多事情Docker Compose&amp;Fig之類的就可以辦到了所以也有人有提出這樣的問題出來~ 還是有什麼東西需要混用管理或者其它需求呢? 還請高人指點 [R0] 從 React Native 看 “Learn once write anywhere” 帶來的開發典範轉移 - Jeremy Lu有點小失望~ 這場議程內容和JSDC大致上一樣，講者主要是想推坑React.js 吧XDJeremy的風台真的超穩阿…議程時間真的太短可惜了，不然應該可以分享很多有趣的東西不過以前玩React.js前聽他在JSDC介紹，再完整走過一遍React.js+Flux單向資料流後再聽一次有種不一樣的感受~ flux那張流程圖當初也是邊實做邊盯著圖的流程想，到現在不用看圖就可以在腦子寫code的時候走完一遍流程這樣子吧.. [R0+R1+R2] How the East Was Won - 松田明Ruby = Lisp + Smalltalk + Perl + C + English你寫Ruby嗎? 不…我寫Python跟Js….QQ講師是rails的核心貢獻者，很努力的再向大家推廣，介紹了Ruby社群的一些理念不過我從來沒碰過Ruby誒 所以我算是個邪教徒嗎~~console.log “May Ruby be with you!” [R1] When web meet native app - Eric Chuang(ddsakura)後面幾場比較不曉得聽什麼~ 只好挑跟技術比較相關來著手介紹了一些在Java上使用webview的做法 不過不同的手機廠牌都會有自己的版本預設會把js關掉，所以不打開下場就是跑版等問題，分享了一些實作上會碰到的狀況像有的圖片走https網站是走httpss需要透過Always Allow來解決不同協定的問題Android5以前的版本也需要去處理cookie的問題CookieSyncManager透過這樣的方式可以寫一隻app不完全是native或者web~ 就可以在web頁面上叫native的api [R1] 使用 React.js 協助開發 Rails 產品 - 何澤清雖然沒寫Rails不過就來聽聽看使用React.js的心得，不過講者似乎很緊張阿XD~原則上前端和我現在使用的方式大致相同，有種 喔! 原來你也是這樣子的感覺不過因為我們後端是使用node.js 並使用了yahoo的fluxible，用rails的做法是前後切割而node.js這邊則是前後端都可以render，這樣子的好處就是js產生的html我們不需要重新寫一份來讓搜尋引擎的機器人爬，不過可惜講師沒時間提到他們是怎麼做這塊 [R2] 從技術角度看 Responsive Web Design - 吳政斌(Chris)提到了一些開發RWD時碰上的血淚史資源一致性 - 為了版本修改，重覆寫了相同的html code，圖片被引用的url只會被下載一次高品質內容,媒體相容性 - 不用的裝置 傳回不同大小的圖片，不過他這邊只有max,medium,min 一般我們會比較希望可以後面帶query傳尺寸到後端去處理圖片，就不需要像他一樣這樣判斷要打哪個 減少重複code環境狀態感知 - 透過api得知網速決定要吐的資源 今天網路贊助商又中標XDD","categories":[],"tags":[{"name":"modernweb","slug":"modernweb","permalink":"https://blog.yunchen.tw/tags/modernweb/"}]},{"title":"四月 Taipei.py / Cython 手把手教學","slug":"taipeipy","date":"2014-04-23T16:00:00.000Z","updated":"2017-04-05T15:00:48.000Z","comments":true,"path":"2014/04/24/taipeipy/","link":"","permalink":"https://blog.yunchen.tw/2014/04/24/taipeipy/","excerpt":"","text":"從去年開始就一直有在參加Taipei.py 不過一直以來聽的都是在場Programmer 專業的分享 當然收獲有是有 不過仍然感到非常的硬 原因在於他們分享的東西沒有玩過 當然容易聽不懂 自從上次第一次 Pandas手把手教學 再接這次的Cython手把手教學 真的越來越感覺Taipei.py 對初學的人相常友善～ ：） 我也感覺自己滿幸運的 當自己有想學的東西都會剛好有人要分享、教學(樂) 不管是上次的Pandas 或 這次的Cython 居然可以從頭到尾聽得懂~ 跟著做XD 對我來說也是相當大的鼓舞 以後提及Python加速 或者 資料分析應該就不會太陌生了～ 什麼是Cython!? 你可以把它想成是 Cython = C + Python 或者是乾脆把Cython想成是一個新的語言也行 為什麼要這麼做？ 原因沒有別的～ 腳本語言最大的缺點就是速度會比靜態語言慢上許多 尤其是像Python越來越被用在科學運算做處理 當然對於速度上的需求就越大 之前的Taipei.py就有人說 我可以用Python寫出和Ｃ一樣快的程式 這種酷酷的發言XD 他就介紹了Cython，今天終於有機會聽到Mosky帶著大家體驗這個驚人的套件～ 一般Python在import 套件的時候都的.py檔 但其實只要符合Python所訂的規則，其它檔案也都可以import 給Python去做使用 此外Cython會比Python快的原因之一也是經由轉成.c檔再做編譯 當然比起Python的直譯器快 Cython編譯完的.so (share object) 就可以給Python import使用了 Cython在寫的使用其實仍保持著像Python的彈性 也因此可以與Python的檔案做相容 除此之外像是一些變數或function的宣告就有分像 CDEF CPDEF 及Python原本的DEF cdef int i,j,k cdef float f, g[42], *h 後面基本上就和你一般寫ｃ宣告的方式一樣ＸＤ 當然像enum struct 也都可以這麼做 Cython的檔案為 .pyx 所以一般是寫在裡頭 那這三種的差別到底在哪？ 為什麼有這些東西出現？ CDEF和原本的DEF相比 CDEF是僅用來給C去做轉換編譯的 此外Python 不是用import 而是cimport 去做載入 並且僅能執行 CDEF並不提供給Python像DEF做function的呼叫 繼承至Ｃ所以在用CDEF的時面 還必須要創一個.pxd 檔做介面的宣告 這點稍為麻煩了一些ＸＤ 而CPDEF 和 CDEF的差別 可以想成是CDF包了一層Python 這樣就可以讓Python去做function的呼叫了，為此所付出的代價就是速度較慢 這邊附上了Mosky附上了比較表 對 這堂Cython有興趣的可以到 mosky.tw 找投影片～ 速度是越上面速度就越快，反正則越慢 我們可以發現DEF在最下面是速度最慢的一個 再來就是CPDEF犧牲了一點速度換來Python呼叫的便利性 排第二的就是我們自己寫的CDEF 相對的就不方便許多 最快的理所當然就是直接用Cython去取用C原的函式庫 使用方式一樣是用cimport 所以我們可以發現Cython加速的方式就是去犧牲Python的韌性來換取速度 我記得像是多了形態和陣列大小的宣告就能夠大幅提升原本的效能 而我們也可以透過Cython找到Python的便利性與速度的平衡 不但可以讓原始碼非常簡潔，同樣的也有一定的效能，這是多神奇的一件事啊！ 做了非常扎實的綀習 超棒！！ Cython給人的印象深刻！！ 在這堂也發現了檔案的命名管理真的超級重要 .pyx .pxd .py 三個互相做取用 如果隨便命名 光是該import哪些就相當惱人了吧XD 期待下一次的Taipei.py 不過在那之前的五月中會有更大的聚會 5/17 PyCon2014 Apac 期待會有更多收獲與心得~","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.yunchen.tw/tags/Python/"}]},{"title":"node.js 基礎技術研習營","slug":"nodejs","date":"2014-04-18T16:00:00.000Z","updated":"2017-04-05T15:00:37.000Z","comments":true,"path":"2014/04/19/nodejs/","link":"","permalink":"https://blog.yunchen.tw/2014/04/19/nodejs/","excerpt":"","text":"去年暑假在宅學習時，梅興老師請到Caesar Chi來談談node.js 不過那個時候我剛在玩Python 所以知道了這個用Javascript語言為基楚的後端 不過並沒有馬上玩XD 一直到了最近玩了 BZ學長寫的遊戲外掛，藉由修改手機遊戲封包 來達到人物一擊必殺，當時感到超驚訝的XD，而且又發現是由node.js架起來的~ 再加上SITCON時聽到有越來越多人開始玩它，梅大的Web又需要發表網頁 就這樣順水推舟，玩起了node.js…XD 這次來到實踐大學資管系的電腦教室來一探node.js的魅力 由於在來聽研習營前，node.js已經有小玩了一段時間 並且也玩過Express的framework了 所以上午的基本課程非常的輕鬆，大致介紹了一些node.js的特性 像是event-driven、non-blocking、可處理大量I/O的服務來避免Server阻塞 再加上有socket.io的支持，甚至可以做到用瀏覽器做P2P傳輸 當然其它像Python Django、Ruby on Rails也可以做得到，但以node.js來說會容易很多 不適合做CPU運算等需要多執行序的網頁程式，因為JavaScript本身就是一個單執行序的架構 不過既然部分有優勢，當然也會有劣勢存在 不適合做CPU運算等需要多執行序的網頁程式， 因為JavaScript本身就是一個單執行序的架構，還有JavaScript先天有的缺陷等等 網路上有太多的比較文章XD 有興趣可以去找找~ 接下來我就以下午我感興趣的部分為主 後端常說MVC 當然除了Express這樣的之外 更加方便的Sails 這也讓我大感驚訝 原來還有這類的framework存在 當然它也是基於熱門的Express架構為主 超可愛的terminal 介面 連運行指令都很有趣! 你可以把他當成是 Sails就是將Express再做一次包裝又更方便 更好用了! 一些基本的東西都已經將你整理好 當然也支援socket.io 像是css javascript檔案只要放到資料夾 就會幫你做好連結 不需要再到html更動 路由的部份也是都已經設定完畢 連同錯誤頁面也都做的很精美! 再順利的運行之後 預設的port在1337 可以先到裡頭 瞧瞧 上面就有附上一些簡單的教學 不過我還是建議去看官方的Documents才能做更深的認識 但是如果是對於要交作業這檔事XD 什麼架個資料庫做留言板什麼的 很夠用啦XD 因為已經都幫你做好好了XDDDDDD 連同資料庫也一樣 你只要去用就可以了 加上事先如果有玩過Django或者Rails的話 我想這些要修改應該也很快就能上手了 說到了後端的Sails 那麼當然前端也必須要提一下 而這次介紹的就是 AngularJS!! 這玩意兒可是有牌的XDD 是說有Google大神加持就很潮嗎? 一般我們寫HTML都是以Document的概念去寫 像是用jquery取用一個個物件ID 一樣 可是AngularJS 卻是以UI的概念去想 寫起來非常直覺 看 起 來 “簡單” !? 事實上學習曲線卻不一點也不簡單XD 這次梅興老師的Web基本課程的期末發表就有用上一點點 不過還不至於熟到可以讓我在發表說嘴XD 等熟了一點再來分享一些心得吧! 也許是新興技術的課！？","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://blog.yunchen.tw/tags/nodejs/"}]},{"title":"實戰中大型專案開發II","slug":"ossf","date":"2014-04-12T16:00:00.000Z","updated":"2017-04-05T15:00:08.000Z","comments":true,"path":"2014/04/13/ossf/","link":"","permalink":"https://blog.yunchen.tw/2014/04/13/ossf/","excerpt":"","text":"此文章僅做為基本入門參考 :) 這次是第二次專案開發的課程 不過可以確信的是我的工程數學應該完蛋了Orz 因為這篇網誌是考完之後才寫的，所以是真的確定完蛋了… 專案報告 某學長還臨陣脫逃艸 最後我們這組就他沒來 被酸爆了XD 為什麼要有編輯風格的標準? 主要是為了能讓Programmer的程式架構盡量保持一致 方便閱讀，也能提升對Code的維護 尤其是在多人合作的時候 我們這組報告的是Python風格編寫標準，每組都針對不同的語言做報告 而這也是此次課程的重點，藉以分析不同語言的特性及是否認同他的寫作風格 不過再開始了解這些的Standard之前，專案、公司共同的編寫風格是 &gt; Standard 主要是為了一致性的問題，為了追求這些Standard反而破壞與大家編寫code的一致性 這反而不太妥當，這也是我們在場聽到很多業界人士參與討論的聲音 當然你也可以完全不理會這些標準 開開心心的寫程式碼~不過有些標準不是沒有道理 有空當然還是希望可以參考一下囉! PEP 8 – Style Guide for Python Code (本篇以官方為主)https://legacy.python.org/dev/peps/pep-0008/ Google Python Style Guidehttps://google-styleguide.googlecode.com/svn/trunk/pyguide.html 我大約整理了一些常見的類型&amp;專案開發課程的討論&amp;心得 想看完整點的可以看看上面這兩篇 #Python 特性 try: for port in range(1,1025): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) result = sock.connect_ex((remoteServerIP, port)) if result == 0: print &quot;Port {}: \\t Open&quot;.format(port) sock.close() except KeyboardInterrupt: print &quot;You pressed Ctrl+C&quot; sys.exit() 從上面我們可以看到Python並沒有以{}做區塊的分別 而是嚴格採用空白來做區分(註: 空白和TAB不可混用 建議全空白) 這類的特性(Ruby也是如此) 可以稱他是竹竿曬衣!XD 長長一隻竹竿，下面整齊掛一排衣服 讓整體Code具高可讀性，也大大減少了新手容易搞不清區塊的問題 這也是為什麼Python對新手非常有善的地方之一 區塊都是以 “視覺化” 為主 像是因為{}之中 所以{x=1;for(int i=1;i&lt;10;i++)x++;System.out.print(x);} 不小心都擠在一行也是ok的…It’s work!等等 (當然Python真有心這樣做也可以啦Orz) ##Code lay-out foo = { long_dictionary_key: long_dictionary_value, ... } foo = long_function_name(var_one, var_two, var_three, var_four) my_list = [ 1, 2, 3, 4, 5, 6, ] 不論在PEP8 或 Google 都會希望以四格空白來做區塊的分辦 參數的話如果太長則是能夠以上一行的開頭為對照 如此一來比較能夠一眼就曉得這些區塊的位置在，但並非所有的語言都建議以四格 例: JavaScript 會比較希望是以二格來做排版 不過像我碰到要接手的案子，有的人就是習慣用二格，為了確保一致性…還是照對方所做的吧 ##Maximum Line Length with open(&apos;/path/to/some/file/you/want/to/read&apos;) as file_1, \\ open(&apos;/path/to/some/file/being/written&apos;, &apos;w&apos;) as file_2: file_2.write(file_1.read()) 超過80字元長就以 \\ 換行吧~ 傳統的終端機terminal，最大一行的顯示字元約80字，所以一般會規定一行不要超過80字 不過現在的編輯器很方便當然可以超過這個範圍，但還是建議以這個值為主 一來是比較容易閱讀 此外如果今天換成是開發前端的網頁呢…? 不像Python、C、Ruby…等等，執行的環境不是在這些編譯器中，而是在各種不同的瀏覽器 以直譯的方式來執行，更不用說有的還有非主流的瀏覽器存在，對於超過該行而跳到下一行 的原始碼會不會如其執行? 所以能避開不必要的問題就儘量吧! url=&quot;https://www.example.com/developer/documentation/csv_file_name_extension_full_specification.html&quot; 在Google的標準中有提到網址就最好不要這樣做了 這點我超同意!XD 尤其是要複製的時候!! 會多 “\\” ##Blank Lines 區塊是不是該用單、雙行空行做區塊 好比method(function)之間、class之間 等等 不同關連性的以兩行來分，有相關的則是一行做區隔 在Google的標準中甚至有嚴格規定class開頭與第一個method需要空兩行 其餘則空一行 而巢狀class(class裡頭包含class) 有此類別也是以雙行來做區隔 這點我想就見人見智了吧~現在得知的都是公司沒有這類規定 大多都以一行空行(也許是懶XD) ##Source File Encoding 在Python2中預設編碼是ASCII 建議都改成UTF-8 可以在程式的第一行打上 #-*- coding: utf8 -*- 這也幾乎是我開始寫的第一個動作，原因無他…你只要一打個非英文的特殊字元或中文 程式馬上就噴個無法辨識ASCII的Error給你看 在Python3已經將預設編碼改成UTF-8 就比較沒有這類的問題 ……問題是大多數用Python的人都是停在2 XD 太多好用library都在2還沒跟上Orz ##Imports import os import sys 建議在載入packages時能夠分開，不同的package在不同行 比較清楚可以知道用上了哪些package，最好不要一次就一行全數載入 此外在python中不見得要載入整個package，你可以只載入你需要的module即可 from subprocess import Popen 在Google範例中你也能把不同的module 分別放在不同行 from foo.bar import baz from foo.bar import Quux 這我倒是比較不喜歡 通常我會這樣做 from subprocess import Popen, PIPE 不過看每個人的做法~沒有對或錯 ##Whitespace in Expressions and Statements Yes: spam(ham[1], {eggs: 2}) No: spam( ham[ 1 ], { eggs: 2 } ) Yes: if x == 4: print x, y; x, y = y, x No: if x == 4 : print x , y ; x , y = y , x Yes: spam(1) No: spam (1) Yes: dict[&apos;key&apos;] = list[index] No: dict [&apos;key&apos;] = list [index] 這邊對照就會清楚很多，雖然空格很好，可是有時候太多也不好 一般在做參數的時候通常只有參數與參數之間或參數與值之間才有必要 有沒有發現這些空白的地方有點眼熟? 沒錯，如果觀察夠敏銳就會發現到這些規則 和英文寫作的規則非常的相識，逗號、冒號、句號都是要再後頭空格 所以可能有些人有因為英文文章沒有在標點符號空兩格而被老師念吧? 另外像上述的if如果只有一行 Google標準會建議就連同要做的動作寫成一行 但是在JavaScript中就會建議你這麼做 if (a&gt;b){ print a; } 同樣的沒有對或錯，出發點在於如果需要再加上其它的行為在if下會方便很多~ 此外有一點超級無敵重要!! 千萬不要這麼做!! x = 1 y = 2 long_variable = 3 龍哥(高見龍大大) 稱其為 “程式碼潔癖” XD 雖然我在python沒遇過 … 不過目前在接的CASE…CSS天殺的有!! 我貼過來 #title { border: 2px solid #7EB2DB; color: #FFFFFF; background-color: #7EB2DB; height: 20px; padding-left: 10px; -webkit-border-top-left-radius: 10px; -webkit-border-top-right-radius: 10px; -moz-border-radius-topleft: 10px; -moz-border-radius-topright: 10px; } 而且還是長達一百多行都這樣搞，自己要新加的style和其它元素 要跟他保持漂亮的版面 可是空白按到死也不是… 不跟他學，最後一個CSS檔有兩種編寫風格也不是… 最後我是屈服於自己的懶惰 要排你自己以後在慢慢排XD (逃) ##Comments 在編寫註解的時候最好可以緊黏你要註解的區塊 #Comments Here~A function def function: pass 中間如果空行 容易讓接手的人產生這註解應該是上一塊的 而就順手直接在空行處加入新的程式碼 導致Comments和程式碼對不起來，這便會產生一個非常大的問題 又一個新人來接手，在讀程式碼發現這一塊和Comments對不上 通常第一個反應都是 「是不是我理解有錯?」 而花非常多時間再重讀、理解 最後才發現是Comments標錯地方 不管何種標準都稱其為 “最糟糕的後果” 此外如果是單行最好不要附在code的後面 x = x + 1 # Increment x 為什麼? 課本、教科書明明都這樣做! 課本和教科書會這麼做是因為印刷的問題，如果都單行註解，一段程式碼可能就會多出好幾頁 最主要是因為容易造成閱讀者會分心，當我們眼睛在左邊專心讀code了解邏輯時 容易因為右邊有字而造成分心 (通常你會強迫你自己要去讀他XD) ##Programming Recommendations try: value = collection[key] except KeyError: return key_not_found(key) else: return handle_value(value) 在我沒特別注意前也會忘了加 try、except(catch)完之後 就直接將程式往下寫了 少了else(finally) 記得加上去減少bug產生，也讓你的例外處理多了邏輯 Yes: if foo.startswith(&apos;bar&apos;): No: if foo[:3] == &apos;bar&apos;: 如果有字串的function可以使用就千萬不要客氣 不要自己去硬幹，除了非常不好讀之外，萬一像bar改成chen 這樣四個字就錯了 此外硬幹有時還會比較沒有效率喔~ Taipei.py社群有實驗過XD Yes: if greeting: No: if greeting == True: Worse: if greeting is True: 如果greeting回傳已經是True或False了 就不需要在多此一舉了 1 == &apos;1&apos; True!! 1 == True True!! 1 === &apos;1&apos; False!! 1 === 1 True!! 附帶一提在JavaScript中 有 == 和 === 之分 with open(&quot;hello.txt&quot;) as hello_file: for line in hello_file: print line 之前在社群也有討論到 在Python中最好的讀檔方式是什麼? 就是不要用read()!! 這當然是用上了for loop的特性才能這樣做~XD 程式碼會變的很好讀，一看就知道要做什麼而且也很方便 不需要在特別呼叫一個function來讀取 當然還有很多Python漂亮的寫法 除了可以參考上述兩份文件PEP8、Google之外 有人整理了一些不錯的寫法 我也老早把它加到我的最愛之中 :) 在此分享 30 Python Language Features and Tricks You May Not Know Abouthttps://sahandsaba.com/thirty-python-language-features-and-tricks-you-may-not-know.html ##Naming PEP8 (Python官方的標準) 還尚未有對名字的定義標準 不過Google倒是有給一些規則，這些在其它的程式語言之中也常常見到 一些像是全部大小表示常數、Class的開頭單字都要是大寫 不過有些變數或者function則看是全部小寫或是getMoving() 受Java影響像講師-依瑪貓會習慣在有行為的function前面加個get 這也許也是個不錯的建議! 總之不管風格是什麼， 在遵循一些標準時，不要妨礙到自己寫程式的心情最重要XD","categories":[],"tags":[{"name":"OSSFProject","slug":"OSSFProject","permalink":"https://blog.yunchen.tw/tags/OSSFProject/"}]},{"title":"OSDC TW 2014","slug":"osdc","date":"2014-04-11T16:00:00.000Z","updated":"2017-04-05T14:59:28.000Z","comments":true,"path":"2014/04/12/osdc/","link":"","permalink":"https://blog.yunchen.tw/2014/04/12/osdc/","excerpt":"","text":"原本是沒有打算去參加的XD 畢竟有一天卡到上課 再加上下星期又是期中考，所以就打算PASS這次的Conference 不過在星期五早上看到 林哲安 大大~ 因為有事沒辦法參加，當下決定 既然有這樣的機會 就去參加看看吧……我是不是忘了什麼(? 感謝&lt;( )&gt; OSDC對於會眾讓我感到滿滿的善意XD 有接駁車 省去了不少麻煩 不過聽說後面的班次因為客運公司的問題導致沒有車 還好我超早就到了 第二天的OSDC出發! 因為早早就到會場，放好東西之後 就到走道拿會眾早餐 順便到社群攤位晃晃 不過因為是第二天了 有些社群攤位東西發完顯得冷清 每一次的研討會廠商所提供的咖啡都是一個桶子裝著已經研磨好的咖啡 旁邊附個奶精 對於一個Developer來說 咖啡coffee是個非常重要的東西 怎麼能這麼隨便!! Developer就魔術師 可以把咖啡轉變成 程式碼XD 因此這次G0V(這次好幾軌的講者也都有參與) 在OSDC就發起了 「自己的咖啡自己煮，自已的國家自己救」 很酷吧XD 順便也到龍哥推薦的Rails Girls瞧瞧 打卡拿胸針做紀念 Firefox的攤位也可以瞧到昨天偷偷來的學長 結果被照登網的證據 除此之外在會場的簽到處 有設計者精心製做的明信片可以索取 真的很棒 第一場就到 R1的第一國際會議中心 聽Mosky談談MVC 什麼是MVC?用一個整理好的framework就是MVC嗎? 怎麼做會最好 從一個後端的工程師BE角度來看看前端FE的MVC 我們都知道是有這三個部分所組成 Model View Controller Model-save dataView-display datacontroller-modify model 當然 時事梗 是少不了的重要元素 可是很多的網站的取用資料情況如下 以前端來看的話 看起來好像滿合理的 很正常~沒錯 但如果是需要做整理的資料呢? 甚至有些資料只取部分的話會造成什麼結果? 搞死後端工程師就上手XD 以JSON檔為例 不論是向伺服器發送請求資料 或者是 伺服器向用戶端做取用 如果是只取用K1、K3 或者 更大的資料只取用部分 這種多對一的方式雖然可行 但是不但接手的人會感到不滿外，程式可讀性也夠直覺，如果能將資料做到 1:1 會更好 這時就需要多出一塊Model來做 同步/非同步 的維護 至於該如何做? Mosky有給一些原始碼供大家參考 use class in javascript -write 3 methods model view controller httpss://github.com/moskytw/memo-app/blob/master/memo/static/memo.jshttps://zipcode.mosky.tw 第二場是由大名鼎鼎的Fred 出手~ 不過標題他後來有糾正寫錯了 改”大腸花論壇” …XD 後面的投影片一樣充滿時事梗 不過跳太快來不及拍 國民機加油! 番薯一哥就靠你了 這次的主題QML 當然就和預計未來要在台灣上市的國民機脫不了關係 對於Nodejs 當然也有關注 不過QML對其API支援爛炸了 所以就有qtjs 由英國的開發者製做 qt and nodejs v8 eventdispatcherhttpss://github.com/svalaskevicius/qtjs-generator 不過整個專案還在測試的階段 有興趣的可以試試 另外Fred也像我們展示了IRC機器人 + qtjs 的結合httpss://github.com/Tennu/tennu-plugins 聽眾可以在IRC上 對他的 irc_robot下指令 機器人會掃每一句的敘述 並動作，像是我在irc上打 ls 就可以看到講師目錄有什麼 …… 不用我說 可以對講師電腦下指令 該個IRC頻道馬上充斥著滿滿的… rm -rf /rm -rf /rm -rf /rm -rf /rm -rf /… 結果他的IRC機器人DEMO失敗了 當場Debug不出來就只好放棄 而且看到他的原始碼……有些註解 // 拜託不要下rm 你是真的沒有做例外阿? 喂XDDDDDDDDDDDDDDDDDDDD HanGee 桌面畫面也有公開一小小部分…超酷! 都是用QML去做出來的介面唷 老人機版的畫面 Fred: 夠老人了吧 整個螢幕的Icon 這場是作業系統的探索 … 執行緒等等 另一廰貼是G0V的tkirby談d3.js 是一個G0V在將資料繪製圖表所用上的工具 聽說那邊爆滿…可惡 我也想去囧!! 只好怒附上他先前在其它地方講過的投影片 httpss://speakerdeck.com/tkirby/open-data-in-d3js-yi-ling-shi-zheng-fu-wei-li 在場有誰是痛恨PHP骯髒語法的XDDDD 所以開始抱怨起PHP語法糟糕的地方 不直覺 不好讀 一大堆天殺的框 {[($)]} 因此結合了常見的語言 Perl Ruby 等等的特性 寫出一個新的語言 gutscript 並且用Go 語言來做Compiler 產生出PHP檔 為什麼echo 變成say? 除了比較直覺外 更重要的是他少了一個字! 對於這個專案感興趣想試試及加入他的可以到GitHub觀注 gutscripthttpss://github.com/c9s/gutscript 因為這個原故 所以就熱血開發了一個新語言 gutscripthttpss://github.com/c9s/gutscript 這場對我來說很硬 全英文 談Bash我也不熟悉 不過只能說整場很High…一上台就當DJ放起音樂 KTV!! Let’s Dance!! 然後走到台中央跳起舞來 而且他還連續講了兩場 是我今天見過最high的講師了… 最後的Lighting Talk 這讓我印象最深 土炮人型移動LED看板 在立法院發揮極大功效 由一個多個鐵鋁罐…請求同伴支援喝來的XDD LED燈、Arduino及麵包包等等組成 聽說重量極輕~不用為他擔心 一個行動電源就能動 當然還為大家印出 Z &gt; B 立馬獲得掌聲+歡呼 最後當然還是要感謝這些辛苦的工具人員囉~ 好了 … 打完了 來去看討厭的期中考T_T","categories":[],"tags":[{"name":"OSDC","slug":"OSDC","permalink":"https://blog.yunchen.tw/tags/OSDC/"}]},{"title":"三月 Taipei.py / Pandas 手把手教學","slug":"taipeipy","date":"2014-03-26T16:00:00.000Z","updated":"2017-04-05T14:59:09.000Z","comments":true,"path":"2014/03/27/taipeipy/","link":"","permalink":"https://blog.yunchen.tw/2014/03/27/taipeipy/","excerpt":"","text":"這次是Taipei.py第一次有教學活動，聽說也是莫名其妙就有了 大家跟講者沙盤推演的去使用Pandas，此外也有助教從旁協助，剛好坐我後面 人超好XD 幫我解決了不少問題，而且這些問題都是在場也有用Mac的人居多Orz 原因在於不久前OSX Xcode更新到5.1後開始出現C編譯的各種狀況 從上面我們可以看到 command “cc” fail 等訊息 在5.1的版本之前Xcode做C檔的編譯，對於不認識的東西只會跳出Warning 可是在更新之後Warning就被改為了Error，導致執行中斷…也就是安全層級提高了 所以如果easy_install或pip install在c編譯不過的情況下，加入以下的魔法指令就ok了 sudo ARCHFLAGS=-Wno-error=unused-command-line-argument-hard-error-in-future pip install 把Error警告無視掉的解法就就這個神奇指令的用法Orz 至於到底什麼是Pandas? 首先它絕不是梅老師喜愛字面上的意思:貓熊XD 更不用說它和團圓、圓仔有任何的關係! XDDD &lt;-講師還有特別標這段 哈哈 Pandas是Python用來做資料處理的強大工具，支援各式的格式 簡單的下達你的需求就會將資料給整理好 此外和以往open讀取字串的方式不同， 這麼做我們常會用到split掉空格或是其它不相關的字元，不同的格式還有不同的做法 而Pandas會判斷最佳的輸入方法，偵測以換行或空格為區別 等等的方式省下大量的時間 在搭配圖形繪製的輸出 不論是長條圖、點陣分佈或立體圖都難不導它 何況Python的語言本來就擅長做數據分析，也有漸漸取代R語言的趨勢~ 在獲取大量資料並做分析的情況下，Pandas是好用的幫手 更何況像政府開放資料平台: https://data.gov.tw 沒有統一格式充斥各種不同格式的資料 Pandas更可以顯得他的便利所在之處 上面廢話了這麼多，那Pandas真正對我的影響是什麼XD 雖然資料分析超級方便，難道就沒有其它更好用的地方了嗎?? 還記得之前我自已手刻搞的網頁爬蟲 !? 這不好像也是資料分析的一種方式嗎? 在知道Pandas之前 … 乖乖分析HTML語法，找到資料，切掉不要的字串……超累人 我一點也不想乖乖這樣搞，有沒有更好的解決方式? 所以理所當然讀網頁這檔事也是Pandas的擅長之處哩! 以維基百科的資料為例 上頭早有排版完整，整理妥當的資料了，我又何必去惡整自己，全交給Pandas做就好了! 讀取HTML輸出一個漂亮好懂的結果需要幾行? 兩行XD還包含import 條列式的整理好了搜尋到的資料，之後就看自己的需求放置到Table整理成表格 不僅僅只是這樣而已，記得Word或PDF的資料嗎? 好像有個方式叫輸出成HTML檔XD，這樣一來不就少了不少麻煩事了XD 總比一個個複製、貼上好的多~ 社群稱PDF轉HTML神奇的function…… 雖然是圖片卻可以轉成HTML感到不可思議XD 判斷表格轉成HTML的td、tr 當然這樣做是有缺點，會有掉字的問題發生，但已經解決八成以上的麻煩了 所以拿到東西…轉成HTML就對了(逃) 總而言之，這次滿感謝社群的人和助教的協助，在開始前還大約教了我一下怎麼用IPython 和處理掉很多安裝遇到的麻煩~ 好像在場到講完結束還沒安裝完XDD 順便支持一下今年的Pycon，還真是令人期待，包含這次的Pandas作者也會來 4/7 有開賣學生早鳥票1290 不包含碩博士生(茶) 有興趣的可以關注一下 期待下次的聚會 :)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.yunchen.tw/tags/Python/"}]},{"title":"實戰中大型專案開發I","slug":"ossf","date":"2014-03-22T16:00:00.000Z","updated":"2017-04-05T14:58:55.000Z","comments":true,"path":"2014/03/23/ossf/","link":"","permalink":"https://blog.yunchen.tw/2014/03/23/ossf/","excerpt":"","text":"這次的課程總共分為六次來做訓綀到六月，由imacat依瑪貓帶著我們做完全的實戰課 雖然我尚未有上過專題課的經驗，畢竟要到大三才會有，不過聽ROCK說以往所謂的大學專題 大多都是從頭開始，然後做到學期末應付完這個project就結束了，也不會有學弟妹接手下去 和業界的生態完全不同，因此本次不但要參與接手專案開發，就算課程結束時東西還會持續 有人會去修改，算是滿正式的一種訓綀還不錯。 因為是一個中大型的多人開發專案，一開始便分成二大派別(業界和學生)共計7組的隊伍 一組大約有4至5人不等，並選擇一種程式語言做開發，接下來的訓綀要分工並且上台報告 而且還是下一次就要開始，我們只好硬拖著其它人下水全部都用Python(大笑) 話說回來還有Denny大大(SITCON總召)在我們這就沒什麼好怕的了(逃) “你們現在不是應該要待在立法院嗎?” &lt;-第一句就來這樣XD “誒 誒 誒，十點上課不要再看總統的廢話了 這不是昨天..不 前天就能預測他要說什麼了嗎?” “我本來也想到那教課，不過畢竟性質不太一樣…” “g0v不是真的臨時政府啦…那只是一群駭客XD” &lt;-結束的時候有人問的 果然最近的家常閒話都圍繞在這(茶) 再分組完之後首先編譯的第一個開放源碼專案就是pidgin…為什麼會選它馬上就知道 為什麼要編譯這個專案？阿用直接編譯好的專案不就得了，這樣還可以直接安裝多方便 這些的大前提之下都是你擁有管員權限XD 再加上並不是所有的專案都有提供已編譯的程式 此外如果想要獲得最新更新完的程式，直接用拿到的Source Code來做最快! 以pidgin解壓縮完可以獲得如下 當然這些開源的專案有個很大的特點在於約70%左右的專案都是用C來做Compile 要製做這些專案所用上的工具就包含了Automake &amp; Autoconf 等等 不過第一堂課也只大約略提，也許後頭會有機會碰到也說不定…其實第一堂已經夠充實了XD 接下來的實戰全在Ubuntu…Why? OSX不好嗎? 當然好阿…現場還一大堆Mac開頭的 可是當大家遇到編譯上各式各樣的Bug…還是乖乖開個虛擬機來安裝比較實在XD 不是沒有解Bug的精神，照學長的說法…請不要這樣搞自已XDDDD 檢查出現的各式各樣的問題，OSX就算裝了環境一樣吐給你看 我們可以先用 ./configure 去檢查所需要的環境，然後就是看似永無止境的問題 這時只好不斷的問問Google大神或到Stackoverflow請求幫助XD 真的找不到問題所在還得要看看 config.log 確認出了什麼事 仔細看還會發現有的會乾脆直接 #include abc.h 一個小程式看能不能work 這樣就可以直接知道該header是不是真的存在了… 再經歷一個上午在純白環境裝了一大堆所需要的library之後就會得到這樣 多出了一些東西像是config.h Makefile 等等 總而言之 config.h 是由config.h.in所產生出來的 兩個檔案的內容是差不多的 只不過config.h.in是用來偵測目前平台的環境變數，有的話就做保留，而沒有的則註解掉 藉由這樣的方式來讓程式知道是何種平台及該環境 至於Makefile倒是有不少功能，再執行make做編譯的時候會發現一堆CC開頭 那全都用gcc編譯不就好了? 這麼做除了累死要打一堆函數、變數等，也無法掌握該編譯哪些東西 Makefile.am 由前面說的 Automake 所產生的，Makefile.am -&gt; Makefile.in -&gt; Makefile 用vim來看會發現有個Extra_Dist 還包含不少東西…. 這些就是除了標準Library所要包含的額要東西啦(lib都在該目錄下的其它資料夾) 成功出現Makefile除了可以用make編譯之外 裡頭還有不少target可以讓我們使用 make check make test 這些都可以在最後的make install前做的小測試，偷懶的就是跳過直接裝(大誤) 當然還有一些像是清除或包裝等指令等等都可以在裡頭查到 make clean make dist 總算是真的順利裝好了Orz 可以用了囧~~~~It works!! 被pidgin搞了一個上午之後，下午其餘的綀習像是apache或PHP就不堪一擊了XD “同學告訴我說PHP直接./configure就過了 沒挑戰性讓我有點受挫” XDDDDDDDD 下次的課程要分組報告…該期待還是該擔憂呢?XD","categories":[],"tags":[{"name":"OSSFProject","slug":"OSSFProject","permalink":"https://blog.yunchen.tw/tags/OSSFProject/"}]},{"title":"SITCON2014學生計算機年會","slug":"sitcon","date":"2014-03-14T16:00:00.000Z","updated":"2017-04-05T14:58:44.000Z","comments":true,"path":"2014/03/15/sitcon/","link":"","permalink":"https://blog.yunchen.tw/2014/03/15/sitcon/","excerpt":"","text":"這是第二次參加SITCON了 時間過的還真快 去年大一第一次參加的時候根本就什麼都不懂T_T 而且也是第一次參加Conference 只是覺得什麼東西都好難，當時應該程語只學到Class 網頁什麼根本沒摸過XD 不過最大的收獲就是看到台上的講者展示自己的成果感到佩服 今年當然看到很多讓人感到興奮的東西，而且跟之前不同因為不懂所以不在乎 可以對他們所說的技術感到興趣，隨後Google和做紀錄 對自己來說是種成長吧? 上面這是今年SITCON被大家搞掉的座位表…苦主貌似修了一整天的Bug 真是辛苦他了 哈哈 今年的場地搬到了大家都很熟悉的中研院人文社會館，所以一下子就到達會場 不過總覺得效率有待加強，因為我在門口卡了快20分鐘才得以進去 學生採用學生證+簽名的方式比較耗時間，加上入口是分號碼，之前HITCON在門口幫忙時 都有人搞不清楚自己T-Shirt size大小導致混亂(最後還一堆人拿L 所以不夠= =) 如果有其它快速的驗證方式真的會更好…掃QR Code很快 但也考驗對會眾的信任吧~ 前面幾場有些是架站經驗分此，有些則是推廣技術，不過去年在事前參加都會提醒 會眾該裝哪些環境，並發放手稿和講義以利當場跟著講師實做學習~ 開場由鄭永斌和陳鍾誠教授與大家談談創意和資訊人的問題 像是身為資工人卻不會寫程式也可以第一名考上研究所、業界找不到人才等等… 此外今年也有像算命攤的主題沙龍和十分鐘的Short Talk就不再敘述了XD 這場任大的QML就是提供了簡易的語法來完成圖形介面，而且還支援了眾多語言、跨平台 Python如果我沒記錯應該是PyQt可以支援使用，而且看他越介紹越覺得有些熟悉 和我之前玩的Kivy超級像，有點異曲同工的Feel，小可惜的是講師最後沒有順利DEMO完XD 這場是今天讓我感到最熱血的一場(橘子不論在哪都會中槍XD) 這是一個想改變校園而誕生的選課模擬系統NTUST.CC 有興趣的可以去看一看，做的真的很棒，講師JSON敘述如何熱血來改變校園 只是因為室友隨口一句，網站就這樣出現了，點子真的要當下實踐才有可能成功啊~ 還分享了一些製作經驗、技術，這點真的讓我收獲很多很多 原來還有不少技術是我必須要知道，而且也很方便Haml、Sass、CoffeeScript等等 看來又有不少東西可以玩玩，可以的話就用這些東西從改變自己做起吧! 「寫了學三年的外掛所以就不感興趣了，我是來自天大地大的台科大」XD 精專反組譯等技術的大大教你如果寫外掛，不過當然不可能Live DEMO 不然等等又要被找去喝茶了(茶) 簡單介紹了一般常見的外掛分類共分為兩大類 自動化與記憶體(封包)修改，前者當然就是常見的按鍵精靈等，也相當好防禦 後者則是一般常見的外掛與手機遊戲常用的手法 講者還當場教起簡單的組合語言，大約十分鐘左右就講完一般常用到的語法…XD(還講的超好) 和一些反組譯常用的工具(IDA pro等)與反外掛程式如何阻擋以及又該如何…”反反外掛” 不愧是寫出熱門楓之谷外掛的達人 &lt;( )&gt; 最後當然要感謝這些熱血的志工們，總感覺很多研討會除了有固定一批人之外 還不時會多了一些熱血的肝(?，繼續加油下去吧! 整個Conference的品質就靠你們來共同維護了XDDD 照慣例的NISRA大合照 明年的此時希望自己能有更多的改變! 對於後續消息包含投影片可以到SITCON交流區找找SITCON","categories":[],"tags":[{"name":"SITCON","slug":"SITCON","permalink":"https://blog.yunchen.tw/tags/SITCON/"}]},{"title":"搞什麼一鍵登入 FJU一鍵登入Wi-Fi APP","slug":"project","date":"2014-02-27T16:00:00.000Z","updated":"2017-04-05T14:58:19.000Z","comments":true,"path":"2014/02/28/project/","link":"","permalink":"https://blog.yunchen.tw/2014/02/28/project/","excerpt":"","text":"受夠每次在學校登入WiFi都要打密碼嗎?受夠每隔三個小時網路又自動斷線又要重新輸入嗎?受夠隨著在各個大樓移動又要重新在不同熱點輸入一次嗎? *碎碎念…目前同時在做的ICAN爬蟲，剛開學沒什麼資料爬和測試就先暫緩囉!為什麼要寫這個APP? 當然因為我連打密碼都懶啊(逃)而且不覺得很煩很煩很煩嗎? XDDDDD每次用到一半就斷線 正在瀏覽的網頁又重新被導向到登入頁面然後又要輸入那個該死的LDAP…然後手機又難按的要死好啦…我承認我手機輸入很手殘 會一直點錯才很靠妖 那就先附上搶一鍵登入APP吧~(APK檔下載)FJU一鍵登入Wi-Fi APP BETA 1.0.0(File→Download):https://goo.gl/5LeUwZQR Code支援!! 實驗對象: 輔大WiFi使用語言: Python2.7.5 &amp; Kivy Language用到的套件:Kivy - 跨平台圖像處理就全靠它了另外GitHub - 原始碼整理好之後也會放上去 特色:說穿了 就…記住你的帳號密碼 然後送出去XD排版很難看 沒有特別美化、畫插圖 這也是特色(? 目前遇到的問題: 現階段只支援 Android 有關iOS我還要在研究一下 尚未支援圖書館-濟時、公博、國璽 帳號、密碼打錯它就擺爛給你看 不會檢查XD 我不確定全校大樓是否支援 我只有在SF聖言樓、ES進修部大樓、MD國璽樓、LM利馬竇 測試過因為我上課也只會跑這幾個地方而已XDDD 本來就是寫給自己用的其它地方還有待幫忙測試~ 話說回來…請不要嫌我美術差啊Orz 我本來就沒天份T_TAPP圖示我可是一格格慢慢畫出來的…要叫畫可愛圖示按鈕…辦不到囧 畫完之後在找線上優化APP圖示的方便工具設計APP按鈕原來這麼有學問…就+-用吧XD 管它什麼解析度大小最後搞出來就大約像這樣~ 為了偷懶一時，居然要花這麼大功夫去搞…好吧 至少每天都用得到XD而且也越寫越熟悉編寫流程了~~算是滿寶貴的經驗www My Blog:Click","categories":[],"tags":[{"name":"Project","slug":"Project","permalink":"https://blog.yunchen.tw/tags/Project/"}]},{"title":"跟Netman學Shell Script","slug":"shell","date":"2014-02-21T16:00:00.000Z","updated":"2017-04-05T14:57:54.000Z","comments":true,"path":"2014/02/22/shell/","link":"","permalink":"https://blog.yunchen.tw/2014/02/22/shell/","excerpt":"","text":"這次一樣來到了CLBC…的分部-德惠弍参 T23 還好事先有先確認XD … 不然真的會跑錯囧 ~ 一個在大安另一個則在盧州… 不過畢竟才剛啟用沒多久，不少人跑錯好像也很正常(汗) 新的分部在德惠街31號，不過我到的時候也差點找不到 … … 除了Google Map標錯地點、場地在地下室之外…根本沒有CLBC招牌啊囧!! 因為是在地下室的關係，當然收訊會不太好，不過網路依舊順暢100M~一進去還會自動連線!? 原來它是把大安的AP直接搬過來用囧!! SSID、密碼也一模一樣，難怪想上網的時候發現居然已經連好了 整個場地和大安本部不同在於是直的，類似傳統教室，人坐越後面會有看不到的情況 因為場地還沒建好，隔音效果也不好，別廳的聲音會傳過來 看來有很大的進步空間~ 這次的研討會因為講師的高鐵延誤，所以請鳥哥上台代打XD 談談他在學校因為設備的辛酸血淚史(? 查了一下酷學園的網站，此鳥哥還真的是 “鳥哥私房菜”的鳥哥 XD，常常在看 也有他的寫的書 今天終於見到本人啦~~XD 如果學校的也有他在教Linux不知道有多好Q_Q 這一次Netman講的Shell Script算是完完全全從基本功講起，沒來的人真的虧大了 雖然學校有開Unix課程，作業據說也是寫Shell Script，不過我想應該…(汗) 簡單講Shell Script就是把一大堆指令寫到文字檔裡頭…講完了 下課XD ← 講師一開始就這樣搞笑XD 在快速的介紹Shell Kernal Hardware的關係後，就開始談Shell的種類還有基本的概念 因為 IFS 所產生的BUG看來也是一大問題XD (Command Option Argument間的分隔) 所以有一些手法可以讓它變成普通空白 quote 整場讓我最印象深刻的就是他逗趣的比喻 Hard Quote 與 Soft Quote….XD ‘Hard’就是很硬的意思，在裡頭就是免談，管你是什麼東西 “Soft”相較於Hard就是身段放比較軟，可以談判的意思 像(如下) Soft Quote就像強盜一樣，看到$這類的土豪 就會跟你談判 比喻超妙XD 可惜用文字實在難以形容~~不過如此一來確實很好理解 原來一般的Shell Running大多都跑在Sub Shell下，所以不會引響當前Shell的環境 有些比喻如果是寫過程式的話，以區域變數和全域變數的方式來講也許會不錯 雖然他講的已經很詳細，不過應該也是功力不足，第一次接觸到PartVIII的部分已經有些吃力 不過等玩過一遍之後，相信在回來看Data Stream應該會更快上手才對 這是這次研討會的投影片 可以參考看看 跟Netman學Shell Script投影片:Click","categories":[],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://blog.yunchen.tw/tags/Shell/"}]},{"title":"NISRA-Hachathon","slug":"NISRA","date":"2014-01-24T16:00:00.000Z","updated":"2017-04-05T14:57:44.000Z","comments":true,"path":"2014/01/25/NISRA/","link":"","permalink":"https://blog.yunchen.tw/2014/01/25/NISRA/","excerpt":"","text":"-前言- 感謝 理工學院願意贊助此次活動，還有評審們的肯定，及在場共同開發、努力的所有人 這是我第一次參加黑客松的活動，雖然之前早有耳聞這類的消息 但一直找不到機會參加，今天終於有幸入坑(大誤) 後座力就是回家睡到不醒人事… 不過整個過程很歡樂XD 收獲也很多，能夠大家一起聚在一起愉快的開發，而且還有 教綀在旁邊隨時可以問，更重要的是充滿食物，人不要臉就天下無敵，所以我們就在 一開始就衝去拿一盤零食 YA! 邊吃邊開發這才叫做程序猿(誤) 如果提供給你一個超棒的自主學習環境給你開發，何樂不為? 總比在一個專題實驗室好多了 在28小時內完成學習、實做、除做的動作，對任何人都是考驗，願意跨出第一步來參加比賽 我想都是非常值得鼓勵而且都『邁向強者的第一個台階』了吧! 關於 -行事曆整合語音提醒- 很榮幸能拿到這次Hackathon的第一名，對我們來說都是讓人感到興奮的震撼! 不過名次是其次，重點是能在這之中，獲得了什麼、改變你什麼，沒什麼比自主學習和回憶更重要了 Kivy這個用來開發不論是手機Android、IOS、Raspberry PI這跨平台的圖形介面 差不多在一、二個多月前，我在Python Taiwan社群上看到有人在討論Python的介面開發 讓我好奇心大發，立即想嘗試看看，在PYQT和Kivy…等等 抉擇了很久，後來發現Kivy 是最新的就直接嘗試了~不過正如最新…很少人有用過…教學文自然就超少 連社群上有人哀嚎怎麼學Kivy都沒有人回覆，我只好啃官方的Tutorial和官方FB的教學 在經歷非常長的一段時間後，終於摸出了成果出來(取自12/29 FB動態此時根本還沒打算報名XD) 也就有點頭緒和怎麼上手了~~超感動Q_Q 至於我們所使用的服務，當初會用上就是在PHPConf 2013的LightingTalk有人介紹Nexmo 由於早在此之前就非常感興趣，雖然帳號註冊好了，但一直找不到機會去開發， 直到黑客松的一星期前左右，看到皇毅學長示範DDOS(? 惡搞(? 同學的手機(? 用上了PHP和這個服務，讓我想起了這回事~我們才確定組隊 刷副本、打寶、綀功打怪、吸%… 阿不是 是參加黑客松和確定要做的東西~ 才趕緊到KKTIX報名參加 -Hackathon- 在正式倒數黑客松開始後，由於皇毅先前就玩過語音服務，不過一直有中文顯示和使用的問題， 所以前面大多的時間，我們都在研究如何顯示中文和講中文，另外一方便也想盡辦法修改成 能夠用在Python上，最後終於搞定了這個苦差事~~~我們才開始做Hackathon真正要展示的東西 簡訊通知 拜某學長推坑所賜(大誤)，目前和清大合作的國科會計畫正是使用Flask &amp; SQLite3 所以乾脆架設Web就直接使用Flask了~在一起搞定絕大多數的前端和後端之後 剩下的部分就開始分工合作了~ 學長負責修改資料庫和前、後端需要加的功能 我則是想到先前不是有玩過Kivy了嗎? 那是不是能寫成一個App做連結呢? 於是就開始嘗試XD 然後中途發現了不少的Bug和不好用的地方，而且官方都還沒解決Orz 像是不能打中文字，所以還要包字型檔…等等一大堆問題Orz 在APP頁面切換和排版花了不少時間，官方的Tutorial真難懂~”~ 還有Kivy有用上 自己獨家的kv語言，所以在整合也是吃盡苦頭，在帶著睡意熬了整個半夜都沒睡後 雖然還是有不少搞不太懂的地方，不過終於把介面做出來了Orz，EXP↑↑↑ Web Android APP 原本Android APP也要和網頁展示一樣都是寄簡訊或者是寄語音訊息 後來在最後一個小時想到了新的梗，源自於我覺得一次傳多個語音訊息應該沒問題 就立即加速修改最後的成品，所以京有了這樣的一個超大按鈕放在最後XDDDDDDD 語音訊息:警告! 警告! 預計老師將於稍後點名! 請同學火速趕至教室上課! 謝謝 皇毅還靠妖說未免也太白爛了XDD 管它的~~~XD 於是就這樣DEMO了 王國華主任:可是我上課點名都會要求把前後面給關起來喔! (我整個笑翻) 因為是語音的關係，所以如果有公佈發表影片的話，有興趣的建議看之後的成果錄影 最後感謝教綀的付出，讓我們能有完整的概念和省了Debug的時間感謝學長謙組員，能夠跟大神合作真是大棒了XD 明年如果能在舉辦…前提是有經費的話XDD 何樂不為?(完)","categories":[],"tags":[{"name":"NISRA","slug":"NISRA","permalink":"https://blog.yunchen.tw/tags/NISRA/"}]},{"title":"Taipei.py十二月聚會","slug":"taipeipy","date":"2013-12-25T16:00:00.000Z","updated":"2017-04-05T14:57:30.000Z","comments":true,"path":"2013/12/26/taipeipy/","link":"","permalink":"https://blog.yunchen.tw/2013/12/26/taipeipy/","excerpt":"","text":"兩個月沒有去參加Taipei.py了，而且正巧期間信義線通車，從輔大到CLBC 表面上看起來坐的站數一樣，實際上…中間可以不用在忠孝新生和中孝復興轉車 嗯…常經過這兩站的都知道…囧 大安站的出口原本也只有一個，自從全面開放後 我一到站…迷路了Orz 只好跟著人群走，以後去CLBC要到六號出口~ 所以真的是越來越方便了呢~ 這次的聚會的重頭戲在第一場就開始了 他是去年Python Conference的總召，也有人期待很久了，所以這次人也超多 『信不信我能用Python寫的跟C跑的一樣快』 此話一出立即獲得熱烈掌聲 祕訣在於 Cython = C + Python 由於講者的工作是處理大量數學運算方面的 所以對於速度很講究，『如果原本要一天才能運算完的東西，現在只要兩個小時 何樂不為呢?』 並且實際用簡單我語法展示給我們看差異… 雖然只是簡單無意義的回圈XD和一堆把陣列資料放來放去的語法 不過僅僅只是改了 宣告 資料形態、List的大小(上述在原本Python因為是動態資料所以不用) 速度就比起原本的快達200倍…也難怪原本要算兩天的東西，二個小時就可以算完 所以動態資料的方便就有它的代價~要怎麼靈活運用 就看開發者自己本身囉 據本人透露如果真的要運算大量資料 Python + C 最大極限，以目前遇到工作經驗來說 可以只和C語言差到2倍，不過如果真的有需求，再來用C寫就好，也因為他自己是重度Python 的使用者，所以能Pyrhon寫的就用XD… 第二位講者和大家一起討論Cheese Shop~ 它賣的不是起司XD而是Python Package sudo pip install 是我們一般裝Python套件的方式當然還有egg 不過很多東西 『我們其實不知道他到底幹了什麼XD』 所以在去年美國的Python Conference就開始在推廣Wheel 雖然我也還沒使用過，不過感覺這東西真的有可能會改變以後我們不論上傳套或下載的方式","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.yunchen.tw/tags/Python/"}]},{"title":"大家來學Vim","slug":"vim","date":"2013-12-07T16:00:00.000Z","updated":"2017-04-05T14:57:17.000Z","comments":true,"path":"2013/12/08/vim/","link":"","permalink":"https://blog.yunchen.tw/2013/12/08/vim/","excerpt":"","text":"標題應該要改成跟以前NISRA的課程一樣XD 不只真男人要會而且正妹也應該要會用的 Vim 那時候大一看到這個標題的第一印象是…這個講師真的TMD的太酷了 不過當時程式能力超弱XD 等等…好像也才7個月前的樣子麻~ 才剛學會寫class 大概架構的程度而已吧? 那時候NISRA課程把Vim排在玩玩 Linux-Ubuntu之後，就要教文字編輯器~不過那個時候怎麼可能會想這麼多啊~ 寫C\\C++ 用DevC++多好用啊~寫Java 用Eclipse、JCreator不就好了~ 所以上完就放生了Orz 因為頂多會進編緝模式和存檔退出，其它都聽不懂就覺得不好用 就放生了XD 那時候程式語言不強何況是要自虐自己哩!! 原始的vim大約長這樣 後來慢慢開始學Python、學寫HTML&amp;CSS 學長、姐教我們的就是用Notepad++ 覺得不錯用 就開始了這段由台灣之光腳本編輯器的學習之旅XD 不過學過腳本語言像Python的就一定知道…縮排的問題很重要，特別是tab和空白 這兩個是完全不一樣的東西，直譯器可是會翻臉不認字的!! 那個時候剛好是搞什麼競賽，就是因為這個東西debug到吐血，因為根本沒注意tab+空白混用了… 後來發現才把tab全部取代…成空白 除了這一些小問題之外，因為開始想寫GUI介面、用Python架後端，常常要試就是寫好 才用IDE去開…非常的麻煩……不過因為Linux稍為熟悉了，想到可以ctrl+Z、fg切換 就想起之前學的Vim ~ 然後近期就開始用起當年學不會的Vim 剛好又在Openfoundry看到龍哥又要再開一次Vim教學!! 而且還是整天的!! 滿心期待的想要報名…結果快到00:00報名…睡著啦Q_Q 就沒報名到 不過今天還是死纏爛打還是不要臉的跟去了XD 還好有空位，不然就要有站一整天的準備囉 前一天還特別又重新看一遍當時的錄影，如果用”聽懂比例”來說 大一的時候: 剛聽完課只懂10%昨天: 又看了一遍錄影60%今天: 上完課90%↑ XD 比起當初僅僅只有1個半小時左右的濃縮版，今天真的完整的玩了一遍， 整個進步超多啊XD 而且又學到更細更多東西!之後好好綀功，相信能更加少手 反正就如畢業學長所說的，我現在有的是時間啊XD 打CODE慢又沒差XDDDD 不急所以有時間適應~ 有了大師推薦的編輯器，就拿來好好玩玩最近在試的玩具…用Python開發GUI甚至Android App的kivy!","categories":[],"tags":[{"name":"Vim","slug":"Vim","permalink":"https://blog.yunchen.tw/tags/Vim/"}]},{"title":"NISRA-Javascript,密碼學","slug":"NISRA","date":"2013-12-02T16:00:00.000Z","updated":"2017-04-05T14:57:07.000Z","comments":true,"path":"2013/12/03/NISRA/","link":"","permalink":"https://blog.yunchen.tw/2013/12/03/NISRA/","excerpt":"","text":"2013-12/03在生日的時候被拖去講課Q_Q 這是什麼巫術未免也太剛好 在前面幾堂課程轟炸之後(上學期根本全部都是網頁~) HTML、CSS、PHP 就佔四堂了~所以就想找個簡單一點的，不用打任何code 可是又要和Javascript有所關聯，所以就想到了Google的新玩具啦! 這次帶學弟妹們玩玩Google Web Designer，這是一個Google為了給廣告商 有個更加良好的開發環境的產品，因為操作方便，所以也有不少人拿來為自己的網頁做美化 而且這也是在完全不會網頁語法的情況下，能夠做出東西之一，所以拿來教也比較輕鬆 在完成一連串的綀習之後，讓大家做出一個NISRA的廣告~ 這是會動的!! 不過圖片看不出來Orz 點下面的連結會到NISRA的官網 雖然說已經一步步再教學，不過總是會有的學弟妹會不知道神游到哪去XD 所以就必須要停下來關切一下，我想這就是實作的課程最大的困擾~而且還會有奇怪的問題出現Orz 我一直滿擔心投影片和實作的東西會不夠，所以準備不少東西，不過最後還滿多東西沒有交代清楚 因為後半的課程還是得乖乖寫Javascript，不過這對不論是講師或大一在30分鐘內有所成果都是 負擔~”~ 所以也只能夠簡單的做介紹，實做沒空帶，這點是真的滿可惜的，不過我想至少有所接觸 以後要做才會有所想法，而不是空轉 用Javascript寫一個Google定位 時間分配上我想以後應該要有所調整~這應該就是我最大的收獲了 2014-01/21稍為碎碎念一下有關這次的寒訓 因為剛好在期末考完之後，所以我也是考完就要準備投影片，不過還好在第二天有比較多時間 去改善我的投影片，如果要有更好的品質，不論是我或是其它人，時間都是不充足的 這時應該換個方案，看是找以前的投影片和講師就是個選擇，我想會更好 再來是題目的問題，因為當初要挑戰自己，所以就採用大家提出課程名稱 以抽籤的方式做分配，但沒做篩選和考量時間再加上兩天的課程全部都沒有連貫 在台下聽的，或者做投影片的都會非常痛苦吧~ 我抽到密碼學也算好運，雖然當初自己覺得這…不是數學嗎 而且如果像學校的資安課程(誤) 台下會睡一片或做自己的事囧rz 而且有些東西在金盾集訓就有了，所以就20%現代密碼學 80%古典密碼學的課程內容啦 給大家解一些好玩有趣的東西，在我高中的時候就很喜歡打電動，而這些電玩 藏了非常多的『彩蛋』，也就是給玩家去解的一種秘密~或者是電玩的後續情報 都會放在這些裡頭，古典密碼學就有很多這類的例子，所以就帶大家玩玩這些彩蛋 只是…原來大家都這麼厲害，天啊! 幾題一下就被解完，整個出我意料 以後還是帶多的東西會比較好XDD 教不完也無所謂XDD 免得緊張講的快或大家解太快XD 投影片都在這","categories":[],"tags":[{"name":"NISRA","slug":"NISRA","permalink":"https://blog.yunchen.tw/tags/NISRA/"}]},{"title":"102年度資安技能金盾獎決賽","slug":"secure","date":"2013-11-28T16:00:00.000Z","updated":"2017-04-05T14:56:51.000Z","comments":true,"path":"2013/11/29/secure/","link":"","permalink":"https://blog.yunchen.tw/2013/11/29/secure/","excerpt":"","text":"經過一番努力之後，終於有機會可以現身在決賽會場了! 好棒的翹課理由啊XD 是公假啦~而且今天還滿堂WWWWWW 我是連初賽都是第一次XD 現在想想還滿不可思議的…既然有這樣的機會 當然就是要先和橘子來張照相囉! 阿…不是 是要好好把握… 不過難得可以跟他入鏡XD 平常都不露臉的~而且還穿會服來!! 這不是機會不然是什麼? 在聽完一些規則之後就要先去吃午餐然後等比賽囉~ 恩…好像哪裡怪怪的……傳聞中的漢堡山呢Q_Q 真的是便當嗎? 不是吧! 可惡…本來想說難得有機會可以一窺大食團的說 休息場地，旁邊是電腦教室，所以接下來的五個小時隨時可以出來喝飲料、咖啡、吃點心 比賽開始就是跟隊友們全神貫注的在打WarGame 麻煩的是雖然大會提供每隊6台電腦，但是這裡一定要碎碎唸一下 只有一台能上網…所以三個人要查東西只能輪流 6台電腦不能互聯…其中五台只能用USB 所以你會看到不僅僅是我們這隊 解個題目大家的隨身碟丟來丟去的輪流用…送KEY那台還只能用手慢慢輸入 整個感覺超克難…有夠麻煩的囧” 去個廁所也要報備+陪同 因為怕有人會作弊、討論 httpsS的題目有兩題 而且只開放一個小時做完這兩題，所以只能優先去處理 也是怕有人作弊開通訊軟體向外求救…應該有更好的預防方式吧Orz 這五個小時之間跟學長們交流，整個實力有突飛的感覺 因為這些東西是平時不可能玩到的XD 難得有機會一定要好好吸%一下 玩了一大堆的工具 今年網頁相關的題目不多 反而是反組譯技術相關居多，所以只能好好研究程式碼來分析行為 有些WarGame的經典題這次也有…像是解檔500次壓縮拿key之類的XD 密碼還是檔名Orz 而且還是最後才發現…只能怪我們的思維、敏感度還不夠的關係吧Q_Q 只要拿到300分就能進前8，只可惜我們只有200分 而且還會發現到一個斷層就是 第一名 1500分第二名 1300分第三名 700還800 忘了第四名 200分…後面就一堆200 至少我看到最後30分鐘黑屏前是這樣子…超級大斷層啊… 解出來的兩題，第一題大部分隊友都有拿到 提示還很靠妖…你為何而哭泣…這什麼鬼東西啊XDDDDDDDDDD 就是要我們去注意 .onion 這個服務 把URL藏起來，把原本的URL找出來就對了~ 另外解出來的一題就是最後一題 是一個猜拳不論怎麼猜都會輸給電腦有問題的程式，那我們首先是找工具分析是用什麼語言寫的 結果發現是 .NET/C# 可以完完全全的反組譯，所以我們用了一套叫dotpeek去取得原始碼 分析之後發現有一段用base64是加密的字串 解密後得到…upupdowndownleftleftrightrightba 這不就是任天堂經典招牌密技嗎XD…很像啦~ 而且要在1秒內輸入完 按鍵精靈就可以輕鬆辦到了，果不其然猜拳程式跳出一個可以輸入密技的地方!? 繼續分析程式碼我們可以知道 密技:用base64加密的gold_key … 輸入密技 YA 有KEY了~~~ 至於其它的題目，可能之後會找時間大家一起來解決 如果你是NISRA的幹部們應該都有拿到 有需要的話也可以找我拿，大家一起來綀功XD 最後贈品:藍芽喇吧、睡衣一件(誤! 一個金盾下來…收獲真的不是聽課能比擬的，外面也學不到這些東西 重點是可以聽到一些人分享他們的心得! 這遠比解題目要來的珍貴許多! 明年一定要在拚進決賽! 至於得獎麻~~只要有綀習 希望無窮…畢竟那個斷層…XD 果然不是一下子就能到達的境界(茶)","categories":[],"tags":[{"name":"Secure","slug":"Secure","permalink":"https://blog.yunchen.tw/tags/Secure/"}]},{"title":"A day with Google","slug":"google","date":"2013-11-23T16:00:00.000Z","updated":"2017-04-05T14:56:42.000Z","comments":true,"path":"2013/11/24/google/","link":"","permalink":"https://blog.yunchen.tw/2013/11/24/google/","excerpt":"","text":"今天來到華山文創園區來參加Google的展覽，我會來這裡純粹太閒XD 據某位學長透露他只是想來拿小袋子 哈哈! 明明還有專題要發表，勇氣可嘉!! 我們為了要能排到第一輪進到會場的，所以提前兩個小時就到了 作夢想也想不到的是…居然已經有快100個人排在我們前面!! 這什麼鬼!! 沒道理啊!! 一群宅男為了能到裡頭參觀，難道跟學長一樣愛小袋子嗎? 後來才發現我們根本排錯啦XD…這裡是下午的活動…(疑? 原來旁邊是水樹奈奈的簽唱會啊…所以在場的是…提前5、6個小時甚至更早到的… 回到真正的Google那邊，也才10個人左右在我們前面，這還差不多XD麻~ 拿完號碼牌在旁邊輕鬆等待 一進會場大概長的像這樣，就像捷運收票口~ 不過這裡驗證的不是票，而是你有沒有手持智慧裝置並登入Google帳戶 因為接下來的活動全是和Youtube、Google+….等等有關 一開始只是很簡單的Google Maps搜尋路徑 YouTube還滿酷的，現在已經可以在上頭做影片編輯再轉成另一個影片 還有調整快慢很方便 再來還有像是照片分析，我只要拍好比…生薑，Google就會很聰明告訴你那是什麼 然後搜尋 其它像是語音功能可以邊運動邊使用服務，還有翻譯XD 實習生一口超標準印度話!! 有了它就能及時語音翻譯 最後則是比賽Google搜尋，贏的人可以拿到一個Google杯墊 不過我手殘搶不到Orz 學長用跟Google工作人員借來的Nexus 7趁他還在講解的時候偷灌超注音XDD 才幾秒就找到了 誰搶得贏你啊(大叫 理所當然就被他拿走了 工作人員:這麼快啊!! 全程大約只有30分鐘左右而已，快到來不及慢慢拍Q_Q 最後就附上一張抽獎卷和Google給的小禮物:紙膠帶XD 好像哪裡怪怪的? 沒錯，最後沒有拿到小袋子XD 所以學長白跑一趟了(茶) 人太多了，所以小禮物也跟著縮水了-.-","categories":[],"tags":[{"name":"Google","slug":"Google","permalink":"https://blog.yunchen.tw/tags/Google/"}]},{"title":"Raspberry Pi首次社群聚會+mini小鍵盤開箱","slug":"raspi","date":"2013-10-28T16:00:00.000Z","updated":"2017-04-05T14:56:31.000Z","comments":true,"path":"2013/10/29/raspi/","link":"","permalink":"https://blog.yunchen.tw/2013/10/29/raspi/","excerpt":"","text":"4天前才去了一趟CLBC -Taipei.py 今天又去了一趟CLBC 不過這次終於不是聽跟Python有關的……而是叫樹梅派的… Raspberry Pi官方推薦語言……噗 果然還是脫離不了它… 比較有趣的是跟皇毅學長去的時候，同一地點…同一時間…梅老師也在這打了卡XD 早上才剛上完梅老師的遠距醫療，晚上又碰巧在同一個地方出現 哈哈 而且還是在樓下喔(汗) 早知道去樓下裝熟聊天「順便」裝一杯汽水上來…為什麼這次樓上只有水可以喝Q_Q 這次是Raspberry Pi社群第一次在台灣辦的Raspberry Pi聚會，吸引不少人來朝聖 所以也請了剛出書沒多久的葉難來談談Raspberry Pi從入門到應用~ Raspberry Pi 應用於氣象觀測上 簡單的基本介紹了Raspberry Pi的理念、由來及一些入門，算是給完全的門外漢聽的介紹 主要讓我們看到了在國外神人的加持下，Raspberry Pi被發揮到什麼樣的地步 國外學生專題Air Pi 中間的休息時間當然就是要去看看講師帶了哪些新玩具來XD 木質感的壓克力感覺真不錯…只可惜我忘記去拍講師的Raspberry Pi了Orz 這塊版子可以拿來小超頻，而且也完全不須要散熱片，甚至還有防護機制防止燒壞 當然也有追求極致的超頻玩家連這塊小板板都要用水冷…那就另當別論了囧 混亂桌面上暗藏許多的神器 中間當然就要來一點硬的，談談技術及實作，最後理所當然的Live Demo 用Raspberry Pi實作無線路由器分享~ 網概的知識在這裡受益無窮!! 示範的指令還跟金盾答案一模一樣…該說這是某種緣分嗎O_0 Live Demo!! 最後講師則是來談硬體…不塊是硬體，果然超級無敵硬 不過自行在家展示的遙控車超酷!! 不過上述隨便聽每個都要5000多行code才能實做Orz 既然要玩Raspberry Pi ，怎麼可以少了最重要的鍵盤呢! 忘了是誰說的XD…少了鍵盤的駭客就跟手殘沒有兩樣XDDDD 開箱MT-200 為了這一塊小平板，等了一個星期終於從遙遠的對岸送來了 整個大約NT $160 ，不過再加運費麻….都可以多半塊板子出來了囧 既然這麼便宜我也不嫌什麼了，至少能動就好XD mini小鍵盤+USB無線+microUSB轉USB線+說明書+小拭鏡布 看的這個也想到今天居然有幸摸到剛出爐的Firefox OS手機…值得了XDD 主打支援WIN8手勢 左側手寫板 右側平板鍵盤 既然這篇是再主打Raspberry Pi 沒道理不拿來玩看看吧! 使用心得是感覺還不錯，藉由按壓小平板鍵盤，還會震動~就可以知道有沒有按到該鍵 不過我沒機會用上手寫板，所以就不太清楚，而且也沒WIN8電腦實戰XD 反正我主要也是用在Raspberry Pi上的 :p 成功輸入帳號:yunchen 聽說還會有下次的社群聚會，到時候再來去瞧瞧O_0 至於之後可不可以實作這塊板子給大家看…你不是還有一堆事嗎(瞪) 就下學期有空再說了囧rz 看得到跟看不到的地方…都是線…都是線…都是線…","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.yunchen.tw/tags/Python/"}]},{"title":"102年度資安技能金盾獎初賽","slug":"goldshield","date":"2013-10-24T16:00:00.000Z","updated":"2017-04-05T14:56:14.000Z","comments":true,"path":"2013/10/25/goldshield/","link":"","permalink":"https://blog.yunchen.tw/2013/10/25/goldshield/","excerpt":"","text":"第一次參加金盾，最後悔的就是大一因為死黨覺得太難不想參加，而我也跟著放棄 因此就少了這麼良好的訓綀機會，而今年就當然不能錯過!! 一開始學長找我組隊真的嚇一跳，不是應該找同年級的比較好嗎XD 找個菜鳥幹麻 不過既然都選擇參加了，當然就應該要盡我所能的去做好它 NISRA也開始金盾集訓，被誘騙之下我也要講一堂課Q_Q 把自己搞的那麼累幹麻Orz 收到集訓準備，而且要正式報隊參加的時候距離初賽也只剩下一個月左右， 一方面要廣泛的學習另一方面就是要備課，整個時間極為吃緊 中間拖鞋臨時不能來要延到下星期，原本備課整個提前一個星期Orz 再加上學校…為什麼這時老是出一些二、三千字的報告 不然就是寫個短短的25行程式碼又要我交書面報告…(碎碎念) 好在最後有趕出成果，真慶幸暑假的研習營讓我有不少東西可以講 金盾集訓-網路安全 筆記 第一次講課難免會有所緊張，也碰上不少突發狀況(汗) 原來當一個講者真的不簡單，課程準備還要有經驗臨場反應 而且一口氣講了90分鐘的時候，喉嚨真的會超乾，難怪老師上課要一直喝水… 實作果然是最好帶也最殺時間的(笑) 而且也可以看起來比較有趣 不過為了能讓學弟妹聽得懂…其實也去掉了不少東西 可是還是有人說聽不懂囧 附上當日投影片: 投影片 為了能夠搞好金盾獎初賽 所以開始規畫一天大約要解決一個章節中的一小節，每天至少抽出二到三小時去準備 每個選項盡量都去做Google，盡我所能的去學好它，畢竟早晚都要搞懂 去硬幹這種事付出的代價時間可以說是相當可觀…Orz 不過收獲卻出乎意思的多，整個補強了大一計概的概念，甚至物聯網概論的課至少一半都會 原因就在於準備了 資料通訊、網際網路介面基礎、網際網路服務應用、網路安全 整個網概都有綀到功XD 光是這一個月就覺得自己進步超多~ 不過整本也被我翻到快要爛掉了….囧 到了比賽當天來自北、中、南共計154隊參加，壓力還挺大的， 和另外兩位學長攜手合作花了60分鐘左右將100題答完，還滿有效率的XD 這次不同於去年，沒有考雲端的問題 倒是有了不少像是防火牆、VPN、Linux用戶帳號資料管理、Windows指令、協議 等等 成績公佈的時候，其實我根本就還不知道這回事XD 我趕下堂課到教室的時候，有人跟我說恭喜 哪尼!? 還以為發生什麼事了… 趕緊打開官網 整個超感動，154隊進入決賽只有31隊…辛苦果然沒有白費Q_Q 再來就是一個月的決賽…中間有期中考…更有數也數不清的作業+報告… …NISRA還要再講一堂網頁…我可以假裝沒這回事嗎(淚) 看來下個月又是精彩的一個月(攤) 最後要說期待決賽也不是，先期待能熬過這個月好了","categories":[],"tags":[{"name":"Secure","slug":"Secure","permalink":"https://blog.yunchen.tw/tags/Secure/"}]},{"title":"Taipei.py十月聚會","slug":"taipeipy","date":"2013-10-23T16:00:00.000Z","updated":"2017-04-05T14:55:20.000Z","comments":true,"path":"2013/10/24/taipeipy/","link":"","permalink":"https://blog.yunchen.tw/2013/10/24/taipeipy/","excerpt":"","text":"這次的聚會人超多的Orz ，因為是下課直接趕過去，到的時候已經坐滿滿 還不是普通的滿…是滿的後面的人拿椅子已經坐一排了XD 所以就只好乖乖的擠到後面去啦O_0 這張根本看不出後面的人其實已經坐滿滿了XD 這次邀請到在KKBOX開發IOS版的來分享心得，應該說IOS版的都是他做的 然後談一些使用Python用來測試點歌清單跟同步是有多好用~ 中間順便要求中斷錄影…不斷的靠妖老闆到底在想什麼東西XDDDDDD 還滿有趣的，其它總覺得這次的徵才廣告還滿多的，連Lighting Talk都是 不過你發給我傳單也沒用啊(汗) 看不出來我很嫩嗎XD KKBOX with Python 最近 社群流傳著一種神器，聽說只要使用了它，Python的開發速度會快兩倍 而且我還看到滿多人在使用它的，好奇心的區使之下，連上了Ubuntu下載了套件來試試 不用還不知道，一用之下驚為天人，而且我根本還沒看說明，想說隨便玩玩 就以一個最簡單了ls 如下: 我居然可以用Python的語法來存取Linux的指令…超猛的!!! 而且聽說其它的功能已經強大到不可思議的境界，找時間來玩玩，以後搞不好就入坑了XD 另外還有介紹SQLite3 如果我想做個小網站，以後就決定是它了!! 未免也太輕巧了， 而且資料型態只有五種:NULL、INTEGER、REAL、TEXT、BLOB 也只有一個db檔就搞定，搞不好這個就足以滿足我的需求了Orz 聽的越多，就會感覺Allen學長所說的和業界的洪(紅)溝? 超大 一些開發者在分享他們的專案、心得總能得到很多共鳴，不過我總覺得超硬… 和一些社群在業界工作的大大談談，給了我不少相當實用的建議 看來我Python真的是要花時間重新好好學學了 先把Python官方的Tutorial給吃掉…好好的重新打好程試語言的基礎 再來就是研究Python for Data Analysis 他們跟我提到有次到Evernote美國總部居然桌上有人擺這本，可見有多強大 而且我也不奢望學校的資料結構能帶給我什麼了…做好自己打掉重綀的心理準備 最後就是可以選擇該往什麼方向走 都以為我已經畢業了，跟他們說我大二還會感到驚訝，我看起來沒這麼老吧O_0 談到NISRA社團，和資安相關，又丟給我一本Violent Python “等你Python熟綀了 可以考慮看看” “你們在幹麻”←另一個加入話題 “他說他想當駭客XD” “……..囧(抹黑啊!而且我不是說我初學沒多久嗎Q_Q 根本超嫩)” 這個月收獲還滿多的XD 期待下次11月份的聚會會有什麼更有趣的東西吧~","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.yunchen.tw/tags/Python/"}]},{"title":"PHPConf2013第三屆 PHPConf Taiwan","slug":"phpconf","date":"2013-10-04T16:00:00.000Z","updated":"2017-04-05T14:55:05.000Z","comments":true,"path":"2013/10/05/phpconf/","link":"","permalink":"https://blog.yunchen.tw/2013/10/05/phpconf/","excerpt":"","text":"這次和HITCON一樣，在中研究院的人文館，不一樣的是少了刺激的綿羊牆XD 對於後端，大多人第一個想到的就是PHP，所以當然就要來朝聖一下地表上最強的PHP高手囉 總召:結果這些人都告訴我說他們都沒在用PHP(淚) 我很喜歡這次的標語:IT’S CODE NOT MAGIC做為一個程序猿(? ，只要能做CODING就能改變些什麼，心裡除了感到不可思議，也非常的踏實 開場前忙錄的艾倫和龍哥 其實今天最主要的目地就是來聽矛盾大對決啦!! Orange &amp; allenown 矛盾大對決 - 能入侵任何網站的駭客 vs. 絕對不會被入侵的網站 Allen Own X Orange Tsai 據說把中間的&amp;改成X，有人會異常興奮(? 開戰前，當然要先禮再後兵囉! 所以就要有交換名片的儀式啦~ 來自東方神秘的艾倫，據說有斬殺(切)巨人(橘子)的實力XD 我覺得應該改為: 老闆的陰謀與員工的逆襲 一方做防護，另一方則是找弱點並修改首頁 戲劇效果，兩人不惜犧牲色相，為了資安而有了這場相聲XD 從實際展示手法，來告訴大家資安的重要性，同時做為一個網管應該要有的概念 網站、資料庫不能放在一起，被置換的首頁單純換回來是不行的 密碼被挖出來了XD Password:orangenogg (狂笑) 秀出了一些非常典型的攻擊手法，SQL Injection和XSS，對字串上的檢查應該要有怎麼樣的防護 以及黑名單與白名單該怎麼去拿捏對網管來說都是一大課題 所以 Allen老闆?橘子被扣薪了嗎?XD” 最後還展示了連PHPConf 網站都可以實做的PHP-CGI Argument Injection XD 所以也要記得時常更新 保持最新的版本 消失的一分鐘 其它讓我印象還滿深的就是Gearman Demo，能夠把工作丟給另外一台電腦，就不用傻傻的等 就像Youtube上傳之後，自己就會轉檔和發佈~ 這次是用簡單的e-mail來實作，體驗一下它能帶來的便利性 PHPConf German Demo: Decmo 不過有人實作XSS 因為沒防護Q_Q 【script】alert(“Cyberwar : In hack we trust.”)【/script】 所以後來就關掉了Orz，還滿可惜的 有機會我也想寫一個來玩 Python支援:Web 人超多的Orz ，尤其是閃電秀都擠進同一廰，只好在上方看囉 另外像是Nexmo 電話和簡訊的價格還真是低的讓人心動 有機會一定要去玩玩，連回覆Line都可以應用的樣子 Lighting Talk:我的密碼沒加密 ，你的呢? 今年的PHPConf還滿精彩的，唯一的怨恨就是食物太早被DDOS 難度不一的課程似乎是兩廳交錯排，所以像我們這種吃軟不吃硬的就只好跑來跑去XD” 那希望明年可以再看到大家，然後功力至少要進步到可以聽得懂那些很硬的議程Orz","categories":[],"tags":[{"name":"PHPConf","slug":"PHPConf","permalink":"https://blog.yunchen.tw/tags/PHPConf/"}]},{"title":"Taipei.py九月-週年聚會","slug":"taipeipy","date":"2013-09-26T16:00:00.000Z","updated":"2017-04-05T14:54:54.000Z","comments":true,"path":"2013/09/27/taipeipy/","link":"","permalink":"https://blog.yunchen.tw/2013/09/27/taipeipy/","excerpt":"","text":"下午最後一節課上的是資管開課的雲端概論，原本我還很擔心說會來不及… 18:30下課，可是19:00就開始了，要趕到CLBC根本不太可能Orz 還好是說以後都會提前半小時下課XD 這樣就不用擔心會趕不上的問題了 www 不過…下課前老師丟下一下 “期末專題 資工系的要做的比資管系好” 然後往我們這看囧… 我們可是提前一年修課的 可以不要這樣嗎Q_Q 提前到CLBC，信上說這個月是Taipei.py成立週年的聚會，所以有小點心、食物可以用 先恭喜Taipei.py滿一歲囉~不過既然只是小點心，那我還是先去吃飯好了…還吃的很飽 一直到聚會開始…小點心送來了…小點心…小點心…結果是好幾盒PIZZA (淚) 天殺的小點心… 拜提前到所賜，上個月玩Mynt玩不太起來，其實我也沒花什麼時間弄 (逃) 因為還很新，找不到什麼詳細的教學文件，只有GitHub簡單的說明 剛好架設Taipei.py新網站謙紀錄的David大大在，所以就跑去問了XD David:”噗 還真的有人馬上拿來用了喔?” 結果居然只是因為沒做編譯，而只有讓後端跑起來，結果才會這樣….Orz 剛好搞什麼競賽玩過tornado，對這些原始碼很有親切感!! 這邊來個簡單的入門好了XD 環境為Ubuntu Mynt 通常會將檔案分做兩個資料夾一個是原始檔，修改都在這邊做另外一個是編譯過的檔案，用來執行後端，讓網站跑起來 1.安裝Mynt ((廢話 $sudo pip install mynt 可以先執行$mynt –version 來確定可以動 不能跑的可能會需要一些額外的python套件，錯誤會顯示還少哪些2.初始化 $mynt init ~/projects/my-mynt-site/ 後面的路徑隨便怎麼動都可以 然後就像下面這個樣子 初始化產生的檔案 3.編譯 我設的目標位置資料夾叫output 第一次才要加 這裡有兩種選擇 看是每次改完網頁後 手動編譯一次:$mynt gen -f 原始檔位置 [目標位置] 或者是修改完偵測到就會自動幫你編譯，但要切ctrl+z讓指令在後頭跑 $mynt watch -f 原始檔位置 [目標位置] -f:force 編譯後產生的檔案 最後當然就是讓Mynt跑起來囉XD 我開的是8888port$mynt serve -p 8888 我的第一個Blogger XD 剩下的就只是修改內容和新增文章不過我還要慢慢研究之後再說(茶) 這次聚會講了不少有趣的東西 像是利用Raspberry Pi 做出一個感應器，就是晚上監視器，人一旦經過就會照光的那種 居然還可以搞成任天堂遊戲機….你碰到植物就會發出叫聲等等鬼詭的機器人 熱門的WhosCall App 也有人來講喔! 這次比較讓我印象深刻的Talk就是Tilespace 這套軟體 Tilespace 製做過程Talk 比dropbox好用很多，Free而且對空間上的應用更加靈活 絕大部分都是用Python寫的，再次感受到Python的強大(茶) 對這次聚會有興趣的可以到 Taipei Python:MOVIE 觀看錄影檔 那就期待下個月的Taipei.py能在看到一些新玩具吧~","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.yunchen.tw/tags/Python/"}]},{"title":"BoT2013偵測與防治技術研討會","slug":"botnet","date":"2013-09-13T16:00:00.000Z","updated":"2017-04-05T14:54:33.000Z","comments":true,"path":"2013/09/14/botnet/","link":"","permalink":"https://blog.yunchen.tw/2013/09/14/botnet/","excerpt":"","text":"這次來到清大參加研討會，有點小遠XD 本來想訂校內的清華會館…感覺就是一整個超棒，很可惜太晚預約Orz 所以只好去找外面的飯店來住，不過聽了第一場Birdmand的演講之後 一整個超值啊!! 來這一趟都值得了，講的真是太棒了 雖然聽說很多東西駭客年會就有講過了，不過那時工作人員排班沒聽到Q_Q 在聽完他的Defcon經驗分享，害我也好想去學開鎖(誤) 國外研討會的資源果然比較多，不過門票錢當然也非同小可(汗) 有機會的話還真想去親眼看看，再那之前還是存好錢再說XD HITCON不愧是號稱最便宜的駭客年會了，門票錢都相當親民 而且有這麼多的熱血志工，我相信明年一定也可以辦成的!! Day 1 再來就是有關Botnet in Taiwan…非常非常精彩的圖表分析… 受害的電腦沒實際聽到數據真的很難相信啊…然後有些受害的單位….moea 除了一般的學校機構 還有最近吵火熱的dpp和kmt ….等等 整個研討會只要是我超想拍照的場次…全部都禁止拍照、攝影、錄音…抖抖 所以那些資料就只能留在腦中做想像了(茶) 就連我想給帥氣的AllenOwn大大來張帥照也不行XD BigData海量資料分析 一窺龐大資料處理的秘密 而至於這9TB是什麼資料 (逃) 如何管理這麼龐大的資料，這世上有Open Source真的太美好了 由威播科技贊助 因為沒地方住，所以只好問問清大人有什麼推薦的好地方 就來到了元首大飯店，還不錯~滿便宜的，可能是因為還沒開學吧 然後就找不到房間了 (? 還好沒有真的找不到XD” 404 Not Found!? 櫃台人員還有跟我確認你是雙人房? 然後結果拿三人房給我… 好吧XD 我也不還你了，賺到了!!房間好大~~ 林哲安大大 就睡那張大床，我本來還期待你躺大字睡的Q_Q 第二天的演講就稍微硬了點 基本上學術研究這方面的人比較多，第一堂的殭屍網路追蹤與分析 同樣也是藉由分析，台灣早已成為殭屍網路一大份子，同樣的…不能攝影XD 整個Botnet聽下來，說真的眼界開了不小，思維變的更加的多樣 像聽完Kenny講的Kill AV in X64，如何繞過檢查，獲得提權和簽章 都會有一種，原來還可以這樣搞的心情… 而且除了大量的分析也介紹了不少工具，並且當場實做，更加印證了， 不須要高超的技術也能控制這些受害的電腦，僅僅只要4000美金，就有這些專門的工具 比起過去，工具成熟度相當高了之外，教學手冊也日益完善，能很快上手這些東西 有些不能錄影我想也是怕流出去會出現ScriptKid吧Orz 今年的Bot2013已經是整個專案的最後一期 至於會不會有Bot2014，就要看有沒有經費補助了，希望明年還有機會再看到 可以確定的是HITCON 會一年比一年精彩XD 看來又要搶票和傷荷包了Q_Q 下星期就開學了，這也是暑假的最後一場活動 當了HITCON志工、參加了各式研討會、加入了Taipei.py、搞什麼競賽、寫了第一隻搶課 可以說是我由始以來收獲最多的暑假，有了方向、目標也更明確，開學也有不少活動 我很感激有這些機會，也謝謝一路上幫助過我的大大XD 開學啊…我還是一點也不想回學校啊Q_Q","categories":[],"tags":[{"name":"Secure","slug":"Secure","permalink":"https://blog.yunchen.tw/tags/Secure/"}]},{"title":"搞什麼搶課系統 FJU搶課系統","slug":"project","date":"2013-09-09T16:00:00.000Z","updated":"2017-04-05T14:54:19.000Z","comments":true,"path":"2013/09/10/project/","link":"","permalink":"https://blog.yunchen.tw/2013/09/10/project/","excerpt":"","text":"星號表示為碎碎念…純粹做好玩給自己用來搶課而已，沒UI、懶的Debug…ps:所以輸入錯誤會卡住orz 第一次寫搶課系統，學校開放搶課的時間僅僅只有4天，中間又有維護時間…學習+摸索套件就花了不少時間，所以難免會有問題產生 開始寫搶課系統，你會發現學校的選課系統真是TMD的爛，介面選上下左右都會有問題本來還以為是我的問題，結果實際用PCMAN去操作…學校選課介面根本~!@#$%^&amp;都沒有去修正嗎囧 整個大半夜就被這個搞死(汗) 用程式碼去硬幹…突然覺得…我當初幹麻去搞什麼搶課系統啊Q_Q 那就先附上搶課系統吧~FJU搶課系統 BETA 1.0.0(File→Download):File 9/9開放第一天的進度 實驗對象: 輔大選課系統使用語言: Python2.7.5用到的套件(皆為內建):getpass - 隱藏輸入密碼，完全不做顯示sys - 做為輸入的好伙伴telnetlib - 連線至 telnet://signcourse.fju.edu.tw的利器time - 做為時間延遲避免輸入過快導致沒有結果及控制Enter其它: py2exe - 將Python檔打包為exe檔，使未有Python環境下仍能運行 GitHub - 已將原始碼公開 特色:一旦完成設定，幾秒內就可完成登入的動作學校選課每10分鐘就斷線，因此設定為每500秒(每0.5秒搶一次)立刻進行重登，並馬上繼續重新搶課Bug is my feature (? 有碰上的困難: 抓到的中文字串必須先由UTF-8轉為BIG5才可辨識 確認ENTER鍵 = “\\r” 還沒讀到、連結到BBS就把資料送出導致沒有結果4.學校介面本身就有問題，需要自己做修正5.開放時間過短，測試時間有限6.若使用者輸入錯誤會導致系統卡住不動或者產生錯誤(累了…尚未修正)7.選課帳號不能重複登入，因此一次只能搶一門 有關選該系所第幾門課順序的問題: 如果我想搶 梅興 的 遠距醫療健康服務 由一進入系所頁面開始，由上往下即第5門課，因此需要輸入5 其它以此類推 整個系統其實是 User Unfriendly的…未來如果 學校仍有搶課系統的話，預計會增加檢查機制以防止產生bug如果能做出GUI介面，將能改善使用上不方便的問題，也不需要打系所((前提是選課系統還在 還要有動力去改XD” 最後我的學分:28…再繼續用搶課系統搶到課會開心嗎…開學會哭出來吧Q_Q 有點後悔報學分學程","categories":[],"tags":[{"name":"Project","slug":"Project","permalink":"https://blog.yunchen.tw/tags/Project/"}]},{"title":"NISRA搞什麼競賽 心得感想(文長)","slug":"nisra","date":"2013-09-03T16:00:00.000Z","updated":"2017-04-05T14:54:01.000Z","comments":true,"path":"2013/09/04/nisra/","link":"","permalink":"https://blog.yunchen.tw/2013/09/04/nisra/","excerpt":"","text":"廢話很多，要看做好心裡準備吧! Web請勿拍打及Injection (? 手下留情啊Q_Q，主機不是我的 首先非常感謝NISRA給了我不論是學習還是有展示成果的地方 能有機會聽到學長\\姐們的建議，能參加像這樣的活動，這是過去我完全不曾想過的 因為在我以前的高中…(默)，想學資訊類的東西永遠只得到 Visual Basic…這又是另外一段故事了 所以我非常的感激現在能有機會學這些以前想碰卻沒機會碰的東西 搞什麼競賽是為了能自主學習而誔生的活動 其實在指考剛完的時候，我一直想嘗試學些什麼，就開始上網Google該學些什麼 然後得到的結果就是從C語言開始XD 就這樣暑假開始慢慢玩，一邊學一邊解書上的題目 然後另一方面，學校開始教起了Java，我也是一步步學，然後一樣的…解題目 剛開始還會因此混亂了寫法導致錯誤，像C有％lf表示 但Java只有％f 諸如此類… 大約在大一下學期的時候把C那本題目解完時，心裡整個空虛想”就這樣?” 我以為是看的不夠多 就又找了本C++，繼續開始從Hello World，因為我以為這個是加強版(? 解完題目就想做什麼東西都可以了!? 然後一樣繼續解後面的題目…就解不下去了 想當然這樣根本沒用麻…就只是單純的一直一直解那些題目……囧 唯一的好處就是上機考的時候比較輕鬆 因為程語就算語言不同 概念也一樣，類似的題目C寫一遍C++又一次Java…噁心 整個對程式語言的熱情在學年快結束的時候已經消逝的差不多了，整個迷失了方向 這時候在NISRA課程從BZ教的用Re套件，到哈比教的十八銅人啦～甚至說可以抓漫畫 我就對Python感到莫名的親切感，然後就一直想學學看，又這麼剛好有搞什麼競賽活動 哈比又跟我說可以像他一樣用Python搞個Wargame網站，就開始有了點興趣 大一從學校只有學到Java比較能做coding，所以也真的沒有想法 好在哈比丟個簡單的範例和tornado關鍵字，再加上皇毅教我怎麼把這個範例架起來才稍為安心 暑假就開始這個搞什麼競賽，然後就像投影片寫的XD 只學Python真的架不起來QQ 皇毅學長也借了我台主機和教了一些簡單的指令讓我可以好好玩 遇到很多問題都找他討論，其實我真的很怕玩壞啊(笑) 開始Google各種網站學HTML&amp;CSS、吃掉了一本電子書，花了不少時間才摸懂 簡單的Python語法也學的差不多了，就開始摸索tornado然後發現中文的東西真的好少好少 開始啃官方的文件，並學著查API，然後慢慢刻XD 因為想學東西，暑假也開始參加很多Confrence 認識很多熱血的志工和朋友，想知道更多Python的東西就參加Taipei.py～ 第一階段發表我完全沒有東西可以展示，只好說說學到的網頁語法 心裡一直在想，完了，搞不好真的會來不及做出來…怎麼辦怎麼辦怎麼辦 註冊介面 還好到第二階段發表網站有了一點樣子，整個超感動，可是之後呢? 我對cookies和資料庫毫無概念，又不太敢問哈比學長，怕他太忙會打擾到 Google好久仍沒有收獲和頭緒，最後才忍不住問 ”學長，有空嗎？有事情想問” 得到peewee這個關鍵字之後就開始努力搞XD，中間不懂的真的太多太多了 可是又不敢再問了，然後就找了很多教學文慢慢摸，最後還是回歸官方文件 找自己需要的功能一個個試，然後運氣很好的發表延期了， 藉此加了鎖按鈕和排名跟修正一些連亂按都會出現的bug，在8/30才完成整個網站 最後搞個投影片、玩玩之前跟龍哥學的GitHub～然後發表 : ) 先不說學到了什麼技術，至少找回了最初對程式語言的熱情，有成果就有動力往下 而且也有了方向，像可以回去細看tornado和peewee的東西，或者玩玩mynt 之後還有PHPCONF要參加，要開始看一下，不然會聽不懂~ 金盾獎還有其它伙伴可以依靠，NISRA真是太棒了!! 加深功力之後再找時間把硬幹的網站改一改XD 不然好糟糕(汗) 就是現在正在搞搶課系統這樣，比起當初什麼都不懂好很多XD” 最後還是要 謝謝評審和學長的肯定 和 曾經為我指點迷津的大大們 &lt;( )&gt; 是AllenOwn大大ㄝ!! &lt;( )&gt; 然後看完我廢話連篇的人 你也很厲害啊…(汗)歡迎大家來入坑這樣(? 使用到的玩具:HTML &amp; CSS - 架站的基本Python2.7.5 - 好程語，不用嗎?Tornado 3.1 - 新手玩後端就上手Peewee - 輕量級的ORMBootstrap - 免於苦刻CSS不過熟綀度還有些不足，看來要多增加經驗值來提升等級XD美工…(默):Photoimpact - BJ4不解釋Orz其它:GitHub - 阿宅的社群網站XD","categories":[],"tags":[{"name":"NISRA","slug":"NISRA","permalink":"https://blog.yunchen.tw/tags/NISRA/"}]},{"title":"宅學營 & Taipei.py聚會","slug":"taipeipy","date":"2013-09-01T16:00:00.000Z","updated":"2017-04-05T14:53:41.000Z","comments":true,"path":"2013/09/02/taipeipy/","link":"","permalink":"https://blog.yunchen.tw/2013/09/02/taipeipy/","excerpt":"","text":"最近有點忙(藉口XD)，雖然學長\\姐說是要用網誌紀錄自己 可是我有的懶(茶)，所以只好藉由早上睡太飽導致現在睡不著來慢慢寫 一連四天的宅學營感覺還真是吃不消(笑) 就是整個課程對小的來說超級硬，不過並不代表說完全沒有收獲 因為藉此被推坑進黑客松嗎囧，請來的大大來談談node.js很棒!! 最重要的收獲是學長們整理的投影片及錄影-YouTube:宅學營就查得到了 當我學到這部分的時候我都會回去看錄影，這對我來說幫助非常大 不管是NISRA或者OpenFoundry，以前不見得懂，可是事後想去一探究竟，是個很棒的資源 也是經由搞什麼競賽，讓我深切的體會到能有這些大大們的錄影是多麼的真貴 因為我用到的時候，都會去看這些，然後再藉由Google找關鍵字來慢慢學 希望之後可以慢慢的上手這些技術O_0 宅學營的第四天，晚上又颱風入境，風雨超大，不過還是想去參加看看 所以就接著宅學營到了CLBC的Taipei.py聚會 因為是第一次參加，想當然沒有半個人認識，突然看到一位熟面孔 這不是HITCON出現的安德魯大大嗎?XD 心中有種安心感這樣(? 這次講者居然有輔大的大一新生!! 太厲害了，不過很可惜不是資工系的~ 利用Blender+Python Script來製做電影 Blender是一套Open Source，可用來製做3D動畫，如果有電影做分享，也可以使用其特效 感覺還不錯，有機會來玩玩看!! 沒有看到他用太多Python的部分，還滿希望能看到他的成品 不過似乎最後因為考試而沒有完成，實在可惜QQ 這次個人深深被Lighting Talk吸引住，在講Taipei.py Logo始源的時候真是太有趣了!! 有興趣的可以看看這次八月的錄影:MOVIE 當然既然來了，就一定要帶玩具回家 Mynt是一套用Python寫的快速生成靜態網頁的套件，看了整個心動，開學立馬來實作XDMYNT 至於其它內容…還是有點吃不消XD 就請客倌們去看錄影吧(逃) 話說回來…好像在哪聽說 搞什麼競賽(Project 發表)是9/2 今天在SF648 19:00 想聽的可以來，但不保證精彩…((被拖走","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.yunchen.tw/tags/Python/"}]},{"title":"COSCUP2013開源人年會","slug":"coscup","date":"2013-08-03T16:00:00.000Z","updated":"2017-04-05T14:53:04.000Z","comments":true,"path":"2013/08/04/coscup/","link":"","permalink":"https://blog.yunchen.tw/2013/08/04/coscup/","excerpt":"","text":"DAY1順便被天龍書攤推入坑 (汗)，不過真的是本好書!! COSCUP 一直是主打網頁與智慧手機與平板 今年則特別強調了OPEN SOURCE來做專案開發 「在COSUP裡，40%聽演講、60%交朋友」 在裡頭遇到不少是HITCON就認識的工作人員，以後應該也會常常看到 也藉機加了一些朋友，不過可惜的是其它工作人員大多都很忙，所以不方便找他們 下次去真的應該要自己印一些名片，也可以順便換食物 (誤 贊助商攤位的大地尋寶活動之一 DAY2順便去了Python Taipei 的攤位看一下，給了我一些資訊-右上的小冊子 因為本身就對Python有興趣，再加上學長有推薦可以去參加看看 所以預計會加入Taipei.py 應該會是我在NISRA之後的第二個社群，還滿讓人期待的 Taipei.py G0V 雖然之前就有聽說過零時政府，不過也是在這次的年會上有所了解 藉由寫程式來改變社會，甚至是監督政府，定期也會舉辦相關的活動 黑客松雖然我也很有興趣，不過行有餘而力不足啊T.T，以後再來挑戰(汗) Mosky-Automatic Printing 今年有超過100位的講師，最多高達8軌 所以有很多不同的議程可以聽聽，不見得都是和程式碼有關 也有很多是經驗談或是專案參與的體悟，多少可以學到一些東西 像是蝦蝦、OPOP、雨蒼的演講都很有趣，其中也有不少爆笑的梗XD Lighting talk 最後壓軸的Lighting talk，不管是什麼confrence總是最人期待的結尾 之前馬小久的報數也是Lighting talk生出來的作品 這次比較有印象的是牛肉湯和Mr.bus的app，有機會可以用看看 最後則是以「這裡”沒有畫面”」「還是沒有畫面」「阿就沒有東西可以說」-國防布啊囧! 1分鐘搞定閃電秀結束了XD 期待明年的COSCUP 2014囉! 47秒的逆襲完售，售票亭老闆準備接招XD","categories":[],"tags":[{"name":"COSCUP","slug":"COSCUP","permalink":"https://blog.yunchen.tw/tags/COSCUP/"}]},{"title":"一小時就從 Data 學會 Python - Mosky","slug":"moskypy","date":"2013-07-27T16:00:00.000Z","updated":"2017-04-05T14:52:48.000Z","comments":true,"path":"2013/07/28/moskypy/","link":"","permalink":"https://blog.yunchen.tw/2013/07/28/moskypy/","excerpt":"","text":"不得不說一下，這次的場地真的是太…棒了!! 整個環境非常的舒適，真的是太適合在這coding了!! CLBC 難怪16:00的時候還有code 馬拉松在這舉辦，真的會讓人想一直待下去XD 這次是第一次聽Mosky的教學，之前SITCON的時候我好像在另一廰聽Unity所以就錯過了 好在影片都有公開就來看看:)MOVIE 此外這次還有orange大大在旁邊做御用助教，所以出問題全推給駭客入侵就對了(? 雖然這次是說新手都可以來參加，但我還是覺得應該要事先了解才會比較快理解 好在已經對Python有一定的認識和自學所以就算講很快也都跟得上XD” 前面大多是在為尚未接觸Python的人做的熱身，之後就進入了正題－從Data處理來認識Python 常見的金字塔兩行搞定，還可以用字串置中來處理－”string”.center(number) 藉由requests、lxml、csv這些套件來處理html、xml和csv格式的檔案 不過最多人卡在這邊都是因為windows安裝的問題orz 黑橘在這顯得特別繁忙XD 有一個ubuntu的主機還真的方便XD，完全沒有這些問題 所以就在旁邊輕鬆喝現場無限提供的飲料 (茶 會眾 O_0~ 有一點不同的是這次是用requests來擷取html的格式 在之前是上BZ助教的Python則是用re來搞定XD，用re來抓字串也很快 當然也少不了Mosky從SITCON就一直強調自己的Clime 礙於時間，所以沒機會用到，之後在來研究看看~ 總之，藉由Data上的處理來實際運用Python，見識到.py各種套件的強大+_+ Come join us !! -Python if來得及搞懂: SQL就決定是用這些了 ;else: txt……orz 筆記learning-python投影片:MOVIEcode:CodeGitHub，龍神發威，現學現賣嗎XD 不過錯過Allen的課倒是滿可惜的O_0","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.yunchen.tw/tags/Python/"}]},{"title":"航向大海的旅程 - GitHub 教學","slug":"github","date":"2013-07-26T16:00:00.000Z","updated":"2017-04-05T14:51:35.000Z","comments":true,"path":"2013/07/27/github/","link":"","permalink":"https://blog.yunchen.tw/2013/07/27/github/","excerpt":"","text":"一個Programmer正是因為追求懶惰所以才會進步-高見龍 龍哥說正是因為懶惰所以才會找一堆奇奇怪怪的方法來讓自己更加輕鬆XD 不過大大也太節省了這些指令了吧XD 我一開始還有點混亂 這樣做未免也太偷懶了吧XD 難道不怕哪天忘記這些簡略的指令嗎? co=checkoutl=log…據本人說這樣可以看起來比較強(? 因為別人都看不懂啊XD 這次OpenFoundry來到大同大學來辦這個教學 因為學校比預想中的小上很多，所以我走過頭了也沒發現orz 這也合理的解釋了龍哥騎車騎過頭所以才會遲到(? 距離上一次聽到高見龍大大的教學好像有幾個月了吧? 當時教的vim還滿有印象的 神龍的vim :GitHub 不過缺點是龍哥的vim設定 少了方個鍵來打code 真的超難習慣的XD” 那個時候就是藉由Git &amp; GitHub來分享設定，不過當時並沒有意識到這個有多好用 今天終於就有機會來好好的認識一下Git 每次的push到GitHub都會儲存時間、評論和動作 Git用來做專案管理超方便的，離線的時候可以只有commit將檔案存在本機 等到有網路可以在push上去，之後需要在別台電腦修改在pull回來就好 每次的push到GitHub都會儲存時間、評論和動作 藉由暫存、add、commit萬一不幸remove 也有checkout救回檔案 滿神奇的~ 遇上多人處理的時候可能產生的衝突 聽說他之前的同事對客戶超不爽就順手把~!@#$%加進commit裡面，結果被發現XD 而我覺得好用的地方在於可以用branch來做分支，還有git-flow來幫助你養成好習慣 居然用branch做出台北捷運圖 太強了XD 這就像是每次猶豫該怎麼做的時候，都暫時把決定的程式註解來考慮要不要使用一樣 龍哥教的滿清晰、簡單~而且也超有耐心的XD 五個多小時聽下來收獲很多 龍神果然厲害啊 雖然他本人都說自己小咖就是了XD","categories":[],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.yunchen.tw/tags/GitHub/"}]},{"title":"第十屆成大資訊安全研習營","slug":"nccu","date":"2013-07-23T16:00:00.000Z","updated":"2017-04-05T14:49:58.000Z","comments":true,"path":"2013/07/24/nccu/","link":"","permalink":"https://blog.yunchen.tw/2013/07/24/nccu/","excerpt":"","text":"今年因為沒有經費的關係，從五天縮水成兩天QQ 所以有不少的東西就這樣被帶過了，因為時間較少，大多都直接衝實戰 比較可惜的是這樣大多的理論就比較不了解，也只能夠事後自己去查詢 另人訝異的是我們明明人在台南，但他聽到NISRA這個詞的時候居然會這麼訝異 “你們是NISRA喔!! 台科大的嗎?” ……真不愧是orange大大啊，名聲居然都跑到這邊了 其它人也得加加油才行了XD 這次在 XSS 和 SQL 注入上有很大的收獲，而且才剛懂HTML語法馬上就有很大的感觸 XSS:利用script的注入，來對使用者做攻擊SQL:藉由資料庫的漏洞來撈出所需獲的資料 果然要踏入資安這一塊會需要懂很多技術啊~ 雲端安全似乎就只有聽演講的樣子，主要是給我們有一點印象而已 密碼加密雖然有實作，知道了windows的加密是以7+7=14的方式也好 Linux是用password和shadow的方式組成，不過更新後這種方式似乎就被改掉了 成大最方便邊的地方是提供了虛擬機來做測試，雖然一開始對這個系統有點混亂XD 好在有”某位學長”在旁邊幫忙，就差不多了解背後這麼做的意義 助教:”我和我的教授都有一個認知，不論是系統安全還是網路安全，最重要的還是各位的人生安全” XD雖然最後是給我們這句話做結束而大家也覺得像開玩笑，不過話中有話嗎 (? 總之希望明年的資安研習營課程能更完整，讓想學的人能有更多的管道做學習~","categories":[],"tags":[{"name":"Secure","slug":"Secure","permalink":"https://blog.yunchen.tw/tags/Secure/"}]},{"title":"HITCON2013 臺灣駭客年會","slug":"hitcon","date":"2013-07-21T16:00:00.000Z","updated":"2017-04-05T14:50:05.000Z","comments":true,"path":"2013/07/22/hitcon/","link":"","permalink":"https://blog.yunchen.tw/2013/07/22/hitcon/","excerpt":"","text":"目前攝影組還沒公佈當天的照片所以來源就是目前上面有滴~感謝其它人的照片喔:) 這次是我第一次參加HITCON，所以感覺還滿新奇的 同時也是第一次加入工作人員的行列，認識了不少熱血的志工:) 行政組::場務組 Yun Chen調查兵團的會服還滿好看的 因為工作人員必須要提早到達會場，所以提前一個小時到達中研院 誇張的是早有一群等候入場的聽眾，也是本次的贊助商之一，我們私下稱其為皇阿碼軍團XD 我們工作人員7:00到達會場，而他們好像坐了有一段時間了，你們到底是多早來啊-___-“ 由於一開始還有些工作人員還搞不太清楚場地的地理位置，所以就去問其它人 “請問一下有人知道第一演講廳的後門在哪嗎?” 沒想到就有人給的回答是:”你難道不知道在這問「後門」是很敏感的嗎?” 哪招啦XD 又不是後面程式XDD orange的演講每次都超級大爆滿，說真的我也很想聽啊QQ 我還錯過Allen在算命攤的演講QQ 不過倒是有聽到提摩大師講的從簡單的例子來看開發者心態 明年一定要買票來聽，當工作人員超累，不過也是一種滿有趣的經驗就是了 從報到的時候開始，就一大堆有的沒的狀況，一堆人不知道自己的T-shirt尺寸 最後靠著活動通人員拿出還在實驗用的手機來掃QRcode才解決問題 有的人則是一早就衝過來問在拿打wargame 囧 我知道你很想打站 但至少也先等活動開始宣佈規則之後再來問麻QQ 真的想打可以像orange所推薦的 打這邊 China 大家會感激你滴 這次的民宿 [ Meaning of Travel ] 旅行的意義 還可以，雖然小，但大家住在一起感覺滿好玩的 而且還有這四隻貓可以玩…….XD 不過晚上就換牠們報復了…半夜一直喵喵叫的 到了茶點時間也很特別，這次託統一外加Even大大冰寶寶的福 哈根大死隨你吃XD” 真的是賺到了(? 也拜這些多樣化的茶點 … 一到這個時間點，對講機的耳機一直傳來 “這裡是南邊(茶點區)目前遭到了嚴重的DDOS(會眾)” 哈哈哈 第二天最讓我印象深刻的就是那位從日本來的講師 剛好我就在他演講的時候輪班，那時候在門外待命，然後突然整個HITCON的攝影組的所有人員 全部都跑了過來，哪尼!!?? 問了其中一位，”你不知道嗎!? 你進去裡面看看” 沒想到居然看到…. Even還很貼心的為”她”也做了一個會眾證明 整個IRC聊天室都是，「講師居然帶著閃光來!!」「我該帶墨鏡來的」「XDDD」 到了中午的時候，日本講師回到了VIP休息室，先讓他的”阿娜答”在這休息一下 就跟著會議助理去吃飯，另外兩場的美國講師也回到了休息室看到了”她” 開始狂笑 然後跟她拍照XD 之後趁著日本講師還沒回來之前，在”她”身上貼了兩張便條紙之後 把”她”轉向面對牆壁，他們整個笑到不行就趕快閃人 … 仔細一看的話 “I am sad :(“ “You left me and let me get alone I’m aid^2” ……XD 不曉得他看到反應如何，因為之後就跑去值班了 最後結束的時候公佈了wargame名次和奇筢獎 HITCON的吉祥物代表果然是你啊XD 休息室就有聽到有人問EVEN是不是要搞死他了XD 最後期望明年的HITCON2014會更好，明年就要努力的搶票了希望其它工作人員能繼續加油XD然後如果可以也打個幾題wargame就更好了~ 閉幕影片:MOVIE //這次綿羊牆，稍為瞄了一下…我覺得當天應該有超過一百組帳號、密碼被公佈在上面//記得做好加密啊XD 明年就不要再被[http] username/pass**//HITCON的網路是很危險的…..","categories":[],"tags":[{"name":"HITCON","slug":"HITCON","permalink":"https://blog.yunchen.tw/tags/HITCON/"}]},{"title":"HTML&CSS&ORZ","slug":"html","date":"2013-07-17T16:00:00.000Z","updated":"2017-04-05T14:44:43.000Z","comments":true,"path":"2013/07/18/html/","link":"","permalink":"https://blog.yunchen.tw/2013/07/18/html/","excerpt":"","text":"當初以為靠著Python就可以架出一個網站 沒想到半路殺出一個tornado套件tornado 本來認為只要把自己要放的內容通通丟到函數庫就ok了（應該？ 可是居然連method在做字串處理的html語法都不懂，何況這樣會很空虛orz… 所以就只好乖乖的去看HTML這個我們每天都在接觸的神秘外星語言 HTML:鋼筋水泥 CSS:油漆、家俱、水晶吊燈XD 摸熟之後最大的感動在於當右鍵點開檢視網頁原始碼的時候，居然…看得懂大部分的架構了!!只可惜script因為功力不夠…所以完全碰壁囧 HITCON2013當然…還可以看到有趣的東西:P 未來的主流是html5，不過我還是先遵守 strict xhtml1.0之後再說吧orz; 既然要架wargame系統的站就要有提交key，而這就扯上了表單form的處理action=”Web處理程序” method=”POST”Web處理程序好像可以用PHP寫或用別人寫好的….果然技術這個坑是越跳越深…而且還越補越大洞這樣不就多了JavaScript和PHP這兩個大洞了…最後真的做得完嗎QAQ 今天是HITCON的場佈，明天就是駭客年會了真令人期待不過今年聽眾大爆滿，工作人員看來是完全沒辦法進去聽了-___-“","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.yunchen.tw/tags/Web/"}]},{"title":"HITCON 工作人員認識茶會","slug":"hitcon-worker","date":"2013-06-28T16:00:00.000Z","updated":"2017-04-05T14:48:28.000Z","comments":true,"path":"2013/06/29/hitcon-worker/","link":"","permalink":"https://blog.yunchen.tw/2013/06/29/hitcon-worker/","excerpt":"","text":"照片取至郭杰穎:) 在台大電機博理館 \\PIZZA/\\PIZZA/\\PIZZA/HITCON2013 CYBERWAR, IN HACK WE TRUSTHITCON2013 這是HITCON舉辦的第九屆，而我還是新手第一次就加入工作人員行列 原因是門票太貴了 哈哈XD…聽說這次的茶會是第一次舉辦的，所以賺到一餐? 藉由這次的機會大家彼此互相認識，才不會因為當天太忙來而沒空打招呼 門機組看來有得忙了…為什麼聽起來好像要應付很多突發狀況orz 不只PIZZA 其實還有很多KFC炸雞、飲料和點心餐(薯條+薯泥)XD 這次最多三軌共30位左右講師進行，然後往年都有兩個投影 一來是講師本身的投影片，另一個則是現場開放的線上聊天室 聊天室除了對講者施壓? 如果現場有sheep的帳密被釣出來還會直接被公佈在上面 哈哈 有參加的各位記得要加密，不要被當成綿羊看待囉:P 本日焦點:orange一直被tag “單身” 快笑死我 hacker誤認orange的電腦，將場務組長的windows多插了一個使用者? 橘子到底是多黑啊XDD 總之，期待今年的HITCON會有什麼有趣的事和演講O_0","categories":[],"tags":[{"name":"HITCON","slug":"HITCON","permalink":"https://blog.yunchen.tw/tags/HITCON/"}]},{"title":"初探Python","slug":"firstpy","date":"2013-06-24T16:00:00.000Z","updated":"2017-04-05T14:43:22.000Z","comments":true,"path":"2013/06/25/firstpy/","link":"","permalink":"https://blog.yunchen.tw/2013/06/25/firstpy/","excerpt":"","text":"Python 是一個輕巧、簡潔且極具魅力的語言 本來還以為又要非常痛苦的從Hello World開始努力掙扎… 還好之前玩過C\\C++滿長一段時間，再加上之前拜學長所賜也曾經摸過幾次 所以就非常好上手啦~ 不過還是有些不太適應就只能慢慢調整了=__=” 有時候看了老半天還不懂意思 常常都是因為Python太直白了囧 我把它想的太過複雜 這也是為什麼Python會這麼令人著迷的原因吧 想到之前用宣告式的語言寫真的會吐血… 暑假期間也有相關的演講，希望聽了能夠更加熟綀一點(? 雖然我是以學習技術為目標，但要弄出一個網站…(抬頭望-__-“ 因為都是要從頭開始…好像會來不及orz Linux指令好多但很好記 -a選項才會吐血 雖然有些意思相同 但還是好多-0- 只能不時回去查查 或者找真男人 man 問問了 哈比學長口中的練武奇才 等哪天打通任督二脈再說(炸 哈哈:P","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.yunchen.tw/tags/Python/"}]},{"title":"近期活動","slug":"activity","date":"2013-06-20T16:00:00.000Z","updated":"2014-01-26T05:11:24.000Z","comments":true,"path":"2013/06/21/activity/","link":"","permalink":"https://blog.yunchen.tw/2013/06/21/activity/","excerpt":"","text":"6/28 [HITCON] 全體工作人員認識茶會 7/19~7/20 [HITCON] 台灣駭客年會 7/21 搞什麼競賽第一階段發表 7/22~7/23 第十屆全國資訊安全研習營 7/27 高見龍-GitHub教學 7/28 [COSCUP] 2013 Hands-on 8/3~8/4 [COSCUP] 開源人年會 8/16 搞什麼競賽第二階段發表 8/26~8/29 2013 暑期宅學營 8/29 Taipei.py 聚會 8/30 搞什麼競賽結果發表 9/12~9/13 [BoT2013] Botnet 偵測與防治技術研討會 突然覺得…好像事情有點多 何況暑假才剛開始拜託不要再有坑給我跳了XD 這樣會讓我想不開啊!(抱頭) 專題還有兩個要發表…希望最後能順利完成orz","categories":[],"tags":[{"name":"Schedule","slug":"Schedule","permalink":"https://blog.yunchen.tw/tags/Schedule/"}]}]}